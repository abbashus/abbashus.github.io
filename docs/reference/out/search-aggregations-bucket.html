<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<title>OpenSearch Reference</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:50%;border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<style>.toc-current{font-weight: bold;} .toc-root{font-family: "Open Sans","DejaVu Sans",sans-serif;
                       font-size: 0.9em;} #content{display: flex; flex-direction: column; flex: 1 1 auto;}
             .nav-footer{text-align: center; margin-top: auto;}
             .nav-footer > p > a {white-space: nowrap;}</style>
</head>
<body id="search-aggregations-bucket" class="book toc2 toc-left">
<div id="header">
<h1>OpenSearch Reference</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<p><span class="toc-root"><a href="index.html">OpenSearch Reference</a></span></p><ul class="sectlevel1">
<li><a href="opensearch-intro.html">What is OpenSearch?</a>
</li>
<li><a href="getting-started.html">Getting started with OpenSearch</a>
</li>
<li><a href="setup.html">Set up OpenSearch</a>
</li>
<li><a href="setup-upgrade.html">Upgrade OpenSearch</a>
</li>
<li><a href="index-modules.html">Index modules</a>
</li>
<li><a href="mapping.html">Mapping</a>
</li>
<li><a href="analysis.html">Text analysis</a>
</li>
<li><a href="index-templates.html">Index templates</a>
</li>
<li><a href="ingest.html">Ingest node</a>
</li>
<li><a href="search-your-data.html">Search your data</a>
</li>
<li><a href="query-dsl.html">Query DSL</a>
</li>
<li><a href="search-aggregations.html">Aggregations</a>
<ul class="sectlevel1">
<li><a href="search-aggregations-bucket.html"><span class="toc-current">Bucket aggregations</span></a>
<ul class="sectlevel2">
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-adjacency-matrix-aggregation">Adjacency matrix aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-autodatehistogram-aggregation">Auto-interval date histogram aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-children-aggregation">Children aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-composite-aggregation">Composite aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-datehistogram-aggregation">Date histogram aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-daterange-aggregation">Date range aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-diversified-sampler-aggregation">Diversified sampler aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-filter-aggregation">Filter aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-filters-aggregation">Filters aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-geodistance-aggregation">Geo-distance aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-geohashgrid-aggregation">Geohash grid aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-geotilegrid-aggregation">Geotile grid aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-global-aggregation">Global aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-histogram-aggregation">Histogram aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-iprange-aggregation">IP range aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-missing-aggregation">Missing aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-nested-aggregation">Nested aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-parent-aggregation">Parent aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-range-aggregation">Range aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-rare-terms-aggregation">Rare terms aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-reverse-nested-aggregation">Reverse nested aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-sampler-aggregation">Sampler aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-significantterms-aggregation">Significant terms aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-significanttext-aggregation">Significant text aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation">Terms aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-variablewidthhistogram-aggregation">Variable width histogram aggregation</a>
</li>
<li><a href="search-aggregations-bucket.html#search-aggregations-bucket-range-field-note">Subtleties of bucketing range fields</a>
</li>
</ul>
</li>
<li><a href="search-aggregations-metrics.html">Metrics aggregations</a>
</li>
<li><a href="search-aggregations-pipeline.html">Pipeline aggregations</a>
</li>
</ul>
</li>
<li><a href="modules-scripting.html">Scripting</a>
</li>
<li><a href="high-availability.html">Set up a cluster for high availability</a>
</li>
<li><a href="snapshot-restore.html">Snapshot and restore</a>
</li>
<li><a href="commands.html">Command line tools</a>
</li>
<li><a href="how-to.html">How To</a>
</li>
<li><a href="glossary.html">Glossary of terms</a>
</li>
<li><a href="rest-apis.html">REST APIs</a>
</li>
<li><a href="breaking-changes.html">Migration guide</a>
</li>
<li><a href="opensearch-release-notes.html">Release notes</a>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="search-aggregations-bucket">Bucket aggregations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Bucket aggregations don&#8217;t calculate metrics over fields like the metrics aggregations do, but instead, they create
buckets of documents. Each bucket is associated with a criterion (depending on the aggregation type) which determines
whether or not a document in the current context "falls" into it. In other words, the buckets effectively define document
sets. In addition to the buckets themselves, the <code>bucket</code> aggregations also compute and return the number of documents
that "fell into" each bucket.</p>
</div>
<div class="paragraph">
<p>Bucket aggregations, as opposed to <code>metrics</code> aggregations, can hold sub-aggregations. These sub-aggregations will be
aggregated for the buckets created by their "parent" bucket aggregation.</p>
</div>
<div class="paragraph">
<p>There are different bucket aggregators, each with a different "bucketing" strategy. Some define a single bucket, some
define fixed number of multiple buckets, and others dynamically create the buckets during the aggregation process.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The maximum number of buckets allowed in a single response is limited by a
dynamic cluster setting named
<a href="settings.html#search-settings-max-buckets"><code>search.max_buckets</code></a>. It defaults to 65,535.
Requests that try to return more than the limit will fail with an exception.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-adjacency-matrix-aggregation">Adjacency matrix aggregation</h3>
<titleabbrev>Adjacency matrix</titleabbrev>
<div class="paragraph">
<p>A bucket aggregation returning a form of <a href="https://en.wikipedia.org/wiki/Adjacency_matrix">adjacency matrix</a>.
The request provides a collection of named filter expressions, similar to the <code>filters</code> aggregation
request.
Each bucket in the response represents a non-empty cell in the matrix of intersecting filters.</p>
</div>
<div class="paragraph">
<p>Given filters named <code>A</code>, <code>B</code> and <code>C</code> the response would return buckets with the following names:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">A</th>
<th class="tableblock halign-left valign-top">B</th>
<th class="tableblock halign-left valign-top">C</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">A</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A&amp;B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A&amp;C</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">B</p></th>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">B&amp;C</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">C</p></th>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The intersecting buckets e.g <code>A&amp;C</code> are labelled using a combination of the two filter names separated by
the ampersand character. Note that the response does not also include a "C&amp;A" bucket as this would be the
same set of documents as "A&amp;C". The matrix is said to be <em>symmetric</em> so we only return half of it. To do this we sort
the filter name strings and always use the lowest of a pair as the value to the left of the "&amp;" separator.</p>
</div>
<div class="paragraph">
<p>An alternative <code>separator</code> parameter can be passed in the request if clients wish to use a separator string
other than the default of the ampersand.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT /emails/_bulk?refresh
{ "index" : { "_id" : 1 } }
{ "accounts" : ["hillary", "sidney"]}
{ "index" : { "_id" : 2 } }
{ "accounts" : ["hillary", "donald"]}
{ "index" : { "_id" : 3 } }
{ "accounts" : ["vladimir", "donald"]}

GET emails/_search
{
  "size": 0,
  "aggs" : {
    "interactions" : {
      "adjacency_matrix" : {
        "filters" : {
          "grpA" : { "terms" : { "accounts" : ["hillary", "sidney"] }},
          "grpB" : { "terms" : { "accounts" : ["donald", "mitt"] }},
          "grpC" : { "terms" : { "accounts" : ["vladimir", "nigel"] }}
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, we analyse email messages to see which groups of individuals
have exchanged messages.
We will get counts for each group individually and also a count of messages for pairs
of groups that have recorded interactions.</p>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "took": 9,
  "timed_out": false,
  "_shards": ...,
  "hits": ...,
  "aggregations": {
    "interactions": {
      "buckets": [
        {
          "key":"grpA",
          "doc_count": 2
        },
        {
          "key":"grpA&amp;grpB",
          "doc_count": 1
        },
        {
          "key":"grpB",
          "doc_count": 2
        },
        {
          "key":"grpB&amp;grpC",
          "doc_count": 1
        },
        {
          "key":"grpC",
          "doc_count": 1
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_usage">Usage</h4>
<div class="paragraph">
<p>On its own this aggregation can provide all of the data required to create an undirected weighted graph.
However, when used with child aggregations such as a <code>date_histogram</code> the results can provide the
additional levels of data required to perform <a href="https://en.wikipedia.org/wiki/Dynamic_network_analysis">dynamic network analysis</a>
where examining interactions <em>over time</em> becomes important.</p>
</div>
</div>
<div class="sect3">
<h4 id="_limitations_2">Limitations</h4>
<div class="paragraph">
<p>For N filters the matrix of buckets produced can be N²/2 and so there is a default maximum
imposed of 100 filters . This setting can be changed using the <code>index.max_adjacency_matrix_filters</code> index-level setting.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-autodatehistogram-aggregation">Auto-interval date histogram aggregation</h3>
<titleabbrev>Auto-interval date histogram</titleabbrev>
<div class="paragraph">
<p>A multi-bucket aggregation similar to the <a href="search-aggregations-bucket.html#search-aggregations-bucket-datehistogram-aggregation">Date histogram aggregation</a> except
instead of providing an interval to use as the width of each bucket, a target number of buckets is provided
indicating the number of buckets needed and the interval of the buckets is automatically chosen to best achieve
that target. The number of buckets returned will always be less than or equal to this target number.</p>
</div>
<div class="paragraph">
<p>The buckets field is optional, and will default to 10 buckets if not specified.</p>
</div>
<div class="paragraph">
<p>Requesting a target of 10 buckets.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "aggs": {
    "sales_over_time": {
      "auto_date_histogram": {
        "field": "date",
        "buckets": 10
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_keys">Keys</h4>
<div class="paragraph">
<p>Internally, a date is represented as a 64 bit number representing a timestamp
in milliseconds-since-the-epoch. These timestamps are returned as the bucket
keys. The <code>key_as_string</code> is the same timestamp converted to a formatted
date string using the format specified with the <code>format</code> parameter:</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
If no <code>format</code> is specified, then it will use the first date
<a href="mapping-params.html#mapping-date-format">format</a> specified in the field mapping.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "aggs": {
    "sales_over_time": {
      "auto_date_histogram": {
        "field": "date",
        "buckets": 5,
        "format": "yyyy-MM-dd" <b class="conum">(1)</b>
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Supports expressive date <a href="search-aggregations-bucket.html#date-format-pattern">format pattern</a></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "sales_over_time": {
      "buckets": [
        {
          "key_as_string": "2015-01-01",
          "key": 1420070400000,
          "doc_count": 3
        },
        {
          "key_as_string": "2015-02-01",
          "key": 1422748800000,
          "doc_count": 2
        },
        {
          "key_as_string": "2015-03-01",
          "key": 1425168000000,
          "doc_count": 2
        }
      ],
      "interval": "1M"
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_intervals">Intervals</h4>
<div class="paragraph">
<p>The interval of the returned buckets is selected based on the data collected by the
aggregation so that the number of buckets returned is less than or equal to the number
requested. The possible intervals returned are:</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
seconds
</td>
<td class="hdlist2">
<p>In multiples of 1, 5, 10 and 30</p>
</td>
</tr>
<tr>
<td class="hdlist1">
minutes
</td>
<td class="hdlist2">
<p>In multiples of 1, 5, 10 and 30</p>
</td>
</tr>
<tr>
<td class="hdlist1">
hours
</td>
<td class="hdlist2">
<p>In multiples of 1, 3 and 12</p>
</td>
</tr>
<tr>
<td class="hdlist1">
days
</td>
<td class="hdlist2">
<p>In multiples of 1, and 7</p>
</td>
</tr>
<tr>
<td class="hdlist1">
months
</td>
<td class="hdlist2">
<p>In multiples of 1, and 3</p>
</td>
</tr>
<tr>
<td class="hdlist1">
years
</td>
<td class="hdlist2">
<p>In multiples of 1, 5, 10, 20, 50 and 100</p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the worst case, where the number of daily buckets are too many for the requested
number of buckets, the number of buckets returned will be 1/7th of the number of
buckets requested.</p>
</div>
</div>
<div class="sect3">
<h4 id="_time_zone">Time Zone</h4>
<div class="paragraph">
<p>Date-times are stored in OpenSearch in UTC.  By default, all bucketing and
rounding is also done in UTC. The <code>time_zone</code> parameter can be used to indicate
that bucketing should use a different time zone.</p>
</div>
<div class="paragraph">
<p>Time zones may either be specified as an ISO 8601 UTC offset (e.g. <code>+01:00</code> or
<code>-08:00</code>)  or as a timezone id, an identifier used in the TZ database like
<code>America/Los_Angeles</code>.</p>
</div>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-00001/log/1?refresh
{
  "date": "2015-10-01T00:30:00Z"
}

PUT my-index-00001/log/2?refresh
{
  "date": "2015-10-01T01:30:00Z"
}

PUT my-index-00001/log/3?refresh
{
  "date": "2015-10-01T02:30:00Z"
}

GET my-index-00001/_search?size=0
{
  "aggs": {
    "by_day": {
      "auto_date_histogram": {
        "field":     "date",
        "buckets" : 3
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>UTC is used if no time zone is specified, three 1-hour buckets are returned
starting at midnight UTC on 1 October 2015:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "by_day": {
      "buckets": [
        {
          "key_as_string": "2015-10-01T00:00:00.000Z",
          "key": 1443657600000,
          "doc_count": 1
        },
        {
          "key_as_string": "2015-10-01T01:00:00.000Z",
          "key": 1443661200000,
          "doc_count": 1
        },
        {
          "key_as_string": "2015-10-01T02:00:00.000Z",
          "key": 1443664800000,
          "doc_count": 1
        }
      ],
      "interval": "1h"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a <code>time_zone</code> of <code>-01:00</code> is specified, then midnight starts at one hour before
midnight UTC:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET my-index-00001/_search?size=0
{
  "aggs": {
    "by_day": {
      "auto_date_histogram": {
        "field":     "date",
        "buckets" : 3,
        "time_zone": "-01:00"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now three 1-hour buckets are still returned but the first bucket starts at
11:00pm on 30 September 2015 since that is the local time for the bucket in
the specified time zone.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "by_day": {
      "buckets": [
        {
          "key_as_string": "2015-09-30T23:00:00.000-01:00", <b class="conum">(1)</b>
          "key": 1443657600000,
          "doc_count": 1
        },
        {
          "key_as_string": "2015-10-01T00:00:00.000-01:00",
          "key": 1443661200000,
          "doc_count": 1
        },
        {
          "key_as_string": "2015-10-01T01:00:00.000-01:00",
          "key": 1443664800000,
          "doc_count": 1
        }
      ],
      "interval": "1h"
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>key_as_string</code> value represents midnight on each day
in the specified time zone.</p>
</li>
</ol>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
When using time zones that follow DST (daylight savings time) changes,
buckets close to the moment when those changes happen can have slightly different
sizes than neighbouring buckets.
For example, consider a DST start in the <code>CET</code> time zone: on 27 March 2016 at 2am,
clocks were turned forward 1 hour to 3am local time. If the result of the aggregation
was daily buckets, the bucket covering that day will only hold data for 23 hours
instead of the usual 24 hours for other buckets. The same is true for shorter intervals
like e.g. 12h. Here, we will have only a 11h bucket on the morning of 27 March when the
DST shift happens.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_scripts">Scripts</h4>
<div class="paragraph">
<p>Like with the normal <a href="search-aggregations-bucket.html#search-aggregations-bucket-datehistogram-aggregation"><code>date_histogram</code></a>, both document level
scripts and value level scripts are supported. This aggregation does not however, support the <code>min_doc_count</code>,
<code>extended_bounds</code>, <code>hard_bounds</code> and <code>order</code> parameters.</p>
</div>
</div>
<div class="sect3">
<h4 id="_minimum_interval_parameter">Minimum Interval parameter</h4>
<div class="paragraph">
<p>The <code>minimum_interval</code> allows the caller to specify the minimum rounding interval that should be used.
This can make the collection process more efficient, as the aggregation will not attempt to round at
any interval lower than <code>minimum_interval</code>.</p>
</div>
<div class="paragraph">
<p>The accepted units for <code>minimum_interval</code> are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>year</p>
</li>
<li>
<p>month</p>
</li>
<li>
<p>day</p>
</li>
<li>
<p>hour</p>
</li>
<li>
<p>minute</p>
</li>
<li>
<p>second</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "aggs": {
    "sale_date": {
      "auto_date_histogram": {
        "field": "date",
        "buckets": 10,
        "minimum_interval": "minute"
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_missing_value">Missing value</h4>
<div class="paragraph">
<p>The <code>missing</code> parameter defines how documents that are missing a value should be treated.
By default they will be ignored but it is also possible to treat them as if they
had a value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "aggs": {
    "sale_date": {
      "auto_date_histogram": {
        "field": "date",
        "buckets": 10,
        "missing": "2000/01/01" <b class="conum">(1)</b>
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Documents without a value in the <code>publish_date</code> field will fall into the same bucket as documents that have the value <code>2000-01-01</code>.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-children-aggregation">Children aggregation</h3>
<titleabbrev>Children</titleabbrev>
<div class="paragraph">
<p>A special single bucket aggregation that selects child documents that have the specified type, as defined in a <a href="mapping-types.html#parent-join"><code>join</code> field</a>.</p>
</div>
<div class="paragraph">
<p>This aggregation has a single option:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>type</code> - The child type that should be selected.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, let&#8217;s say we have an index of questions and answers. The answer type has the following <code>join</code> field in the mapping:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT child_example
{
  "mappings": {
    "properties": {
      "join": {
        "type": "join",
        "relations": {
          "question": "answer"
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>question</code> document contain a tag field and the <code>answer</code> documents contain an owner field. With the <code>children</code>
aggregation the tag buckets can be mapped to the owner buckets in a single request even though the two fields exist in
two different kinds of documents.</p>
</div>
<div class="paragraph">
<p>An example of a question document:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT child_example/_doc/1
{
  "join": {
    "name": "question"
  },
  "body": "&lt;p&gt;I have Windows 2003 server and i bought a new Windows 2008 server...",
  "title": "Whats the best way to file transfer my site from server to a newer one?",
  "tags": [
    "windows-server-2003",
    "windows-server-2008",
    "file-transfer"
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Examples of <code>answer</code> documents:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT child_example/_doc/2?routing=1
{
  "join": {
    "name": "answer",
    "parent": "1"
  },
  "owner": {
    "location": "Norfolk, United Kingdom",
    "display_name": "Sam",
    "id": 48
  },
  "body": "&lt;p&gt;Unfortunately you're pretty much limited to FTP...",
  "creation_date": "2009-05-04T13:45:37.030"
}

PUT child_example/_doc/3?routing=1&amp;refresh
{
  "join": {
    "name": "answer",
    "parent": "1"
  },
  "owner": {
    "location": "Norfolk, United Kingdom",
    "display_name": "Troll",
    "id": 49
  },
  "body": "&lt;p&gt;Use Linux...",
  "creation_date": "2009-05-05T13:45:37.030"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following request can be built that connects the two together:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST child_example/_search?size=0
{
  "aggs": {
    "top-tags": {
      "terms": {
        "field": "tags.keyword",
        "size": 10
      },
      "aggs": {
        "to-answers": {
          "children": {
            "type" : "answer" <b class="conum">(1)</b>
          },
          "aggs": {
            "top-names": {
              "terms": {
                "field": "owner.display_name.keyword",
                "size": 10
              }
            }
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>type</code> points to type / mapping with the name <code>answer</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The above example returns the top question tags and per tag the top answer owners.</p>
</div>
<div class="paragraph">
<p>Possible response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "took": 25,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped" : 0,
    "failed": 0
  },
  "hits": {
    "total" : {
      "value": 3,
      "relation": "eq"
    },
    "max_score": null,
    "hits": []
  },
  "aggregations": {
    "top-tags": {
      "doc_count_error_upper_bound": 0,
      "sum_other_doc_count": 0,
      "buckets": [
        {
          "key": "file-transfer",
          "doc_count": 1, <b class="conum">(1)</b>
          "to-answers": {
            "doc_count": 2, <b class="conum">(2)</b>
            "top-names": {
              "doc_count_error_upper_bound": 0,
              "sum_other_doc_count": 0,
              "buckets": [
                {
                  "key": "Sam",
                  "doc_count": 1
                },
                {
                  "key": "Troll",
                  "doc_count": 1
                }
              ]
            }
          }
        },
        {
          "key": "windows-server-2003",
          "doc_count": 1, <b class="conum">(1)</b>
          "to-answers": {
            "doc_count": 2, <b class="conum">(2)</b>
            "top-names": {
              "doc_count_error_upper_bound": 0,
              "sum_other_doc_count": 0,
              "buckets": [
                {
                  "key": "Sam",
                  "doc_count": 1
                },
                {
                  "key": "Troll",
                  "doc_count": 1
                }
              ]
            }
          }
        },
        {
          "key": "windows-server-2008",
          "doc_count": 1, <b class="conum">(1)</b>
          "to-answers": {
            "doc_count": 2, <b class="conum">(2)</b>
            "top-names": {
              "doc_count_error_upper_bound": 0,
              "sum_other_doc_count": 0,
              "buckets": [
                {
                  "key": "Sam",
                  "doc_count": 1
                },
                {
                  "key": "Troll",
                  "doc_count": 1
                }
              ]
            }
          }
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The number of question documents with the tag <code>file-transfer</code>, <code>windows-server-2003</code>, etc.</p>
</li>
<li>
<p>The number of answer documents that are related to question documents with the tag <code>file-transfer</code>, <code>windows-server-2003</code>, etc.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-composite-aggregation">Composite aggregation</h3>
<titleabbrev>Composite</titleabbrev>
<div class="paragraph">
<p>A multi-bucket aggregation that creates composite buckets from different sources.</p>
</div>
<div class="paragraph">
<p>Unlike the other <code>multi-bucket</code> aggregations, you can use the <code>composite</code>
aggregation to paginate <strong>all</strong> buckets from a multi-level aggregation
efficiently. This aggregation provides a way to stream <strong>all</strong> buckets of a
specific aggregation, similar to what
<a href="paginate-search-results.html#scroll-search-results">scroll</a> does for documents.</p>
</div>
<div class="paragraph">
<p>The composite buckets are built from the combinations of the
values extracted/created for each document and each combination is considered as
a composite bucket.</p>
</div>
<div class="paragraph">
<p>For example, consider the following document:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "keyword": ["foo", "bar"],
  "number": [23, 65, 76]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using <code>keyword</code> and <code>number</code> as source fields for the aggregation results in
the following composite buckets:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{ "keyword": "foo", "number": 23 }
{ "keyword": "foo", "number": 65 }
{ "keyword": "foo", "number": 76 }
{ "keyword": "bar", "number": 23 }
{ "keyword": "bar", "number": 65 }
{ "keyword": "bar", "number": 76 }</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_value_sources">Value sources</h4>
<div class="paragraph">
<p>The <code>sources</code> parameter defines the source fields to use when building
composite buckets. The order that the <code>sources</code> are defined controls the order
that the keys are returned.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
You must use a unique name when defining <code>sources</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>sources</code> parameter can be any of the following types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="search-aggregations-bucket.html#_terms">Terms</a></p>
</li>
<li>
<p><a href="search-aggregations-bucket.html#_histogram">Histogram</a></p>
</li>
<li>
<p><a href="search-aggregations-bucket.html#_date_histogram">Date histogram</a></p>
</li>
<li>
<p><a href="search-aggregations-bucket.html#_geotile_grid">GeoTile grid</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_terms">Terms</h5>
<div class="paragraph">
<p>The <code>terms</code> value source is equivalent to a simple <code>terms</code> aggregation.
The values are extracted from a field or a script exactly like the <code>terms</code> aggregation.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "product": { "terms": { "field": "product" } } }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Like the <code>terms</code> aggregation it is also possible to use a script to create the values for the composite buckets:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          {
            "product": {
              "terms": {
                "script": {
                  "source": "doc['product'].value",
                  "lang": "painless"
                }
              }
            }
          }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_histogram">Histogram</h5>
<div class="paragraph">
<p>The <code>histogram</code> value source can be applied on numeric values to build fixed size
interval over the values. The <code>interval</code> parameter defines how the numeric values should be
transformed. For instance an <code>interval</code> set to 5 will translate any numeric values to its closest interval,
a value of <code>101</code> would be translated to <code>100</code> which is the key for the interval between 100 and 105.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "histo": { "histogram": { "field": "price", "interval": 5 } } }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The values are built from a numeric field or a script that return numerical values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          {
            "histo": {
              "histogram": {
                "interval": 5,
                "script": {
                  "source": "doc['price'].value",
                  "lang": "painless"
                }
              }
            }
          }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_date_histogram">Date histogram</h5>
<div class="paragraph">
<p>The <code>date_histogram</code> is similar to the <code>histogram</code> value source except that the interval
is specified by date/time expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d" } } }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example above creates an interval per day and translates all <code>timestamp</code> values to the start of its closest intervals.
Available expressions for interval: <code>year</code>, <code>quarter</code>, <code>month</code>, <code>week</code>, <code>day</code>, <code>hour</code>, <code>minute</code>, <code>second</code></p>
</div>
<div class="paragraph">
<p>Time values can also be specified via abbreviations supported by <a href="api-conventions.html#time-units">time units</a> parsing.
Note that fractional time values are not supported, but you can address this by shifting to another
time unit (e.g., <code>1.5h</code> could instead be specified as <code>90m</code>).</p>
</div>
<div class="paragraph">
<p><strong>Format</strong></p>
</div>
<div class="paragraph">
<p>Internally, a date is represented as a 64 bit number representing a timestamp in milliseconds-since-the-epoch.
These timestamps are returned as the bucket keys. It is possible to return a formatted date string instead using
the format specified with the format parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          {
            "date": {
              "date_histogram": {
                "field": "timestamp",
                "calendar_interval": "1d",
                "format": "yyyy-MM-dd"         <b class="conum">(1)</b>
              }
            }
          }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Supports expressive date <a href="search-aggregations-bucket.html#date-format-pattern">format pattern</a></p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Time Zone</strong></p>
</div>
<div class="paragraph">
<p>Date-times are stored in OpenSearch in UTC.  By default, all bucketing and
rounding is also done in UTC. The <code>time_zone</code> parameter can be used to indicate
that bucketing should use a different time zone.</p>
</div>
<div class="paragraph">
<p>Time zones may either be specified as an ISO 8601 UTC offset (e.g. <code>+01:00</code> or
<code>-08:00</code>)  or as a timezone id, an identifier used in the TZ database like
<code>America/Los_Angeles</code>.</p>
</div>
<div class="paragraph">
<p><strong>Offset</strong></p>
</div>
<div class="paragraph">
<p>Use the <code>offset</code> parameter to change the start value of each bucket by the
specified positive (<code>+</code>) or negative offset (<code>-</code>) duration, such as <code>1h</code> for
an hour, or <code>1d</code> for a day. See <a href="api-conventions.html#time-units">Time units</a> for more possible time
duration options.</p>
</div>
<div class="paragraph">
<p>For example, when using an interval of <code>day</code>, each bucket runs from midnight
to midnight. Setting the <code>offset</code> parameter to <code>+6h</code> changes each bucket
to run from 6am to 6am:</p>
</div>
<div id="composite-aggregation-datehistogram-offset-example" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001/_doc/1?refresh
{
  "date": "2015-10-01T05:30:00Z"
}

PUT my-index-000001/_doc/2?refresh
{
  "date": "2015-10-01T06:30:00Z"
}

GET my-index-000001/_search?size=0
{
  "aggs": {
    "my_buckets": {
      "composite" : {
        "sources" : [
          {
            "date": {
              "date_histogram" : {
                "field": "date",
                "calendar_interval": "day",
                "offset": "+6h",
                "format": "iso8601"
              }
            }
          }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of a single bucket starting at midnight, the above request groups the
documents into buckets starting at 6am:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "my_buckets": {
      "after_key": { "date": "2015-10-01T06:00:00.000Z" },
      "buckets": [
        {
          "key": { "date": "2015-09-30T06:00:00.000Z" },
          "doc_count": 1
        },
        {
          "key": { "date": "2015-10-01T06:00:00.000Z" },
          "doc_count": 1
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The start <code>offset</code> of each bucket is calculated after <code>time_zone</code>
adjustments have been made.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_geotile_grid">GeoTile grid</h5>
<div class="paragraph">
<p>The <code>geotile_grid</code> value source works on <code>geo_point</code> fields and groups points into buckets that represent
cells in a grid. The resulting grid can be sparse and only contains cells
that have matching data. Each cell corresponds to a
<a href="https://en.wikipedia.org/wiki/Tiled_web_map">map tile</a> as used by many online map
sites. Each cell is labeled using a "{zoom}/{x}/{y}" format, where zoom is equal
to the user-specified precision.</p>
</div>
<div id="composite-aggregation-geotilegrid-example" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "tile": { "geotile_grid": { "field": "location", "precision": 8 } } }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Precision</strong></p>
</div>
<div class="paragraph">
<p>The highest-precision geotile of length 29 produces cells that cover
less than 10cm by 10cm of land. This precision is uniquely suited for composite aggregations as each
tile does not have to be generated and loaded in memory.</p>
</div>
<div class="paragraph">
<p>See <a href="https://wiki.openstreetmap.org/wiki/Zoom_levels">Zoom level documentation</a>
on how precision (zoom) correlates to size on the ground. Precision for this
aggregation can be between 0 and 29, inclusive.</p>
</div>
<div class="paragraph">
<p><strong>Bounding box filtering</strong></p>
</div>
<div class="paragraph">
<p>The geotile source can optionally be constrained to a specific geo bounding box, which reduces
the range of tiles used. These bounds are useful when only a specific part of a geographical area needs high
precision tiling.</p>
</div>
<div id="composite-aggregation-geotilegrid-boundingbox-example" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          {
            "tile": {
              "geotile_grid": {
                "field": "location",
                "precision": 22,
                "bounds": {
                  "top_left": "52.4, 4.9",
                  "bottom_right": "52.3, 5.0"
                }
              }
            }
          }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_mixing_different_value_sources">Mixing different value sources</h5>
<div class="paragraph">
<p>The <code>sources</code> parameter accepts an array of value sources.
It is possible to mix different value sources to create composite buckets.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d" } } },
          { "product": { "terms": { "field": "product" } } }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will create composite buckets from the values created by two value sources, a <code>date_histogram</code> and a <code>terms</code>.
Each bucket is composed of two values, one for each value source defined in the aggregation.
Any type of combinations is allowed and the order in the array is preserved
in the composite buckets.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "shop": { "terms": { "field": "shop" } } },
          { "product": { "terms": { "field": "product" } } },
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d" } } }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_order">Order</h4>
<div class="paragraph">
<p>By default the composite buckets are sorted by their natural ordering. Values are sorted
in ascending order of their values. When multiple value sources are requested, the ordering is done per value
source, the first value of the composite bucket is compared to the first value of the other composite bucket and if they are equals the
next values in the composite bucket are used for tie-breaking. This means that the composite bucket
 <code>[foo, 100]</code> is considered smaller than <code>[foobar, 0]</code> because <code>foo</code> is considered smaller than <code>foobar</code>.
It is possible to define the direction of the sort for each value source by setting <code>order</code> to <code>asc</code> (default value)
or <code>desc</code> (descending order) directly in the value source definition.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d", "order": "desc" } } },
          { "product": { "terms": { "field": "product", "order": "asc" } } }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>... will sort the composite bucket in descending order when comparing values from the <code>date_histogram</code> source
and in ascending order when comparing values from the <code>terms</code> source.</p>
</div>
</div>
<div class="sect3">
<h4 id="_missing_bucket">Missing bucket</h4>
<div class="paragraph">
<p>By default documents without a value for a given source are ignored.
It is possible to include them in the response by setting <code>missing_bucket</code> to
<code>true</code> (defaults to <code>false</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "product_name": { "terms": { "field": "product", "missing_bucket": true } } }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above the source <code>product_name</code> will emit an explicit <code>null</code> value
for documents without a value for the field <code>product</code>.
The <code>order</code> specified in the source dictates whether the <code>null</code> values should rank
first (ascending order, <code>asc</code>) or last (descending order, <code>desc</code>).</p>
</div>
</div>
<div class="sect3">
<h4 id="_size">Size</h4>
<div class="paragraph">
<p>The <code>size</code> parameter can be set to define how many composite buckets should be returned.
Each composite bucket is considered as a single bucket, so setting a size of 10 will return the
first 10 composite buckets created from the value sources.
The response contains the values for each composite bucket in an array containing the values extracted
from each value source. Defaults to <code>10</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_pagination">Pagination</h4>
<div class="paragraph">
<p>If the number of composite buckets is too high (or unknown) to be returned in a single response
it is possible to split the retrieval in multiple requests.
Since the composite buckets are flat by nature, the requested <code>size</code> is exactly the number of composite buckets
that will be returned in the response (assuming that they are at least <code>size</code> composite buckets to return).
If all composite buckets should be retrieved it is preferable to use a small size (<code>100</code> or <code>1000</code> for instance)
and then use the <code>after</code> parameter to retrieve the next results.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "size": 2,
        "sources": [
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d" } } },
          { "product": { "terms": { "field": "product" } } }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>... returns:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "my_buckets": {
      "after_key": {
        "date": 1494288000000,
        "product": "mad max"
      },
      "buckets": [
        {
          "key": {
            "date": 1494201600000,
            "product": "rocky"
          },
          "doc_count": 1
        },
        {
          "key": {
            "date": 1494288000000,
            "product": "mad max"
          },
          "doc_count": 2
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To get the next set of buckets, resend the same aggregation with the <code>after</code>
parameter set to the <code>after_key</code> value returned in the response.
For example, this request uses the <code>after_key</code> value provided in the previous response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "size": 2,
        "sources": [
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d", "order": "desc" } } },
          { "product": { "terms": { "field": "product", "order": "asc" } } }
        ],
        "after": { "date": 1494288000000, "product": "mad max" } <b class="conum">(1)</b>
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Should restrict the aggregation to buckets that sort <strong>after</strong> the provided values.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The <code>after_key</code> is <strong>usually</strong> the key to the last bucket returned in
the response, but that isn&#8217;t guaranteed. Always use the returned <code>after_key</code> instead
of derriving it from the buckets.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_early_termination">Early termination</h4>
<div class="paragraph">
<p>For optimal performance the <a href="index-modules-index-sorting.html">index sort</a> should be set on the index so that it matches
parts or fully the source order in the composite aggregation.
For instance the following index sort:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001
{
  "settings": {
    "index": {
      "sort.field": [ "username", "timestamp" ],   <b class="conum">(1)</b>
      "sort.order": [ "asc", "desc" ]              <b class="conum">(2)</b>
    }
  },
  "mappings": {
    "properties": {
      "username": {
        "type": "keyword",
        "doc_values": true
      },
      "timestamp": {
        "type": "date"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This index is sorted by <code>username</code> first then by <code>timestamp</code>.</p>
</li>
<li>
<p>&#8230;&#8203; in ascending order for the <code>username</code> field and in descending order for the <code>timestamp</code> field.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>could be used to optimize these composite aggregations:</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "user_name": { "terms": { "field": "user_name" } } }     <b class="conum">(1)</b>
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>user_name</code> is a prefix of the index sort and the order matches (<code>asc</code>).</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "user_name": { "terms": { "field": "user_name" } } }, <b class="conum">(1)</b>
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d", "order": "desc" } } } <b class="conum">(2)</b>
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>user_name</code> is a prefix of the index sort and the order matches (<code>asc</code>).</p>
</li>
<li>
<p><code>timestamp</code> matches also the prefix and the order matches (<code>desc</code>).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In order to optimize the early termination it is advised to set <code>track_total_hits</code> in the request
to <code>false</code>. The number of total hits that match the request can be retrieved on the first request
and it would be costly to compute this number on every page:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "size": 0,
  "track_total_hits": false,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "user_name": { "terms": { "field": "user_name" } } },
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d", "order": "desc" } } }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the order of the source is important, in the example below switching the <code>user_name</code> with the <code>timestamp</code>
would deactivate the sort optimization since this configuration wouldn&#8217;t match the index sort specification.
If the order of sources do not matter for your use case you can follow these simple guidelines:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Put the fields with the highest cardinality first.</p>
</li>
<li>
<p>Make sure that the order of the field matches the order of the index sort.</p>
</li>
<li>
<p>Put multi-valued fields last since they cannot be used for early termination.</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<a href="index-modules-index-sorting.html">index sort</a> can slowdown indexing, it is very important to test index sorting
with your specific use case and dataset to ensure that it matches your requirement. If it doesn&#8217;t note that <code>composite</code>
aggregations will also try to early terminate on non-sorted indices if the query matches all document (<code>match_all</code> query).
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_sub_aggregations">Sub-aggregations</h4>
<div class="paragraph">
<p>Like any <code>multi-bucket</code> aggregations the <code>composite</code> aggregation can hold sub-aggregations.
These sub-aggregations can be used to compute other buckets or statistics on each composite bucket created by this
parent aggregation.
For instance the following example computes the average value of a field
per composite bucket:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "size": 0,
  "aggs": {
    "my_buckets": {
      "composite": {
        "sources": [
          { "date": { "date_histogram": { "field": "timestamp", "calendar_interval": "1d", "order": "desc" } } },
          { "product": { "terms": { "field": "product" } } }
        ]
      },
      "aggregations": {
        "the_avg": {
          "avg": { "field": "price" }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>... returns:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "my_buckets": {
      "after_key": {
        "date": 1494201600000,
        "product": "rocky"
      },
      "buckets": [
        {
          "key": {
            "date": 1494460800000,
            "product": "apocalypse now"
          },
          "doc_count": 1,
          "the_avg": {
            "value": 10.0
          }
        },
        {
          "key": {
            "date": 1494374400000,
            "product": "mad max"
          },
          "doc_count": 1,
          "the_avg": {
            "value": 27.0
          }
        },
        {
          "key": {
            "date": 1494288000000,
            "product": "mad max"
          },
          "doc_count": 2,
          "the_avg": {
            "value": 22.5
          }
        },
        {
          "key": {
            "date": 1494201600000,
            "product": "rocky"
          },
          "doc_count": 1,
          "the_avg": {
            "value": 10.0
          }
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_pipeline_aggregations">Pipeline aggregations</h4>
<div class="paragraph">
<p>The composite agg is not currently compatible with pipeline aggregations, nor does it make sense in most cases.
E.g. due to the paging nature of composite aggs, a single logical partition (one day for example) might be spread
over multiple pages.  Since pipeline aggregations are purely post-processing on the final list of buckets,
running something like a derivative on a composite page could lead to inaccurate results as it is only taking into
account a "partial" result on that page.</p>
</div>
<div class="paragraph">
<p>Pipeline aggs that are self contained to a single bucket (such as <code>bucket_selector</code>) might be supported in the future.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-datehistogram-aggregation">Date histogram aggregation</h3>
<titleabbrev>Date histogram</titleabbrev>
<div class="paragraph">
<p>This multi-bucket aggregation is similar to the normal
<a href="search-aggregations-bucket.html#search-aggregations-bucket-histogram-aggregation">histogram</a>, but it can
only be used with date or date range values. Because dates are represented internally in
OpenSearch as long values, it is possible, but not as accurate, to use the
normal <code>histogram</code> on dates as well. The main difference in the two APIs is
that here the interval can be specified using date/time expressions. Time-based
data requires special support because time-based intervals are not always a
fixed length.</p>
</div>
<div class="paragraph">
<p>Like the histogram, values are rounded <strong>down</strong> into the closest bucket. For
example, if the interval is a calendar day, <code>2020-01-03T07:00:01Z</code> is rounded to
<code>2020-01-03T00:00:00Z</code>. Values are rounded as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bucket_key = Math.floor(value / interval) * interval</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="calendar_and_fixed_intervals">Calendar and fixed intervals</h4>
<div class="paragraph">
<p>When configuring a date histogram aggregation, the interval can be specified
in two manners: calendar-aware time intervals, and fixed time intervals.</p>
</div>
<div class="paragraph">
<p>Calendar-aware intervals understand that daylight savings changes the length
of specific days, months have different amounts of days, and leap seconds can
be tacked onto a particular year.</p>
</div>
<div class="paragraph">
<p>Fixed intervals are, by contrast, always multiples of SI units and do not change
based on calendaring context.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Combined <code>interval</code> field is deprecated</div>
<div class="paragraph">
<p>This behavior has been deprecated in favor of two new, explicit fields: <code>calendar_interval</code>
and <code>fixed_interval</code>.</p>
</div>
<div class="paragraph">
<p>By forcing a choice between calendar and intervals up front, the semantics of the interval
are clear to the user immediately and there is no ambiguity.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="calendar_intervals">Calendar intervals</h4>
<div class="paragraph">
<p>Calendar-aware intervals are configured with the <code>calendar_interval</code> parameter.
You can specify calendar intervals using the unit name, such as <code>month</code>, or as a
single unit quantity, such as <code>1M</code>. For example, <code>day</code> and <code>1d</code> are equivalent.
Multiple quantities, such as <code>2d</code>, are not supported.</p>
</div>
<div class="paragraph">
<p>The accepted calendar intervals are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>minute</code>, <code>1m</code> </dt>
<dd>
<p>All minutes begin at 00 seconds.
One minute is the interval between 00 seconds of the first minute and 00
seconds of the following minute in the specified time zone, compensating for any
intervening leap seconds, so that the number of minutes and seconds past the
hour is the same at the start and end.</p>
</dd>
<dt class="hdlist1"><code>hour</code>, <code>1h</code> </dt>
<dd>
<p>All hours begin at 00 minutes and 00 seconds.
One hour (1h) is the interval between 00:00 minutes of the first hour and 00:00
minutes of the following hour in the specified time zone, compensating for any
intervening leap seconds, so that the number of minutes and seconds past the hour
is the same at the start and end.</p>
</dd>
<dt class="hdlist1"><code>day</code>, <code>1d</code> </dt>
<dd>
<p>All days begin at the earliest possible time, which is usually 00:00:00
(midnight).
One day (1d) is the interval between the start of the day and the start of
of the following day in the specified time zone, compensating for any intervening
time changes.</p>
</dd>
<dt class="hdlist1"><code>week</code>, <code>1w</code> </dt>
<dd>
<p>One week is the interval between the start day_of_week:hour:minute:second
and the same day of the week and time of the following week in the specified
time zone.</p>
</dd>
<dt class="hdlist1"><code>month</code>, <code>1M</code> </dt>
<dd>
<p>One month is the interval between the start day of the month and time of
day and the same day of the month and time of the following month in the specified
time zone, so that the day of the month and time of day are the same at the start
and end.</p>
</dd>
<dt class="hdlist1"><code>quarter</code>, <code>1q</code> </dt>
<dd>
<p>One quarter is the interval between the start day of the month and
time of day and the same day of the month and time of day three months later,
so that the day of the month and time of day are the same at the start and end.<br></p>
</dd>
<dt class="hdlist1"><code>year</code>, <code>1y</code> </dt>
<dd>
<p>One year is the interval between the start day of the month and time of
day and the same day of the month and time of day the following year in the
specified time zone, so that the date and time are the same at the start and end.<br></p>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="calendar_interval_examples">Calendar interval examples</h5>
<div class="paragraph">
<p>As an example, here is an aggregation requesting bucket intervals of a month in calendar time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "aggs": {
    "sales_over_time": {
      "date_histogram": {
        "field": "date",
        "calendar_interval": "month"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you attempt to use multiples of calendar units, the aggregation will fail because only
singular calendar units are supported:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "aggs": {
    "sales_over_time": {
      "date_histogram": {
        "field": "date",
        "calendar_interval": "2d"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "error" : {
    "root_cause" : [...],
    "type" : "x_content_parse_exception",
    "reason" : "[1:82] [date_histogram] failed to parse field [calendar_interval]",
    "caused_by" : {
      "type" : "illegal_argument_exception",
      "reason" : "The supplied interval [2d] could not be parsed as a calendar interval.",
      "stack_trace" : "java.lang.IllegalArgumentException: The supplied interval [2d] could not be parsed as a calendar interval."
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="fixed_intervals">Fixed intervals</h4>
<div class="paragraph">
<p>Fixed intervals are configured with the <code>fixed_interval</code> parameter.</p>
</div>
<div class="paragraph">
<p>In contrast to calendar-aware intervals, fixed intervals are a fixed number of SI
units and never deviate, regardless of where they fall on the calendar. One second
is always composed of <code>1000ms</code>. This allows fixed intervals to be specified in
any multiple of the supported units.</p>
</div>
<div class="paragraph">
<p>However, it means fixed intervals cannot express other units such as months,
since the duration of a month is not a fixed quantity. Attempting to specify
a calendar interval like month or quarter will throw an exception.</p>
</div>
<div class="paragraph">
<p>The accepted units for fixed intervals are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">milliseconds (<code>ms</code>) </dt>
<dd>
<p>A single millisecond. This is a very, very small interval.</p>
</dd>
<dt class="hdlist1">seconds (<code>s</code>) </dt>
<dd>
<p>Defined as 1000 milliseconds each.</p>
</dd>
<dt class="hdlist1">minutes (<code>m</code>) </dt>
<dd>
<p>Defined as 60 seconds each (60,000 milliseconds).
All minutes begin at 00 seconds.</p>
</dd>
<dt class="hdlist1">hours (<code>h</code>) </dt>
<dd>
<p>Defined as 60 minutes each (3,600,000 milliseconds).
All hours begin at 00 minutes and 00 seconds.</p>
</dd>
<dt class="hdlist1">days (<code>d</code>) </dt>
<dd>
<p>Defined as 24 hours (86,400,000 milliseconds).
All days begin at the earliest possible time, which is usually 00:00:00
(midnight).</p>
</dd>
</dl>
</div>
<div class="sect4">
<h5 id="fixed_interval_examples">Fixed interval examples</h5>
<div class="paragraph">
<p>If we try to recreate the "month" <code>calendar_interval</code> from earlier, we can approximate that with
30 fixed days:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "aggs": {
    "sales_over_time": {
      "date_histogram": {
        "field": "date",
        "fixed_interval": "30d"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>But if we try to use a calendar unit that is not supported, such as weeks, we&#8217;ll get an exception:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "aggs": {
    "sales_over_time": {
      "date_histogram": {
        "field": "date",
        "fixed_interval": "2w"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "error" : {
    "root_cause" : [...],
    "type" : "x_content_parse_exception",
    "reason" : "[1:82] [date_histogram] failed to parse field [fixed_interval]",
    "caused_by" : {
      "type" : "illegal_argument_exception",
      "reason" : "failed to parse setting [date_histogram.fixedInterval] with value [2w] as a time value: unit is missing or unrecognized",
      "stack_trace" : "java.lang.IllegalArgumentException: failed to parse setting [date_histogram.fixedInterval] with value [2w] as a time value: unit is missing or unrecognized"
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="datehistogram-aggregation-notes">Date histogram usage notes</h4>
<div class="paragraph">
<p>In all cases, when the specified end time does not exist, the actual end time is
the closest available time after the specified end.</p>
</div>
<div class="paragraph">
<p>Widely distributed applications must also consider vagaries such as countries that
start and stop daylight savings time at 12:01 A.M., so end up with one minute of
Sunday followed by an additional 59 minutes of Saturday once a year, and countries
that decide to move across the international date line. Situations like
that can make irregular time zone offsets seem easy.</p>
</div>
<div class="paragraph">
<p>As always, rigorous testing, especially around time-change events, will ensure
that your time interval specification is
what you intend it to be.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
To avoid unexpected results, all connected servers and clients must
sync to a reliable network time service.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Fractional time values are not supported, but you can address this by
shifting to another time unit (e.g., <code>1.5h</code> could instead be specified as <code>90m</code>).
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
You can also specify time values using abbreviations supported by
<a href="api-conventions.html#time-units">time units</a> parsing.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="datehistogram-aggregation-keys">Keys</h4>
<div class="paragraph">
<p>Internally, a date is represented as a 64 bit number representing a timestamp
in milliseconds-since-the-epoch (01/01/1970 midnight UTC). These timestamps are
returned as the key name of the bucket. The <code>key_as_string</code> is the same
timestamp converted to a formatted
date string using the <code>format</code> parameter specification:</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
If you don&#8217;t specify <code>format</code>, the first date
<a href="mapping-params.html#mapping-date-format">format</a> specified in the field mapping is used.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "aggs": {
    "sales_over_time": {
      "date_histogram": {
        "field": "date",
        "calendar_interval": "1M",
        "format": "yyyy-MM-dd" <b class="conum">(1)</b>
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Supports expressive date <a href="search-aggregations-bucket.html#date-format-pattern">format pattern</a></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "sales_over_time": {
      "buckets": [
        {
          "key_as_string": "2015-01-01",
          "key": 1420070400000,
          "doc_count": 3
        },
        {
          "key_as_string": "2015-02-01",
          "key": 1422748800000,
          "doc_count": 2
        },
        {
          "key_as_string": "2015-03-01",
          "key": 1425168000000,
          "doc_count": 2
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="datehistogram-aggregation-time-zone">Time zone</h4>
<div class="paragraph">
<p>OpenSearch stores date-times in Coordinated Universal Time (UTC). By default, all bucketing and
rounding is also done in UTC. Use the <code>time_zone</code> parameter to indicate
that bucketing should use a different time zone.</p>
</div>
<div class="paragraph">
<p>For example, if the interval is a calendar day and the time zone is
<code>America/New_York</code> then <code>2020-01-03T01:00:01Z</code> is :
# Converted to <code>2020-01-02T18:00:01</code>
# Rounded down to <code>2020-01-02T00:00:00</code>
# Then converted back to UTC to produce <code>2020-01-02T05:00:00:00Z</code>
# Finally, when the bucket is turned into a string key it is printed in
  <code>America/New_York</code> so it&#8217;ll display as <code>"2020-01-02T00:00:00"</code>.</p>
</div>
<div class="paragraph">
<p>It looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bucket_key = localToUtc(Math.floor(utcToLocal(value) / interval) * interval))</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can specify time zones as an ISO 8601 UTC offset (e.g. <code>+01:00</code> or
<code>-08:00</code>) or as an IANA time zone ID,
such as <code>America/Los_Angeles</code>.</p>
</div>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001/_doc/1?refresh
{
  "date": "2015-10-01T00:30:00Z"
}

PUT my-index-000001/_doc/2?refresh
{
  "date": "2015-10-01T01:30:00Z"
}

GET my-index-000001/_search?size=0
{
  "aggs": {
    "by_day": {
      "date_histogram": {
        "field":     "date",
        "calendar_interval":  "day"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you don&#8217;t specify a time zone, UTC is used. This would result in both of these
documents being placed into the same day bucket, which starts at midnight UTC
on 1 October 2015:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "by_day": {
      "buckets": [
        {
          "key_as_string": "2015-10-01T00:00:00.000Z",
          "key":           1443657600000,
          "doc_count":     2
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you specify a <code>time_zone</code> of <code>-01:00</code>, midnight in that time zone is one hour
before midnight UTC:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET my-index-000001/_search?size=0
{
  "aggs": {
    "by_day": {
      "date_histogram": {
        "field":     "date",
        "calendar_interval":  "day",
        "time_zone": "-01:00"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now the first document falls into the bucket for 30 September 2015, while the
second document falls into the bucket for 1 October 2015:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "by_day": {
      "buckets": [
        {
          "key_as_string": "2015-09-30T00:00:00.000-01:00", <b class="conum">(1)</b>
          "key": 1443574800000,
          "doc_count": 1
        },
        {
          "key_as_string": "2015-10-01T00:00:00.000-01:00", <b class="conum">(1)</b>
          "key": 1443661200000,
          "doc_count": 1
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>key_as_string</code> value represents midnight on each day
in the specified time zone.</p>
</li>
</ol>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Many time zones shift their clocks for daylight savings time. Buckets
close to the moment when those changes happen can have slightly different sizes
than you would expect from the <code>calendar_interval</code> or <code>fixed_interval</code>.
For example, consider a DST start in the <code>CET</code> time zone: on 27 March 2016 at 2am,
clocks were turned forward 1 hour to 3am local time. If you use <code>day</code> as the
<code>calendar_interval</code>, the bucket covering that day will only hold data for 23
hours instead of the usual 24 hours for other buckets. The same is true for
shorter intervals, like a <code>fixed_interval</code> of <code>12h</code>, where you&#8217;ll have only a 11h
bucket on the morning of 27 March when the DST shift happens.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="search-aggregations-bucket-datehistogram-offset">Offset</h4>
<div class="paragraph">
<p>Use the <code>offset</code> parameter to change the start value of each bucket by the
specified positive (<code>+</code>) or negative offset (<code>-</code>) duration, such as <code>1h</code> for
an hour, or <code>1d</code> for a day. See <a href="api-conventions.html#time-units">Time units</a> for more possible time
duration options.</p>
</div>
<div class="paragraph">
<p>For example, when using an interval of <code>day</code>, each bucket runs from midnight
to midnight. Setting the <code>offset</code> parameter to <code>+6h</code> changes each bucket
to run from 6am to 6am:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001/_doc/1?refresh
{
  "date": "2015-10-01T05:30:00Z"
}

PUT my-index-000001/_doc/2?refresh
{
  "date": "2015-10-01T06:30:00Z"
}

GET my-index-000001/_search?size=0
{
  "aggs": {
    "by_day": {
      "date_histogram": {
        "field":     "date",
        "calendar_interval":  "day",
        "offset":    "+6h"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of a single bucket starting at midnight, the above request groups the
documents into buckets starting at 6am:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "by_day": {
      "buckets": [
        {
          "key_as_string": "2015-09-30T06:00:00.000Z",
          "key": 1443592800000,
          "doc_count": 1
        },
        {
          "key_as_string": "2015-10-01T06:00:00.000Z",
          "key": 1443679200000,
          "doc_count": 1
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The start <code>offset</code> of each bucket is calculated after <code>time_zone</code>
adjustments have been made.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="date-histogram-keyed-response">Keyed Response</h4>
<div class="paragraph">
<p>Setting the <code>keyed</code> flag to <code>true</code> associates a unique string key with each
bucket and returns the ranges as a hash rather than an array:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "aggs": {
    "sales_over_time": {
      "date_histogram": {
        "field": "date",
        "calendar_interval": "1M",
        "format": "yyyy-MM-dd",
        "keyed": true
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "sales_over_time": {
      "buckets": {
        "2015-01-01": {
          "key_as_string": "2015-01-01",
          "key": 1420070400000,
          "doc_count": 3
        },
        "2015-02-01": {
          "key_as_string": "2015-02-01",
          "key": 1422748800000,
          "doc_count": 2
        },
        "2015-03-01": {
          "key_as_string": "2015-03-01",
          "key": 1425168000000,
          "doc_count": 2
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="date-histogram-scripts">Scripts</h4>
<div class="paragraph">
<p>As with the normal <a href="search-aggregations-bucket.html#search-aggregations-bucket-histogram-aggregation">histogram</a>,
both document-level scripts and
value-level scripts are supported. You can control the order of the returned
buckets using the <code>order</code>
settings and filter the returned buckets based on a <code>min_doc_count</code> setting
(by default all buckets between the first
bucket that matches documents and the last one are returned). This histogram
also supports the <code>extended_bounds</code>
setting, which enables extending the bounds of the histogram beyond the data
itself, and <code>hard_bounds</code> that limits the histogram to specified bounds.
For more information, see
<a href="search-aggregations-bucket.html#search-aggregations-bucket-histogram-aggregation-extended-bounds"><code>Extended Bounds</code></a> and
<a href="search-aggregations-bucket.html#search-aggregations-bucket-histogram-aggregation-hard-bounds"><code>Hard Bounds</code></a>.</p>
</div>
<div class="sect4">
<h5 id="date-histogram-missing-value">Missing value</h5>
<div class="paragraph">
<p>The <code>missing</code> parameter defines how to treat documents that are missing a value.
By default, they are ignored, but it is also possible to treat them as if they
have a value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "aggs": {
    "sale_date": {
      "date_histogram": {
        "field": "date",
        "calendar_interval": "year",
        "missing": "2000/01/01" <b class="conum">(1)</b>
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Documents without a value in the <code>publish_date</code> field will fall into the
same bucket as documents that have the value <code>2000-01-01</code>.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="date-histogram-order">Order</h5>
<div class="paragraph">
<p>By default the returned buckets are sorted by their <code>key</code> ascending, but you can
control the order using
the <code>order</code> setting. This setting supports the same <code>order</code> functionality as
<a href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-order"><code>Terms Aggregation</code></a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="date-histogram-aggregate-scripts">Using a script to aggregate by day of the week</h5>
<div class="paragraph">
<p>When you need to aggregate the results by day of the week, use a script that
returns the day of the week:</p>
</div>
<div id="datehistogram-aggregation-script-example" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "aggs": {
    "dayOfWeek": {
      "terms": {
        "script": {
          "lang": "painless",
          "source": "doc['date'].value.dayOfWeekEnum.value"
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "dayOfWeek": {
      "doc_count_error_upper_bound": 0,
      "sum_other_doc_count": 0,
      "buckets": [
        {
          "key": "7",
          "doc_count": 4
        },
        {
          "key": "4",
          "doc_count": 3
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The response will contain all the buckets having the relative day of
the week as key : 1 for Monday, 2 for Tuesday&#8230;&#8203; 7 for Sunday.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-daterange-aggregation">Date range aggregation</h3>
<titleabbrev>Date range</titleabbrev>
<div class="paragraph">
<p>A range aggregation that is dedicated for date values. The main difference
between this aggregation and the normal
<a href="search-aggregations-bucket.html#search-aggregations-bucket-range-aggregation">range</a>
aggregation is that the <code>from</code> and <code>to</code> values can be expressed in
<a href="api-conventions.html#date-math">Date Math</a> expressions, and it is also possible to specify a date
format by which the <code>from</code> and <code>to</code> response fields will be returned.
Note that this aggregation includes the <code>from</code> value and excludes the <code>to</code> value
for each range.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "aggs": {
    "range": {
      "date_range": {
        "field": "date",
        "format": "MM-yyyy",
        "ranges": [
          { "to": "now-10M/M" },  <b class="conum">(1)</b>
          { "from": "now-10M/M" } <b class="conum">(2)</b>
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>&lt; now minus 10 months, rounded down to the start of the month.</p>
</li>
<li>
<p>&gt;= now minus 10 months, rounded down to the start of the month.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In the example above, we created two range buckets, the first will "bucket" all
documents dated prior to 10 months ago and the second will "bucket" all
documents dated since 10 months ago</p>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "range": {
      "buckets": [
        {
          "to": 1.4436576E12,
          "to_as_string": "10-2015",
          "doc_count": 7,
          "key": "*-10-2015"
        },
        {
          "from": 1.4436576E12,
          "from_as_string": "10-2015",
          "doc_count": 0,
          "key": "10-2015-*"
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
If a format or date value is incomplete, the date range aggregation
replaces any missing components with default values. See
<a href="term-level-queries.html#missing-date-components">Missing date components</a>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_missing_values_2">Missing Values</h4>
<div class="paragraph">
<p>The <code>missing</code> parameter defines how documents that are missing a value should
be treated. By default they will be ignored but it is also possible to treat
them as if they had a value. This is done by adding a set of fieldname :
value mappings to specify default values per field.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
   "aggs": {
       "range": {
           "date_range": {
               "field": "date",
               "missing": "1976/11/30",
               "ranges": [
                  {
                    "key": "Older",
                    "to": "2016/02/01"
                  }, <b class="conum">(1)</b>
                  {
                    "key": "Newer",
                    "from": "2016/02/01",
                    "to" : "now/d"
                  }
              ]
          }
      }
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Documents without a value in the <code>date</code> field will be added to the "Older"
bucket, as if they had a date value of "1976-11-30".</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="date-format-pattern">Date Format/Pattern</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
this information was copied from
<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html">DateTimeFormatter</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>All ASCII letters are reserved as format pattern letters, which are defined
as follows:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Symbol</th>
<th class="tableblock halign-left valign-top">Meaning</th>
<th class="tableblock halign-left valign-top">Presentation</th>
<th class="tableblock halign-left valign-top">Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">G</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">era</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">text</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AD; Anno Domini; A</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">u</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">year</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">year</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2004; 04</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">year-of-era</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">year</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2004; 04</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">D</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">day-of-year</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">189</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">M/L</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">month-of-year</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number/text</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7; 07; Jul; July; J</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">d</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">day-of-month</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Q/q</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">quarter-of-year</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number/text</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3; 03; Q3; 3rd quarter</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Y</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">week-based-year</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">year</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1996; 96</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">w</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">week-of-week-based-year</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">27</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">W</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">week-of-month</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">E</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">day-of-week</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">text</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tue; Tuesday; T</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">e/c</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">localized day-of-week</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number/text</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2; 02; Tue; Tuesday; T</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">F</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">week-of-month</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">am-pm-of-day</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">text</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PM</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">h</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">clock-hour-of-am-pm (1-12)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">K</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">hour-of-am-pm (0-11)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">k</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">clock-hour-of-am-pm (1-24)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">H</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">hour-of-day (0-23)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">m</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">minute-of-hour</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">30</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">second-of-minute</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">55</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">S</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fraction-of-second</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">fraction</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">978</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">milli-of-day</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1234</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">n</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">nano-of-second</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">987654321</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">nano-of-day</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">number</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1234000000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">V</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">time-zone ID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">zone-id</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">America/Los_Angeles; Z; -08:30</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">z</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">time-zone name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">zone-name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pacific Standard Time; PST</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">O</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">localized zone-offset</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">offset-O</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GMT+8; GMT+08:00; UTC-08:00;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">zone-offset 'Z' for zero</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">offset-X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Z; -08; -0830; -08:30; -083015; -08:30:15;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">zone-offset</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">offset-x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+0000; -08; -0830; -08:30; -083015; -08:30:15;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Z</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">zone-offset</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">offset-Z</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+0000; -0800; -08:00;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">p</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">pad next</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">pad modifier</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">'</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">escape for text</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">delimiter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">''</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">single quote</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">literal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">'</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">[</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">optional section start</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">optional section end</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">#</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved for future use</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">{</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">reserved for future use</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">}</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The count of pattern letters determines the format.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Text</dt>
<dd>
<p>The text style is determined based on the number of pattern letters
used. Less than 4 pattern letters will use the short form. Exactly 4
pattern letters will use the full form. Exactly 5 pattern letters will use
the narrow form. Pattern letters <code>L</code>, <code>c</code>, and <code>q</code> specify the stand-alone
form of the text styles.</p>
</dd>
<dt class="hdlist1">Number</dt>
<dd>
<p>If the count of letters is one, then the value is output using
the minimum number of digits and without padding. Otherwise, the count of
digits is used as the width of the output field, with the value
zero-padded as necessary. The following pattern letters have constraints
on the count of letters. Only one letter of <code>c</code> and <code>F</code> can be specified.
Up to two letters of <code>d</code>, <code>H</code>, <code>h</code>, <code>K</code>, <code>k</code>, <code>m</code>, and <code>s</code> can be
specified. Up to three letters of <code>D</code> can be specified.</p>
</dd>
<dt class="hdlist1">Number/Text</dt>
<dd>
<p>If the count of pattern letters is 3 or greater, use the
Text rules above. Otherwise use the Number rules above.</p>
</dd>
<dt class="hdlist1">Fraction</dt>
<dd>
<p>Outputs the nano-of-second field as a fraction-of-second. The
nano-of-second value has nine digits, thus the count of pattern letters is
from 1 to 9. If it is less than 9, then the nano-of-second value is
truncated, with only the most significant digits being output.</p>
</dd>
<dt class="hdlist1">Year</dt>
<dd>
<p>The count of letters determines the minimum field width below which
padding is used. If the count of letters is two, then a reduced two digit
form is used. For printing, this outputs the rightmost two digits. For
parsing, this will parse using the base value of 2000, resulting in a year
within the range 2000 to 2099 inclusive. If the count of letters is less
than four (but not two), then the sign is only output for negative years
as per <code>SignStyle.NORMAL</code>. Otherwise, the sign is output if the pad width is
exceeded, as per <code>SignStyle.EXCEEDS_PAD</code>.</p>
</dd>
<dt class="hdlist1">ZoneId</dt>
<dd>
<p>This outputs the time-zone ID, such as <code>Europe/Paris</code>. If the
count of letters is two, then the time-zone ID is output. Any other count
of letters throws <code>IllegalArgumentException</code>.</p>
</dd>
<dt class="hdlist1">Zone names</dt>
<dd>
<p>This outputs the display name of the time-zone ID. If the
count of letters is one, two or three, then the short name is output. If
the count of letters is four, then the full name is output. Five or more
letters throws <code>IllegalArgumentException</code>.</p>
</dd>
<dt class="hdlist1">Offset X and x</dt>
<dd>
<p>This formats the offset based on the number of pattern
letters. One letter outputs just the hour, such as <code>+01</code>, unless the
minute is non-zero in which case the minute is also output, such as
<code>+0130</code>. Two letters outputs the hour and minute, without a colon, such as
<code>+0130</code>. Three letters outputs the hour and minute, with a colon, such as
<code>+01:30</code>. Four letters outputs the hour and minute and optional second,
without a colon, such as <code>+013015</code>. Five letters outputs the hour and
minute and optional second, with a colon, such as <code>+01:30:15</code>. Six or
more letters throws <code>IllegalArgumentException</code>. Pattern letter <code>X</code> (upper
case) will output <code>Z</code> when the offset to be output would be zero,
whereas pattern letter <code>x</code> (lower case) will output <code>+00</code>, <code>+0000</code>, or
<code>+00:00</code>.</p>
</dd>
<dt class="hdlist1">Offset O</dt>
<dd>
<p>This formats the localized offset based on the number of
pattern letters. One letter outputs the short form of the localized
offset, which is localized offset text, such as <code>GMT</code>, with hour without
leading zero, optional 2-digit minute and second if non-zero, and colon,
for example <code>GMT+8</code>. Four letters outputs the full form, which is
localized offset text, such as <code>GMT, with 2-digit hour and minute
field, optional second field if non-zero, and colon, for example
`GMT+08:00</code>. Any other count of letters throws
<code>IllegalArgumentException</code>.</p>
</dd>
<dt class="hdlist1">Offset Z</dt>
<dd>
<p>This formats the offset based on the number of pattern letters.
One, two or three letters outputs the hour and minute, without a colon,
such as <code>+0130</code>. The output will be <code>+0000</code> when the offset is zero.
Four letters outputs the full form of localized offset, equivalent to
four letters of Offset-O. The output will be the corresponding localized
offset text if the offset is zero. Five letters outputs the hour,
minute, with optional second if non-zero, with colon. It outputs <code>Z</code> if
the offset is zero. Six or more letters throws IllegalArgumentException.</p>
</dd>
<dt class="hdlist1">Optional section</dt>
<dd>
<p>The optional section markers work exactly like calling
<code>DateTimeFormatterBuilder.optionalStart()</code> and
<code>DateTimeFormatterBuilder.optionalEnd()</code>.</p>
</dd>
<dt class="hdlist1">Pad modifier</dt>
<dd>
<p>Modifies the pattern that immediately follows to be padded
with spaces. The pad width is determined by the number of pattern letters.
This is the same as calling <code>DateTimeFormatterBuilder.padNext(int)</code>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>For example, <code>ppH</code> outputs the hour-of-day padded on the left with spaces to a width of 2.</p>
</div>
<div class="paragraph">
<p>Any unrecognized letter is an error. Any non-letter character, other than
<code>[</code>, <code>]</code>, <code>{</code>, <code>}</code>, <code>#</code> and the single quote will be output directly.
Despite this, it is recommended to use single quotes around all characters
that you want to output directly to ensure that future changes do not
break your application.</p>
</div>
</div>
<div class="sect3">
<h4 id="time-zones">Time zone in date range aggregations</h4>
<div class="paragraph">
<p>Dates can be converted from another time zone to UTC by specifying the
<code>time_zone</code> parameter.</p>
</div>
<div class="paragraph">
<p>Time zones may either be specified as an ISO 8601 UTC offset (e.g. +01:00 or
-08:00) or as one of the time zone ids from the TZ database.</p>
</div>
<div class="paragraph">
<p>The <code>time_zone</code> parameter is also applied to rounding in date math expressions.
As an example, to round to the beginning of the day in the CET time zone, you
can do the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
   "aggs": {
       "range": {
           "date_range": {
               "field": "date",
               "time_zone": "CET",
               "ranges": [
                  { "to": "2016/02/01" }, <b class="conum">(1)</b>
                  { "from": "2016/02/01", "to" : "now/d" }, <b class="conum">(2)</b>
                  { "from": "now/d" }
              ]
          }
      }
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This date will be converted to <code>2016-02-01T00:00:00.000+01:00</code>.</p>
</li>
<li>
<p><code>now/d</code> will be rounded to the beginning of the day in the CET time zone.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_keyed_response">Keyed Response</h4>
<div class="paragraph">
<p>Setting the <code>keyed</code> flag to <code>true</code> will associate a unique string key with each
bucket and return the ranges as a hash rather than an array:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "aggs": {
    "range": {
      "date_range": {
        "field": "date",
        "format": "MM-yyy",
        "ranges": [
          { "to": "now-10M/M" },
          { "from": "now-10M/M" }
        ],
        "keyed": true
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "range": {
      "buckets": {
        "*-10-2015": {
          "to": 1.4436576E12,
          "to_as_string": "10-2015",
          "doc_count": 7
        },
        "10-2015-*": {
          "from": 1.4436576E12,
          "from_as_string": "10-2015",
          "doc_count": 0
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to customize the key for each range:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "aggs": {
    "range": {
      "date_range": {
        "field": "date",
        "format": "MM-yyy",
        "ranges": [
          { "from": "01-2015", "to": "03-2015", "key": "quarter_01" },
          { "from": "03-2015", "to": "06-2015", "key": "quarter_02" }
        ],
        "keyed": true
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "range": {
      "buckets": {
        "quarter_01": {
          "from": 1.4200704E12,
          "from_as_string": "01-2015",
          "to": 1.425168E12,
          "to_as_string": "03-2015",
          "doc_count": 5
        },
        "quarter_02": {
          "from": 1.425168E12,
          "from_as_string": "03-2015",
          "to": 1.4331168E12,
          "to_as_string": "06-2015",
          "doc_count": 2
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-diversified-sampler-aggregation">Diversified sampler aggregation</h3>
<titleabbrev>Diversified sampler</titleabbrev>
<div class="paragraph">
<p>Like the <code>sampler</code> aggregation this is a filtering aggregation used to limit any sub aggregations' processing to a sample of the top-scoring documents.
The <code>diversified_sampler</code> aggregation adds the ability to limit the number of matches that share a common value such as an "author".</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Any good market researcher will tell you that when working with samples of data it is important
that the sample represents a healthy variety of opinions rather than being skewed by any single voice.
The same is true with aggregations and sampling with these diversify settings can offer a way to remove the bias in your content (an over-populated geography,
a large spike in a timeline or an over-active forum spammer).
</td>
</tr>
</table>
</div>
<div class="ulist">
<div class="title">Example use cases:</div>
<ul>
<li>
<p>Tightening the focus of analytics to high-relevance matches rather than the potentially very long tail of low-quality matches</p>
</li>
<li>
<p>Removing bias from analytics by ensuring fair representation of content from different sources</p>
</li>
<li>
<p>Reducing the running cost of aggregations that can produce useful results using only samples e.g. <code>significant_terms</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A choice of <code>field</code> or <code>script</code> setting is used to provide values used for de-duplication and the <code>max_docs_per_value</code> setting controls the maximum
number of documents collected on any one shard which share a common value. The default setting for <code>max_docs_per_value</code> is 1.</p>
</div>
<div class="paragraph">
<p>The aggregation will throw an error if the choice of <code>field</code> or <code>script</code> produces multiple values for a single document (de-duplication using multi-valued fields is not supported due to efficiency concerns).</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="paragraph">
<p>We might want to see which tags are strongly associated with <code>#opensearch</code> on StackOverflow
forum posts but ignoring the effects of some prolific users with a tendency to misspell #opensearch-dashboards as #dashboards.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /stackoverflow/_search?size=0
{
  "query": {
    "query_string": {
      "query": "tags:opensearch"
    }
  },
  "aggs": {
    "my_unbiased_sample": {
      "diversified_sampler": {
        "shard_size": 200,
        "field": "author"
      },
      "aggs": {
        "keywords": {
          "significant_terms": {
            "field": "tags",
            "exclude": [ "opensearch" ]
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "my_unbiased_sample": {
      "doc_count": 151,           <b class="conum">(1)</b>
      "keywords": {               <b class="conum">(2)</b>
        "doc_count": 151,
        "bg_count": 650,
        "buckets": [
          {
            "key": "opensearch-dashboards",
            "doc_count": 150,
            "score": 2.213,
            "bg_count": 200
          }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>151 documents were sampled in total.</p>
</li>
<li>
<p>The results of the significant_terms aggregation are not skewed by any single author&#8217;s quirks because we asked for a maximum of one post from any one author in our sample.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_scripted_example">Scripted example:</h4>
<div class="paragraph">
<p>In this scenario we might want to diversify on a combination of field values. We can use a <code>script</code> to produce a hash of the
multiple values in a tags field to ensure we don&#8217;t have a sample that consists of the same repeated combinations of tags.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /stackoverflow/_search?size=0
{
  "query": {
    "query_string": {
      "query": "tags:opensearch\\-dashboards"
    }
  },
  "aggs": {
    "my_unbiased_sample": {
      "diversified_sampler": {
        "shard_size": 200,
        "max_docs_per_value": 3,
        "script": {
          "lang": "painless",
          "source": "doc['tags'].hashCode()"
        }
      },
      "aggs": {
        "keywords": {
          "significant_terms": {
            "field": "tags",
            "exclude": [ "opensearch-dashboards" ]
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "my_unbiased_sample": {
      "doc_count": 6,
      "keywords": {
        "doc_count": 6,
        "bg_count": 650,
        "buckets": [
          {
            "key": "opensource",
            "doc_count": 3,
            "score": 2.213,
            "bg_count": 50
          },
          {
            "key": "opensearch",
            "doc_count": 3,
            "score": 1.34,
            "bg_count": 200
          }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_shard_size">shard_size</h4>
<div class="paragraph">
<p>The <code>shard_size</code> parameter limits how many top-scoring documents are collected in the sample processed on each shard.
The default value is 100.</p>
</div>
</div>
<div class="sect3">
<h4 id="_max_docs_per_value">max_docs_per_value</h4>
<div class="paragraph">
<p>The <code>max_docs_per_value</code> is an optional parameter and limits how many documents are permitted per choice of de-duplicating value.
The default setting is "1".</p>
</div>
</div>
<div class="sect3">
<h4 id="_execution_hint">execution_hint</h4>
<div class="paragraph">
<p>The optional <code>execution_hint</code> setting can influence the management of the values used for de-duplication.
Each option will hold up to <code>shard_size</code> values in memory while performing de-duplication but the type of value held can be controlled as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>hold field values directly (<code>map</code>)</p>
</li>
<li>
<p>hold ordinals of the field as determined by the Lucene index (<code>global_ordinals</code>)</p>
</li>
<li>
<p>hold hashes of the field values - with potential for hash collisions (<code>bytes_hash</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The default setting is to use <a href="mapping-params.html#eager-global-ordinals"><code>global_ordinals</code></a> if this information is available from the Lucene index and reverting to <code>map</code> if not.
The <code>bytes_hash</code> setting may prove faster in some cases but introduces the possibility of false positives in de-duplication logic due to the possibility of hash collisions.
Please note that OpenSearch will ignore the choice of execution hint if it is not applicable and that there is no backward compatibility guarantee on these hints.</p>
</div>
</div>
<div class="sect3">
<h4 id="_limitations_3">Limitations</h4>
<div class="sect4">
<h5 id="div-sampler-breadth-first-nested-agg">Cannot be nested under <code>breadth_first</code> aggregations</h5>
<div class="paragraph">
<p>Being a quality-based filter the diversified_sampler aggregation needs access to the relevance score produced for each document.
It therefore cannot be nested under a <code>terms</code> aggregation which has the <code>collect_mode</code> switched from the default <code>depth_first</code> mode to <code>breadth_first</code> as this discards scores.
In this situation an error will be thrown.</p>
</div>
</div>
<div class="sect4">
<h5 id="_limited_de_dup_logic">Limited de-dup logic.</h5>
<div class="paragraph">
<p>The de-duplication logic applies only at a shard level so will not apply across shards.</p>
</div>
</div>
<div class="sect4">
<h5 id="spec-syntax-geo-date-fields">No specialized syntax for geo/date fields</h5>
<div class="paragraph">
<p>Currently the syntax for defining the diversifying values is defined by a choice of <code>field</code> or
<code>script</code> - there is no added syntactical sugar for expressing geo or date units such as "7d" (7
days). This support may be added in a later release and users will currently have to create these
sorts of values using a script.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-filter-aggregation">Filter aggregation</h3>
<titleabbrev>Filter</titleabbrev>
<div class="paragraph">
<p>Defines a single bucket of all the documents in the current document set context that match a specified filter. Often this will be used to narrow down the current aggregation context to a specific set of documents.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "aggs": {
    "t_shirts": {
      "filter": { "term": { "type": "t-shirt" } },
      "aggs": {
        "avg_price": { "avg": { "field": "price" } }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, we calculate the average price of all the products that are of type t-shirt.</p>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "t_shirts": {
      "doc_count": 3,
      "avg_price": { "value": 128.33333333333334 }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-filters-aggregation">Filters aggregation</h3>
<titleabbrev>Filters</titleabbrev>
<div class="paragraph">
<p>Defines a multi bucket aggregation where each bucket is associated with a
filter. Each bucket will collect all documents that match its associated
filter.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT /logs/_bulk?refresh
{ "index" : { "_id" : 1 } }
{ "body" : "warning: page could not be rendered" }
{ "index" : { "_id" : 2 } }
{ "body" : "authentication error" }
{ "index" : { "_id" : 3 } }
{ "body" : "warning: connection timed out" }

GET logs/_search
{
  "size": 0,
  "aggs" : {
    "messages" : {
      "filters" : {
        "filters" : {
          "errors" :   { "match" : { "body" : "error"   }},
          "warnings" : { "match" : { "body" : "warning" }}
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, we analyze log messages. The aggregation will build two
collection (buckets) of log messages - one for all those containing an error,
and another for all those containing a warning.</p>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "took": 9,
  "timed_out": false,
  "_shards": ...,
  "hits": ...,
  "aggregations": {
    "messages": {
      "buckets": {
        "errors": {
          "doc_count": 1
        },
        "warnings": {
          "doc_count": 2
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_anonymous_filters">Anonymous filters</h4>
<div class="paragraph">
<p>The filters field can also be provided as an array of filters, as in the
following request:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET logs/_search
{
  "size": 0,
  "aggs" : {
    "messages" : {
      "filters" : {
        "filters" : [
          { "match" : { "body" : "error"   }},
          { "match" : { "body" : "warning" }}
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The filtered buckets are returned in the same order as provided in the
request.  The response for this example would be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "took": 4,
  "timed_out": false,
  "_shards": ...,
  "hits": ...,
  "aggregations": {
    "messages": {
      "buckets": [
        {
          "doc_count": 1
        },
        {
          "doc_count": 2
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="other-bucket"><code>Other</code> Bucket</h4>
<div class="paragraph">
<p>The <code>other_bucket</code> parameter can be set to add a bucket to the response which will contain all documents that do
not match any of the given filters. The value of this parameter can be as follows:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>false</code></dt>
<dd>
<p>Does not compute the <code>other</code> bucket</p>
</dd>
<dt class="hdlist1"><code>true</code></dt>
<dd>
<p>Returns the <code>other</code> bucket either in a bucket (named <code><em>other</em></code> by default) if named filters are being used,
or as the last bucket if anonymous filters are being used</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The <code>other_bucket_key</code> parameter can be used to set the key for the <code>other</code> bucket to a value other than the default <code><em>other</em></code>. Setting
this parameter will implicitly set the <code>other_bucket</code> parameter to <code>true</code>.</p>
</div>
<div class="paragraph">
<p>The following snippet shows a response where the <code>other</code> bucket is requested to be named <code>other_messages</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT logs/_doc/4?refresh
{
  "body": "info: user Bob logged out"
}

GET logs/_search
{
  "size": 0,
  "aggs" : {
    "messages" : {
      "filters" : {
        "other_bucket_key": "other_messages",
        "filters" : {
          "errors" :   { "match" : { "body" : "error"   }},
          "warnings" : { "match" : { "body" : "warning" }}
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The response would be something like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "took": 3,
  "timed_out": false,
  "_shards": ...,
  "hits": ...,
  "aggregations": {
    "messages": {
      "buckets": {
        "errors": {
          "doc_count": 1
        },
        "warnings": {
          "doc_count": 2
        },
        "other_messages": {
          "doc_count": 1
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-geodistance-aggregation">Geo-distance aggregation</h3>
<titleabbrev>Geo-distance</titleabbrev>
<div class="paragraph">
<p>A multi-bucket aggregation that works on <code>geo_point</code> fields and conceptually works very similar to the <a href="search-aggregations-bucket.html#search-aggregations-bucket-range-aggregation">range</a> aggregation. The user can define a point of origin and a set of distance range buckets. The aggregation evaluate the distance of each document value from the origin point and determines the buckets it belongs to based on the ranges (a document belongs to a bucket if the distance between the document and the origin falls within the distance range of the bucket).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT /museums
{
  "mappings": {
    "properties": {
      "location": {
        "type": "geo_point"
      }
    }
  }
}

POST /museums/_bulk?refresh
{"index":{"_id":1}}
{"location": "52.374081,4.912350", "name": "NEMO Science Museum"}
{"index":{"_id":2}}
{"location": "52.369219,4.901618", "name": "Museum Het Rembrandthuis"}
{"index":{"_id":3}}
{"location": "52.371667,4.914722", "name": "Nederlands Scheepvaartmuseum"}
{"index":{"_id":4}}
{"location": "51.222900,4.405200", "name": "Letterenhuis"}
{"index":{"_id":5}}
{"location": "48.861111,2.336389", "name": "Musée du Louvre"}
{"index":{"_id":6}}
{"location": "48.860000,2.327000", "name": "Musée d'Orsay"}

POST /museums/_search?size=0
{
  "aggs": {
    "rings_around_amsterdam": {
      "geo_distance": {
        "field": "location",
        "origin": "52.3760, 4.894",
        "ranges": [
          { "to": 100000 },
          { "from": 100000, "to": 300000 },
          { "from": 300000 }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "rings_around_amsterdam": {
      "buckets": [
        {
          "key": "*-100000.0",
          "from": 0.0,
          "to": 100000.0,
          "doc_count": 3
        },
        {
          "key": "100000.0-300000.0",
          "from": 100000.0,
          "to": 300000.0,
          "doc_count": 1
        },
        {
          "key": "300000.0-*",
          "from": 300000.0,
          "doc_count": 2
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The specified field must be of type <code>geo_point</code> (which can only be set explicitly in the mappings). And it can also hold an array of <code>geo_point</code> fields, in which case all will be taken into account during aggregation. The origin point can accept all formats supported by the <a href="mapping-types.html#geo-point"><code>geo_point</code> type</a>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Object format: <code>{ "lat" : 52.3760, "lon" : 4.894 }</code> - this is the safest format as it is the most explicit about the <code>lat</code> &amp; <code>lon</code> values</p>
</li>
<li>
<p>String format: <code>"52.3760, 4.894"</code> - where the first number is the <code>lat</code> and the second is the <code>lon</code></p>
</li>
<li>
<p>Array format: <code>[4.894, 52.3760]</code> - which is based on the <code>GeoJson</code> standard and where the first number is the <code>lon</code> and the second one is the <code>lat</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By default, the distance unit is <code>m</code> (meters) but it can also accept: <code>mi</code> (miles), <code>in</code> (inches), <code>yd</code> (yards), <code>km</code> (kilometers), <code>cm</code> (centimeters), <code>mm</code> (millimeters).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /museums/_search?size=0
{
  "aggs": {
    "rings": {
      "geo_distance": {
        "field": "location",
        "origin": "52.3760, 4.894",
        "unit": "km", <b class="conum">(1)</b>
        "ranges": [
          { "to": 100 },
          { "from": 100, "to": 300 },
          { "from": 300 }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The distances will be computed in kilometers</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>There are two distance calculation modes: <code>arc</code> (the default), and <code>plane</code>. The <code>arc</code> calculation is the most accurate. The <code>plane</code> is the fastest but least accurate. Consider using <code>plane</code> when your search context is "narrow", and spans smaller geographical areas (~5km). <code>plane</code> will return higher error margins for searches across very large areas (e.g. cross continent search). The distance calculation type can be set using the <code>distance_type</code> parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /museums/_search?size=0
{
  "aggs": {
    "rings": {
      "geo_distance": {
        "field": "location",
        "origin": "52.3760, 4.894",
        "unit": "km",
        "distance_type": "plane",
        "ranges": [
          { "to": 100 },
          { "from": 100, "to": 300 },
          { "from": 300 }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_keyed_response_2">Keyed Response</h4>
<div class="paragraph">
<p>Setting the <code>keyed</code> flag to <code>true</code> will associate a unique string key with each bucket and return the ranges as a hash rather than an array:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /museums/_search?size=0
{
  "aggs": {
    "rings_around_amsterdam": {
      "geo_distance": {
        "field": "location",
        "origin": "52.3760, 4.894",
        "ranges": [
          { "to": 100000 },
          { "from": 100000, "to": 300000 },
          { "from": 300000 }
        ],
        "keyed": true
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "rings_around_amsterdam": {
      "buckets": {
        "*-100000.0": {
          "from": 0.0,
          "to": 100000.0,
          "doc_count": 3
        },
        "100000.0-300000.0": {
          "from": 100000.0,
          "to": 300000.0,
          "doc_count": 1
        },
        "300000.0-*": {
          "from": 300000.0,
          "doc_count": 2
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to customize the key for each range:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /museums/_search?size=0
{
  "aggs": {
    "rings_around_amsterdam": {
      "geo_distance": {
        "field": "location",
        "origin": "52.3760, 4.894",
        "ranges": [
          { "to": 100000, "key": "first_ring" },
          { "from": 100000, "to": 300000, "key": "second_ring" },
          { "from": 300000, "key": "third_ring" }
        ],
        "keyed": true
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "rings_around_amsterdam": {
      "buckets": {
        "first_ring": {
          "from": 0.0,
          "to": 100000.0,
          "doc_count": 3
        },
        "second_ring": {
          "from": 100000.0,
          "to": 300000.0,
          "doc_count": 1
        },
        "third_ring": {
          "from": 300000.0,
          "doc_count": 2
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-geohashgrid-aggregation">Geohash grid aggregation</h3>
<titleabbrev>Geohash grid</titleabbrev>
<div class="paragraph">
<p>A multi-bucket aggregation that works on <code>geo_point</code> fields and groups points into buckets that represent cells in a grid.
The resulting grid can be sparse and only contains cells that have matching data. Each cell is labeled using a <a href="https://en.wikipedia.org/wiki/Geohash">geohash</a> which is of user-definable precision.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>High precision geohashes have a long string length and represent cells that cover only a small area.</p>
</li>
<li>
<p>Low precision geohashes have a short string length and represent cells that each cover a large area.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Geohashes used in this aggregation can have a choice of precision between 1 and 12.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
The highest-precision geohash of length 12 produces cells that cover less than a square metre of land and so high-precision requests can be very costly in terms of RAM and result sizes.
Please see the example below on how to first filter the aggregation to a smaller geographic area before requesting high-levels of detail.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The specified field must be of type <code>geo_point</code> (which can only be set explicitly in the mappings) and it can also hold an array of <code>geo_point</code> fields, in which case all points will be taken into account during aggregation.</p>
</div>
<div class="sect3">
<h4 id="_simple_low_precision_request">Simple low-precision request</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT /museums
{
  "mappings": {
    "properties": {
      "location": {
        "type": "geo_point"
      }
    }
  }
}

POST /museums/_bulk?refresh
{"index":{"_id":1}}
{"location": "52.374081,4.912350", "name": "NEMO Science Museum"}
{"index":{"_id":2}}
{"location": "52.369219,4.901618", "name": "Museum Het Rembrandthuis"}
{"index":{"_id":3}}
{"location": "52.371667,4.914722", "name": "Nederlands Scheepvaartmuseum"}
{"index":{"_id":4}}
{"location": "51.222900,4.405200", "name": "Letterenhuis"}
{"index":{"_id":5}}
{"location": "48.861111,2.336389", "name": "Musée du Louvre"}
{"index":{"_id":6}}
{"location": "48.860000,2.327000", "name": "Musée d'Orsay"}

POST /museums/_search?size=0
{
  "aggregations": {
    "large-grid": {
      "geohash_grid": {
        "field": "location",
        "precision": 3
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
  "large-grid": {
    "buckets": [
      {
        "key": "u17",
        "doc_count": 3
      },
      {
        "key": "u09",
        "doc_count": 2
      },
      {
        "key": "u15",
        "doc_count": 1
      }
    ]
  }
}
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_high_precision_requests">High-precision requests</h4>
<div class="paragraph">
<p>When requesting detailed buckets (typically for displaying a "zoomed in" map) a filter like <a href="geo-queries.html#query-dsl-geo-bounding-box-query">geo_bounding_box</a> should be applied to narrow the subject area otherwise potentially millions of buckets will be created and returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /museums/_search?size=0
{
  "aggregations": {
    "zoomed-in": {
      "filter": {
        "geo_bounding_box": {
          "location": {
            "top_left": "52.4, 4.9",
            "bottom_right": "52.3, 5.0"
          }
        }
      },
      "aggregations": {
        "zoom1": {
          "geohash_grid": {
            "field": "location",
            "precision": 8
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The geohashes returned by the <code>geohash_grid</code> aggregation can be also used for zooming in. To zoom into the
first geohash <code>u17</code> returned in the previous example, it should be specified as both <code>top_left</code> and <code>bottom_right</code> corner:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /museums/_search?size=0
{
  "aggregations": {
    "zoomed-in": {
      "filter": {
        "geo_bounding_box": {
          "location": {
            "top_left": "u17",
            "bottom_right": "u17"
          }
        }
      },
      "aggregations": {
        "zoom1": {
          "geohash_grid": {
            "field": "location",
            "precision": 8
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "zoomed-in": {
      "doc_count": 3,
      "zoom1": {
        "buckets": [
          {
            "key": "u173zy3j",
            "doc_count": 1
          },
          {
            "key": "u173zvfz",
            "doc_count": 1
          },
          {
            "key": "u173zt90",
            "doc_count": 1
          }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For "zooming in" on the system that don&#8217;t support geohashes, the bucket keys should be translated into bounding boxes using
one of available geohash libraries. For example, for javascript the <a href="https://github.com/sunng87/node-geohash">node-geohash</a> library
can be used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">var geohash = require('ngeohash');

// bbox will contain [ 52.03125, 4.21875, 53.4375, 5.625 ]
//                   [   minlat,  minlon,  maxlat, maxlon]
var bbox = geohash.decode_bbox('u17');</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_requests_with_additional_bounding_box_filtering">Requests with additional bounding box filtering</h4>
<div class="paragraph">
<p>The <code>geohash_grid</code> aggregation supports an optional <code>bounds</code> parameter
that restricts the points considered to those that fall within the
bounds provided. The <code>bounds</code> parameter accepts the bounding box in
all the same <a href="geo-queries.html#query-dsl-geo-bounding-box-query-accepted-formats">accepted formats</a> of the
bounds specified in the Geo Bounding Box Query. This bounding box can be used with or
without an additional <code>geo_bounding_box</code> query filtering the points prior to aggregating.
It is an independent bounding box that can intersect with, be equal to, or be disjoint
to any additional <code>geo_bounding_box</code> queries defined in the context of the aggregation.</p>
</div>
<div id="geohashgrid-aggregation-with-bounds" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /museums/_search?size=0
{
  "aggregations": {
    "tiles-in-bounds": {
      "geohash_grid": {
        "field": "location",
        "precision": 8,
        "bounds": {
          "top_left": "53.4375, 4.21875",
          "bottom_right": "52.03125, 5.625"
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "tiles-in-bounds": {
      "buckets": [
        {
          "key": "u173zy3j",
          "doc_count": 1
        },
        {
          "key": "u173zvfz",
          "doc_count": 1
        },
        {
          "key": "u173zt90",
          "doc_count": 1
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_cell_dimensions_at_the_equator">Cell dimensions at the equator</h4>
<div class="paragraph">
<p>The table below shows the metric dimensions for cells covered by various string lengths of geohash.
Cell dimensions vary with latitude and so the table is for the worst-case scenario at the equator.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<strong>GeoHash length</strong>
</td>
<td class="hdlist2">
<p><strong>Area width x height</strong></p>
</td>
</tr>
<tr>
<td class="hdlist1">
1
</td>
<td class="hdlist2">
<p>5,009.4km x 4,992.6km</p>
</td>
</tr>
<tr>
<td class="hdlist1">
2
</td>
<td class="hdlist2">
<p>1,252.3km x 624.1km</p>
</td>
</tr>
<tr>
<td class="hdlist1">
3
</td>
<td class="hdlist2">
<p>156.5km x 156km</p>
</td>
</tr>
<tr>
<td class="hdlist1">
4
</td>
<td class="hdlist2">
<p>39.1km x 19.5km</p>
</td>
</tr>
<tr>
<td class="hdlist1">
5
</td>
<td class="hdlist2">
<p>4.9km x 4.9km</p>
</td>
</tr>
<tr>
<td class="hdlist1">
6
</td>
<td class="hdlist2">
<p>1.2km x 609.4m</p>
</td>
</tr>
<tr>
<td class="hdlist1">
7
</td>
<td class="hdlist2">
<p>152.9m x 152.4m</p>
</td>
</tr>
<tr>
<td class="hdlist1">
8
</td>
<td class="hdlist2">
<p>38.2m x 19m</p>
</td>
</tr>
<tr>
<td class="hdlist1">
9
</td>
<td class="hdlist2">
<p>4.8m x 4.8m</p>
</td>
</tr>
<tr>
<td class="hdlist1">
10
</td>
<td class="hdlist2">
<p>1.2m x 59.5cm</p>
</td>
</tr>
<tr>
<td class="hdlist1">
11
</td>
<td class="hdlist2">
<p>14.9cm x 14.9cm</p>
</td>
</tr>
<tr>
<td class="hdlist1">
12
</td>
<td class="hdlist2">
<p>3.7cm x 1.9cm</p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_options_3">Options</h4>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
field
</td>
<td class="hdlist2">
<p>Mandatory. The name of the field indexed with GeoPoints.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
precision
</td>
<td class="hdlist2">
<p>Optional. The string length of the geohashes used to define
cells/buckets in the results. Defaults to 5.
The precision can either be defined in terms of the integer
precision levels mentioned above. Values outside of [1,12] will
be rejected.
Alternatively, the precision level can be approximated from a
distance measure like "1km", "10m". The precision level is
calculate such that cells will not exceed the specified
size (diagonal) of the required precision. When this would lead
to precision levels higher than the supported 12 levels,
(e.g. for distances &lt;5.6cm) the value is rejected.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
bounds
</td>
<td class="hdlist2">
<p>Optional. The bounding box to filter the points in the bucket.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
size
</td>
<td class="hdlist2">
<p>Optional. The maximum number of geohash buckets to return
(defaults to 10,000). When results are trimmed, buckets are
prioritised based on the volumes of documents they contain.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
shard_size
</td>
<td class="hdlist2">
<p>Optional. To allow for more accurate counting of the top cells
returned in the final result the aggregation defaults to
returning <code>max(10,(size x number-of-shards))</code> buckets from each
shard. If this heuristic is undesirable, the number considered
from each shard can be over-ridden using this parameter.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-geotilegrid-aggregation">Geotile grid aggregation</h3>
<titleabbrev>Geotile grid</titleabbrev>
<div class="paragraph">
<p>A multi-bucket aggregation that works on <code>geo_point</code> fields and groups points into
buckets that represent cells in a grid. The resulting grid can be sparse and only
contains cells that have matching data. Each cell corresponds to a
<a href="https://en.wikipedia.org/wiki/Tiled_web_map">map tile</a> as used by many online map
sites. Each cell is labeled using a "{zoom}/{x}/{y}" format, where zoom is equal
to the user-specified precision.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>High precision keys have a larger range for x and y, and represent tiles that
cover only a small area.</p>
</li>
<li>
<p>Low precision keys have a smaller range for x and y, and represent tiles that
each cover a large area.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See <a href="https://wiki.openstreetmap.org/wiki/Zoom_levels">Zoom level documentation</a>
on how precision (zoom) correlates to size on the ground. Precision for this
aggregation can be between 0 and 29, inclusive.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
The highest-precision geotile of length 29 produces cells that cover
less than a 10cm by 10cm of land and so high-precision requests can be very
costly in terms of RAM and result sizes. Please see the example below on how
to first filter the aggregation to a smaller geographic area before requesting
high-levels of detail.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The specified field must be of type <code>geo_point</code> (which can only be set
explicitly in the mappings) and it can also hold an array of <code>geo_point</code>
fields, in which case all points will be taken into account during aggregation.</p>
</div>
<div class="sect3">
<h4 id="_simple_low_precision_request_2">Simple low-precision request</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT /museums
{
  "mappings": {
    "properties": {
      "location": {
        "type": "geo_point"
      }
    }
  }
}

POST /museums/_bulk?refresh
{"index":{"_id":1}}
{"location": "52.374081,4.912350", "name": "NEMO Science Museum"}
{"index":{"_id":2}}
{"location": "52.369219,4.901618", "name": "Museum Het Rembrandthuis"}
{"index":{"_id":3}}
{"location": "52.371667,4.914722", "name": "Nederlands Scheepvaartmuseum"}
{"index":{"_id":4}}
{"location": "51.222900,4.405200", "name": "Letterenhuis"}
{"index":{"_id":5}}
{"location": "48.861111,2.336389", "name": "Musée du Louvre"}
{"index":{"_id":6}}
{"location": "48.860000,2.327000", "name": "Musée d'Orsay"}

POST /museums/_search?size=0
{
  "aggregations": {
    "large-grid": {
      "geotile_grid": {
        "field": "location",
        "precision": 8
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "large-grid": {
      "buckets": [
        {
          "key": "8/131/84",
          "doc_count": 3
        },
        {
          "key": "8/129/88",
          "doc_count": 2
        },
        {
          "key": "8/131/85",
          "doc_count": 1
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_high_precision_requests_2">High-precision requests</h4>
<div class="paragraph">
<p>When requesting detailed buckets (typically for displaying a "zoomed in" map)
a filter like <a href="geo-queries.html#query-dsl-geo-bounding-box-query">geo_bounding_box</a> should be
applied to narrow the subject area otherwise potentially millions of buckets
will be created and returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /museums/_search?size=0
{
  "aggregations": {
    "zoomed-in": {
      "filter": {
        "geo_bounding_box": {
          "location": {
            "top_left": "52.4, 4.9",
            "bottom_right": "52.3, 5.0"
          }
        }
      },
      "aggregations": {
        "zoom1": {
          "geotile_grid": {
            "field": "location",
            "precision": 22
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "zoomed-in": {
      "doc_count": 3,
      "zoom1": {
        "buckets": [
          {
            "key": "22/2154412/1378379",
            "doc_count": 1
          },
          {
            "key": "22/2154385/1378332",
            "doc_count": 1
          },
          {
            "key": "22/2154259/1378425",
            "doc_count": 1
          }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_requests_with_additional_bounding_box_filtering_2">Requests with additional bounding box filtering</h4>
<div class="paragraph">
<p>The <code>geotile_grid</code> aggregation supports an optional <code>bounds</code> parameter
that restricts the points considered to those that fall within the
bounds provided. The <code>bounds</code> parameter accepts the bounding box in
all the same <a href="geo-queries.html#query-dsl-geo-bounding-box-query-accepted-formats">accepted formats</a> of the
bounds specified in the Geo Bounding Box Query. This bounding box can be used with or
without an additional <code>geo_bounding_box</code> query filtering the points prior to aggregating.
It is an independent bounding box that can intersect with, be equal to, or be disjoint
to any additional <code>geo_bounding_box</code> queries defined in the context of the aggregation.</p>
</div>
<div id="geotilegrid-aggregation-with-bounds" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /museums/_search?size=0
{
  "aggregations": {
    "tiles-in-bounds": {
      "geotile_grid": {
        "field": "location",
        "precision": 22,
        "bounds": {
          "top_left": "52.4, 4.9",
          "bottom_right": "52.3, 5.0"
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "tiles-in-bounds": {
      "buckets": [
        {
          "key": "22/2154412/1378379",
          "doc_count": 1
        },
        {
          "key": "22/2154385/1378332",
          "doc_count": 1
        },
        {
          "key": "22/2154259/1378425",
          "doc_count": 1
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_options_4">Options</h4>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
field
</td>
<td class="hdlist2">
<p>Mandatory. The name of the field indexed with GeoPoints.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
precision
</td>
<td class="hdlist2">
<p>Optional. The integer zoom of the key used to define
cells/buckets in the results. Defaults to 7.
Values outside of [0,29] will be rejected.</p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>bounds:         Optional. The bounding box to filter the points in the bucket.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">size</dt>
<dd>
<p>Optional. The maximum number of geohash buckets to return
(defaults to 10,000). When results are trimmed, buckets are
prioritised based on the volumes of documents they contain.</p>
</dd>
<dt class="hdlist1">shard_size</dt>
<dd>
<p>Optional. To allow for more accurate counting of the top cells
returned in the final result the aggregation defaults to
returning <code>max(10,(size x number-of-shards))</code> buckets from each
shard. If this heuristic is undesirable, the number considered
from each shard can be over-ridden using this parameter.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-global-aggregation">Global aggregation</h3>
<titleabbrev>Global</titleabbrev>
<div class="paragraph">
<p>Defines a single bucket of all the documents within the search execution
context. This context is defined by the indices and the document types you&#8217;re
searching on, but is <strong>not</strong> influenced by the search query itself.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Global aggregators can only be placed as top level aggregators because
        it doesn&#8217;t make sense to embed a global aggregator within another
        bucket aggregator.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "query": {
    "match": { "type": "t-shirt" }
  },
  "aggs": {
    "all_products": {
      "global": {}, <b class="conum">(1)</b>
      "aggs": {     <b class="conum">(2)</b>
      "avg_price": { "avg": { "field": "price" } }
      }
    },
    "t_shirts": { "avg": { "field": "price" } }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>global</code> aggregation has an empty body</p>
</li>
<li>
<p>The sub-aggregations that are registered for this <code>global</code> aggregation</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The above aggregation demonstrates how one would compute aggregations
(<code>avg_price</code> in this example) on all the documents in the search context,
regardless of the query (in our example, it will compute the average price over
all products in our catalog, not just on the "shirts").</p>
</div>
<div class="paragraph">
<p>The response for the above aggregation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "all_products": {
      "doc_count": 7, <b class="conum">(1)</b>
      "avg_price": {
        "value": 140.71428571428572 <b class="conum">(2)</b>
      }
    },
    "t_shirts": {
      "value": 128.33333333333334 <b class="conum">(3)</b>
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The number of documents that were aggregated (in our case, all documents
within the search context)</p>
</li>
<li>
<p>The average price of all products in the index</p>
</li>
<li>
<p>The average price of all t-shirts</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-histogram-aggregation">Histogram aggregation</h3>
<titleabbrev>Histogram</titleabbrev>
<div class="paragraph">
<p>A multi-bucket values source based aggregation that can be applied on numeric values or numeric range values extracted
from the documents. It dynamically builds fixed size (a.k.a. interval) buckets over the values. For example, if the
documents have a field that holds a price (numeric), we can configure this aggregation to dynamically build buckets with
interval <code>5</code> (in case of price it may represent $5). When the aggregation executes, the price field of every document
will be evaluated and will be rounded down to its closest bucket - for example, if the price is <code>32</code> and the bucket size
is <code>5</code> then the rounding will yield <code>30</code> and thus the document will "fall" into the bucket that is associated with the
key <code>30</code>.
To make this more formal, here is the rounding function that is used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">bucket_key = Math.floor((value - offset) / interval) * interval + offset</code></pre>
</div>
</div>
<div class="paragraph">
<p>For range values, a document can fall into multiple buckets. The first bucket is computed from the lower
bound of the range in the same way as a bucket for a single value is computed.  The final bucket is computed in the same
way from the upper bound of the range, and the range is counted in all buckets in between and including those two.</p>
</div>
<div class="paragraph">
<p>The <code>interval</code> must be a positive decimal, while the <code>offset</code> must be a decimal in <code>[0, interval)</code>
(a decimal greater than or equal to <code>0</code> and less than <code>interval</code>)</p>
</div>
<div class="paragraph">
<p>The following snippet "buckets" the products based on their <code>price</code> by interval of <code>50</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "aggs": {
    "prices": {
      "histogram": {
        "field": "price",
        "interval": 50
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the following may be the response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "prices": {
      "buckets": [
        {
          "key": 0.0,
          "doc_count": 1
        },
        {
          "key": 50.0,
          "doc_count": 1
        },
        {
          "key": 100.0,
          "doc_count": 0
        },
        {
          "key": 150.0,
          "doc_count": 2
        },
        {
          "key": 200.0,
          "doc_count": 3
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_minimum_document_count">Minimum document count</h4>
<div class="paragraph">
<p>The response above show that no documents has a price that falls within the range of <code>[100, 150)</code>. By default the
response will fill gaps in the histogram with empty buckets. It is possible change that and request buckets with
a higher minimum count thanks to the <code>min_doc_count</code> setting:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "aggs": {
    "prices": {
      "histogram": {
        "field": "price",
        "interval": 50,
        "min_doc_count": 1
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "prices": {
      "buckets": [
        {
          "key": 0.0,
          "doc_count": 1
        },
        {
          "key": 50.0,
          "doc_count": 1
        },
        {
          "key": 150.0,
          "doc_count": 2
        },
        {
          "key": 200.0,
          "doc_count": 3
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div id="search-aggregations-bucket-histogram-aggregation-extended-bounds" class="paragraph">
<p>By default the <code>histogram</code> returns all the buckets within the range of the data itself, that is, the documents with
the smallest values (on which with histogram) will determine the min bucket (the bucket with the smallest key) and the
documents with the highest values will determine the max bucket (the bucket with the highest key). Often, when
requesting empty buckets, this causes a confusion, specifically, when the data is also filtered.</p>
</div>
<div class="paragraph">
<p>To understand why, let&#8217;s look at an example:</p>
</div>
<div class="paragraph">
<p>Lets say the you&#8217;re filtering your request to get all docs with values between <code>0</code> and <code>500</code>, in addition you&#8217;d like
to slice the data per price using a histogram with an interval of <code>50</code>. You also specify <code>"min_doc_count" : 0</code> as you&#8217;d
like to get all buckets even the empty ones. If it happens that all products (documents) have prices higher than <code>100</code>,
the first bucket you&#8217;ll get will be the one with <code>100</code> as its key. This is confusing, as many times, you&#8217;d also like
to get those buckets between <code>0 - 100</code>.</p>
</div>
<div class="paragraph">
<p>With <code>extended_bounds</code> setting, you now can "force" the histogram aggregation to start building buckets on a specific
<code>min</code> value and also keep on building buckets up to a <code>max</code> value (even if there are no documents anymore). Using
<code>extended_bounds</code> only makes sense when <code>min_doc_count</code> is 0 (the empty buckets will never be returned if <code>min_doc_count</code>
is greater than 0).</p>
</div>
<div class="paragraph">
<p>Note that (as the name suggest) <code>extended_bounds</code> is <strong>not</strong> filtering buckets. Meaning, if the <code>extended_bounds.min</code> is higher
than the values extracted from the documents, the documents will still dictate what the first bucket will be (and the
same goes for the <code>extended_bounds.max</code> and the last bucket). For filtering buckets, one should nest the histogram aggregation
under a range <code>filter</code> aggregation with the appropriate <code>from</code>/<code>to</code> settings.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "query": {
    "constant_score": { "filter": { "range": { "price": { "to": "500" } } } }
  },
  "aggs": {
    "prices": {
      "histogram": {
        "field": "price",
        "interval": 50,
        "extended_bounds": {
          "min": 0,
          "max": 500
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When aggregating ranges, buckets are based on the values of the returned documents.  This means the response may include
buckets outside of a query&#8217;s range. For example, if your query looks for values greater than 100, and you have a range
covering 50 to 150, and an interval of 50, that document will land in 3 buckets - 50, 100, and 150. In general, it&#8217;s
best to think of the query and aggregation steps as independent - the query selects a set of documents, and then the
aggregation buckets those documents without regard to how they were selected.
See <a href="search-aggregations-bucket.html#search-aggregations-bucket-range-field-note">note on bucketing range
fields</a> for more information and an example.</p>
</div>
<div id="search-aggregations-bucket-histogram-aggregation-hard-bounds" class="paragraph">
<p>The <code>hard_bounds</code> is a counterpart of <code>extended_bounds</code> and can limit the range of buckets in the histogram. It is
particularly useful in the case of open <a href="mapping-types.html#range">data ranges</a> that can result in a very large number of buckets.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div id="histogram-aggregation-hard-bounds-example" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "query": {
    "constant_score": { "filter": { "range": { "price": { "to": "500" } } } }
  },
  "aggs": {
    "prices": {
      "histogram": {
        "field": "price",
        "interval": 50,
        "hard_bounds": {
          "min": 100,
          "max": 200
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example even though the range specified in the query is up to 500, the histogram will only have 2 buckets starting at 100 and 150.
All other buckets will be omitted even if documents that should go to this buckets are present in the results.</p>
</div>
</div>
<div class="sect3">
<h4 id="_order_2">Order</h4>
<div class="paragraph">
<p>By default the returned buckets are sorted by their <code>key</code> ascending, though the order behaviour can be controlled using
the <code>order</code> setting. Supports the same <code>order</code> functionality as the <a href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-order"><code>Terms Aggregation</code></a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_offset">Offset</h4>
<div class="paragraph">
<p>By default the bucket keys start with 0 and then continue in even spaced steps
of <code>interval</code>, e.g. if the interval is <code>10</code>, the first three buckets (assuming
there is data inside them) will be <code>[0, 10)</code>, <code>[10, 20)</code>, <code>[20, 30)</code>. The bucket
boundaries can be shifted by using the <code>offset</code> option.</p>
</div>
<div class="paragraph">
<p>This can be best illustrated with an example. If there are 10 documents with values ranging from 5 to 14, using interval <code>10</code> will result in
two buckets with 5 documents each. If an additional offset <code>5</code> is used, there will be only one single bucket <code>[5, 15)</code> containing all the 10
documents.</p>
</div>
</div>
<div class="sect3">
<h4 id="_response_format">Response Format</h4>
<div class="paragraph">
<p>By default, the buckets are returned as an ordered array. It is also possible to request the response as a hash
instead keyed by the buckets keys:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "aggs": {
    "prices": {
      "histogram": {
        "field": "price",
        "interval": 50,
        "keyed": true
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "prices": {
      "buckets": {
        "0.0": {
          "key": 0.0,
          "doc_count": 1
        },
        "50.0": {
          "key": 50.0,
          "doc_count": 1
        },
        "100.0": {
          "key": 100.0,
          "doc_count": 0
        },
        "150.0": {
          "key": 150.0,
          "doc_count": 2
        },
        "200.0": {
          "key": 200.0,
          "doc_count": 3
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_missing_value_2">Missing value</h4>
<div class="paragraph">
<p>The <code>missing</code> parameter defines how documents that are missing a value should be treated.
By default they will be ignored but it is also possible to treat them as if they
had a value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "aggs": {
    "quantity": {
      "histogram": {
        "field": "quantity",
        "interval": 10,
        "missing": 0 <b class="conum">(1)</b>
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Documents without a value in the <code>quantity</code> field will fall into the same bucket as documents that have the value <code>0</code>.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-iprange-aggregation">IP range aggregation</h3>
<titleabbrev>IP range</titleabbrev>
<div class="paragraph">
<p>Just like the dedicated <a href="search-aggregations-bucket.html#search-aggregations-bucket-daterange-aggregation">date</a> range aggregation, there is also a dedicated range aggregation for IP typed fields:</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /ip_addresses/_search
{
  "size": 10,
  "aggs": {
    "ip_ranges": {
      "ip_range": {
        "field": "ip",
        "ranges": [
          { "to": "10.0.0.5" },
          { "from": "10.0.0.5" }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...

  "aggregations": {
    "ip_ranges": {
      "buckets": [
        {
          "key": "*-10.0.0.5",
          "to": "10.0.0.5",
          "doc_count": 10
        },
        {
          "key": "10.0.0.5-*",
          "from": "10.0.0.5",
          "doc_count": 260
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>IP ranges can also be defined as CIDR masks:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /ip_addresses/_search
{
  "size": 0,
  "aggs": {
    "ip_ranges": {
      "ip_range": {
        "field": "ip",
        "ranges": [
          { "mask": "10.0.0.0/25" },
          { "mask": "10.0.0.127/25" }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...

  "aggregations": {
    "ip_ranges": {
      "buckets": [
        {
          "key": "10.0.0.0/25",
          "from": "10.0.0.0",
          "to": "10.0.0.128",
          "doc_count": 128
        },
        {
          "key": "10.0.0.127/25",
          "from": "10.0.0.0",
          "to": "10.0.0.128",
          "doc_count": 128
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_keyed_response_3">Keyed Response</h4>
<div class="paragraph">
<p>Setting the <code>keyed</code> flag to <code>true</code> will associate a unique string key with each bucket and return the ranges as a hash rather than an array:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /ip_addresses/_search
{
  "size": 0,
  "aggs": {
    "ip_ranges": {
      "ip_range": {
        "field": "ip",
        "ranges": [
          { "to": "10.0.0.5" },
          { "from": "10.0.0.5" }
        ],
        "keyed": true
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...

  "aggregations": {
    "ip_ranges": {
      "buckets": {
        "*-10.0.0.5": {
          "to": "10.0.0.5",
          "doc_count": 10
        },
        "10.0.0.5-*": {
          "from": "10.0.0.5",
          "doc_count": 260
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to customize the key for each range:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /ip_addresses/_search
{
  "size": 0,
  "aggs": {
    "ip_ranges": {
      "ip_range": {
        "field": "ip",
        "ranges": [
          { "key": "infinity", "to": "10.0.0.5" },
          { "key": "and-beyond", "from": "10.0.0.5" }
        ],
        "keyed": true
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...

  "aggregations": {
    "ip_ranges": {
      "buckets": {
        "infinity": {
          "to": "10.0.0.5",
          "doc_count": 10
        },
        "and-beyond": {
          "from": "10.0.0.5",
          "doc_count": 260
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-missing-aggregation">Missing aggregation</h3>
<titleabbrev>Missing</titleabbrev>
<div class="paragraph">
<p>A field data based single bucket aggregation, that creates a bucket of all documents in the current document set context that are missing a field value (effectively, missing a field or having the configured NULL value set). This aggregator will often be used in conjunction with other field data bucket aggregators (such as ranges) to return information for all the documents that could not be placed in any of the other buckets due to missing field data values.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "aggs": {
    "products_without_a_price": {
      "missing": { "field": "price" }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, we get the total number of products that do not have a price.</p>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "products_without_a_price": {
      "doc_count": 00
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-nested-aggregation">Nested aggregation</h3>
<titleabbrev>Nested</titleabbrev>
<div class="paragraph">
<p>A special single bucket aggregation that enables aggregating nested documents.</p>
</div>
<div class="paragraph">
<p>For example, lets say we have an index of products, and each product holds the list of resellers - each having its own
price for the product. The mapping could look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT /products
{
  "mappings": {
    "properties": {
      "resellers": { <b class="conum">(1)</b>
        "type": "nested",
        "properties": {
          "reseller": { "type": "text" },
          "price": { "type": "double" }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>resellers</code> is an array that holds nested documents.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following request adds a product with two resellers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT /products/_doc/0
{
  "name": "LED TV", <b class="conum">(1)</b>
  "resellers": [
    {
      "reseller": "companyA",
      "price": 350
    },
    {
      "reseller": "companyB",
      "price": 500
    }
  ]
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We are using a dynamic mapping for the <code>name</code> attribute.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following request returns the minimum price a product can be purchased for:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /products/_search
{
  "query": {
    "match": { "name": "led tv" }
  },
  "aggs": {
    "resellers": {
      "nested": {
        "path": "resellers"
      },
      "aggs": {
        "min_price": { "min": { "field": "resellers.price" } }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see above, the nested aggregation requires the <code>path</code> of the nested documents within the top level documents.
Then one can define any type of aggregation over these nested documents.</p>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "resellers": {
      "doc_count": 2,
      "min_price": {
        "value": 350
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-parent-aggregation">Parent aggregation</h3>
<titleabbrev>Parent</titleabbrev>
<div class="paragraph">
<p>A special single bucket aggregation that selects parent documents that have the specified type, as defined in a <a href="mapping-types.html#parent-join"><code>join</code> field</a>.</p>
</div>
<div class="paragraph">
<p>This aggregation has a single option:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>type</code> - The child type that should be selected.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, let&#8217;s say we have an index of questions and answers. The answer type has the following <code>join</code> field in the mapping:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT parent_example
{
  "mappings": {
     "properties": {
       "join": {
         "type": "join",
         "relations": {
           "question": "answer"
         }
       }
     }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>question</code> document contain a tag field and the <code>answer</code> documents contain an owner field. With the <code>parent</code>
aggregation the owner buckets can be mapped to the tag buckets in a single request even though the two fields exist in
two different kinds of documents.</p>
</div>
<div class="paragraph">
<p>An example of a question document:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT parent_example/_doc/1
{
  "join": {
    "name": "question"
  },
  "body": "&lt;p&gt;I have Windows 2003 server and i bought a new Windows 2008 server...",
  "title": "Whats the best way to file transfer my site from server to a newer one?",
  "tags": [
    "windows-server-2003",
    "windows-server-2008",
    "file-transfer"
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Examples of <code>answer</code> documents:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT parent_example/_doc/2?routing=1
{
  "join": {
    "name": "answer",
    "parent": "1"
  },
  "owner": {
    "location": "Norfolk, United Kingdom",
    "display_name": "Sam",
    "id": 48
  },
  "body": "&lt;p&gt;Unfortunately you're pretty much limited to FTP...",
  "creation_date": "2009-05-04T13:45:37.030"
}

PUT parent_example/_doc/3?routing=1&amp;refresh
{
  "join": {
    "name": "answer",
    "parent": "1"
  },
  "owner": {
    "location": "Norfolk, United Kingdom",
    "display_name": "Troll",
    "id": 49
  },
  "body": "&lt;p&gt;Use Linux...",
  "creation_date": "2009-05-05T13:45:37.030"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following request can be built that connects the two together:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST parent_example/_search?size=0
{
  "aggs": {
    "top-names": {
      "terms": {
        "field": "owner.display_name.keyword",
        "size": 10
      },
      "aggs": {
        "to-questions": {
          "parent": {
            "type" : "answer" <b class="conum">(1)</b>
          },
          "aggs": {
            "top-tags": {
              "terms": {
                "field": "tags.keyword",
                "size": 10
              }
            }
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>type</code> points to type / mapping with the name <code>answer</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The above example returns the top answer owners and per owner the top question tags.</p>
</div>
<div class="paragraph">
<p>Possible response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "took": 9,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped": 0,
    "failed": 0
  },
  "hits": {
    "total" : {
      "value": 3,
      "relation": "eq"
    },
    "max_score": null,
    "hits": []
  },
  "aggregations": {
    "top-names": {
      "doc_count_error_upper_bound": 0,
      "sum_other_doc_count": 0,
      "buckets": [
        {
          "key": "Sam",
          "doc_count": 1, <b class="conum">(1)</b>
          "to-questions": {
            "doc_count": 1, <b class="conum">(2)</b>
            "top-tags": {
              "doc_count_error_upper_bound": 0,
              "sum_other_doc_count": 0,
              "buckets": [
                {
                  "key": "file-transfer",
                  "doc_count": 1
                },
                {
                  "key": "windows-server-2003",
                  "doc_count": 1
                },
                {
                  "key": "windows-server-2008",
                  "doc_count": 1
                }
              ]
            }
          }
        },
        {
          "key": "Troll",
          "doc_count": 1,
          "to-questions": {
            "doc_count": 1,
            "top-tags": {
              "doc_count_error_upper_bound": 0,
              "sum_other_doc_count": 0,
              "buckets": [
                {
                  "key": "file-transfer",
                  "doc_count": 1
                },
                {
                  "key": "windows-server-2003",
                  "doc_count": 1
                },
                {
                  "key": "windows-server-2008",
                  "doc_count": 1
                }
              ]
            }
          }
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The number of answer documents with the tag <code>Sam</code>, <code>Troll</code>, etc.</p>
</li>
<li>
<p>The number of question documents that are related to answer documents with the tag <code>Sam</code>, <code>Troll</code>, etc.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-range-aggregation">Range aggregation</h3>
<titleabbrev>Range</titleabbrev>
<div class="paragraph">
<p>A multi-bucket value source based aggregation that enables the user to define a set of ranges - each representing a bucket. During the aggregation process, the values extracted from each document will be checked against each bucket range and "bucket" the relevant/matching document.
Note that this aggregation includes the <code>from</code> value and excludes the <code>to</code> value for each range.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "price_ranges": {
      "range": {
        "field": "price",
        "ranges": [
          { "to": 100.0 },
          { "from": 100.0, "to": 200.0 },
          { "from": 200.0 }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "price_ranges": {
      "buckets": [
        {
          "key": "*-100.0",
          "to": 100.0,
          "doc_count": 2
        },
        {
          "key": "100.0-200.0",
          "from": 100.0,
          "to": 200.0,
          "doc_count": 2
        },
        {
          "key": "200.0-*",
          "from": 200.0,
          "doc_count": 3
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_keyed_response_4">Keyed Response</h4>
<div class="paragraph">
<p>Setting the <code>keyed</code> flag to <code>true</code> will associate a unique string key with each bucket and return the ranges as a hash rather than an array:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "price_ranges": {
      "range": {
        "field": "price",
        "keyed": true,
        "ranges": [
          { "to": 100 },
          { "from": 100, "to": 200 },
          { "from": 200 }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "price_ranges": {
      "buckets": {
        "*-100.0": {
          "to": 100.0,
          "doc_count": 2
        },
        "100.0-200.0": {
          "from": 100.0,
          "to": 200.0,
          "doc_count": 2
        },
        "200.0-*": {
          "from": 200.0,
          "doc_count": 3
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to customize the key for each range:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "price_ranges": {
      "range": {
        "field": "price",
        "keyed": true,
        "ranges": [
          { "key": "cheap", "to": 100 },
          { "key": "average", "from": 100, "to": 200 },
          { "key": "expensive", "from": 200 }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "price_ranges": {
      "buckets": {
        "cheap": {
          "to": 100.0,
          "doc_count": 2
        },
        "average": {
          "from": 100.0,
          "to": 200.0,
          "doc_count": 2
        },
        "expensive": {
          "from": 200.0,
          "doc_count": 3
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_script">Script</h4>
<div class="paragraph">
<p>Range aggregation accepts a <code>script</code> parameter. This parameter allows to defined an inline <code>script</code> that
will be executed during aggregation execution.</p>
</div>
<div class="paragraph">
<p>The following example shows how to use an <code>inline</code> script with the <code>painless</code> script language and no script parameters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "price_ranges": {
      "range": {
        "script": {
          "lang": "painless",
          "source": "doc['price'].value"
        },
        "ranges": [
          { "to": 100 },
          { "from": 100, "to": 200 },
          { "from": 200 }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to use stored scripts. Here is a simple stored script:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /_scripts/convert_currency
{
  "script": {
    "lang": "painless",
    "source": "doc[params.field].value * params.conversion_rate"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And this new stored script can be used in the range aggregation like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "price_ranges": {
      "range": {
        "script": {
          "id": "convert_currency",       <b class="conum">(1)</b>
          "params": {                     <b class="conum">(2)</b>
            "field": "price",
            "conversion_rate": 0.835526591
          }
        },
        "ranges": [
          { "from": 0, "to": 100 },
          { "from": 100 }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Id of the stored script</p>
</li>
<li>
<p>Parameters to use when executing the stored script</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_value_script">Value Script</h4>
<div class="paragraph">
<p>Lets say the product prices are in USD but we would like to get the price ranges in EURO. We can use value script to convert the prices prior the aggregation (assuming conversion rate of 0.8)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /sales/_search
{
  "aggs": {
    "price_ranges": {
      "range": {
        "field": "price",
        "script": {
          "source": "_value * params.conversion_rate",
          "params": {
            "conversion_rate": 0.8
          }
        },
        "ranges": [
          { "to": 35 },
          { "from": 35, "to": 70 },
          { "from": 70 }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_sub_aggregations_2">Sub Aggregations</h4>
<div class="paragraph">
<p>The following example, not only "bucket" the documents to the different buckets but also computes statistics over the prices in each price range</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "price_ranges": {
      "range": {
        "field": "price",
        "ranges": [
          { "to": 100 },
          { "from": 100, "to": 200 },
          { "from": 200 }
        ]
      },
      "aggs": {
        "price_stats": {
          "stats": { "field": "price" }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "price_ranges": {
      "buckets": [
        {
          "key": "*-100.0",
          "to": 100.0,
          "doc_count": 2,
          "price_stats": {
            "count": 2,
            "min": 10.0,
            "max": 50.0,
            "avg": 30.0,
            "sum": 60.0
          }
        },
        {
          "key": "100.0-200.0",
          "from": 100.0,
          "to": 200.0,
          "doc_count": 2,
          "price_stats": {
            "count": 2,
            "min": 150.0,
            "max": 175.0,
            "avg": 162.5,
            "sum": 325.0
          }
        },
        {
          "key": "200.0-*",
          "from": 200.0,
          "doc_count": 3,
          "price_stats": {
            "count": 3,
            "min": 200.0,
            "max": 200.0,
            "avg": 200.0,
            "sum": 600.0
          }
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-rare-terms-aggregation">Rare terms aggregation</h3>
<titleabbrev>Rare terms</titleabbrev>
<div class="paragraph">
<p>A multi-bucket value source based aggregation which finds "rare" terms&#8201;&#8212;&#8201;terms that are at the long-tail
of the distribution and are not frequent.  Conceptually, this is like a <code>terms</code> aggregation that is
sorted by <code>_count</code> ascending.  As noted in the <a href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-order">terms aggregation docs</a>,
actually ordering a <code>terms</code> agg by count ascending has unbounded error.  Instead, you should use the <code>rare_terms</code>
aggregation</p>
</div>
<div class="sect3">
<h4 id="_syntax">Syntax</h4>
<div class="paragraph">
<p>A <code>rare_terms</code> aggregation looks like this in isolation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "rare_terms": {
    "field": "the_field",
    "max_doc_count": 1
  }
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 34. <code>rare_terms</code> Parameters</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parameter Name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Description</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default Value</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>field</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The field we wish to find rare terms in</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>max_doc_count</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The maximum number of documents a term should appear in.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>precision</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The precision of the internal CuckooFilters.  Smaller precision leads to
better approximation, but higher memory usage. Cannot be smaller than <code>0.00001</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0.01</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>include</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Terms that should be included in the aggregation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>exclude</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Terms that should be excluded from the aggregation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>missing</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The value that should be used if a document does not have the field being aggregated</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "genres": {
      "rare_terms": {
        "field": "genre"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "genres": {
      "buckets": [
        {
          "key": "swing",
          "doc_count": 1
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the only bucket that we see is the "swing" bucket, because it is the only term that appears in
one document.  If we increase the <code>max_doc_count</code> to <code>2</code>, we&#8217;ll see some more buckets:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "genres": {
      "rare_terms": {
        "field": "genre",
        "max_doc_count": 2
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This now shows the "jazz" term which has a <code>doc_count</code> of 2":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "genres": {
      "buckets": [
        {
          "key": "swing",
          "doc_count": 1
        },
        {
          "key": "jazz",
          "doc_count": 2
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="search-aggregations-bucket-rare-terms-aggregation-max-doc-count">Maximum document count</h4>
<div class="paragraph">
<p>The <code>max_doc_count</code> parameter is used to control the upper bound of document counts that a term can have.  There
is not a size limitation on the <code>rare_terms</code> agg like <code>terms</code> agg has.  This means that terms
which match the <code>max_doc_count</code> criteria will be returned.  The aggregation functions in this manner to avoid
the order-by-ascending issues that afflict the <code>terms</code> aggregation.</p>
</div>
<div class="paragraph">
<p>This does, however, mean that  a large number of results can be returned if chosen incorrectly.
To limit the danger of this setting, the maximum <code>max_doc_count</code> is 100.</p>
</div>
</div>
<div class="sect3">
<h4 id="search-aggregations-bucket-rare-terms-aggregation-max-buckets">Max Bucket Limit</h4>
<div class="paragraph">
<p>The Rare Terms aggregation is more liable to trip the <code>search.max_buckets</code> soft limit than other aggregations due
to how it works.  The <code>max_bucket</code> soft-limit is evaluated on a per-shard basis while the aggregation is collecting
results.  It is possible for a term to be "rare" on a shard but become "not rare" once all the shard results are
merged together.  This means that individual shards tend to collect more buckets than are truly rare, because
they only have their own local view.  This list is ultimately pruned to the correct, smaller list of rare
terms on the coordinating node&#8230;&#8203; but a shard may have already tripped the <code>max_buckets</code> soft limit and aborted
the request.</p>
</div>
<div class="paragraph">
<p>When aggregating on fields that have potentially many "rare" terms, you may need to increase the <code>max_buckets</code> soft
limit.  Alternatively, you might need to find a way to filter the results to return fewer rare values (smaller time
span, filter by category, etc), or re-evaluate your definition of "rare" (e.g. if something
appears 100,000 times, is it truly "rare"?)</p>
</div>
</div>
<div class="sect3">
<h4 id="search-aggregations-bucket-rare-terms-aggregation-approximate-counts">Document counts are approximate</h4>
<div class="paragraph">
<p>The naive way to determine the "rare" terms in a dataset is to place all the values in a map, incrementing counts
as each document is visited, then return the bottom <code>n</code> rows.  This does not scale beyond even modestly sized data
sets.  A sharded approach where only the "top n" values are retained from each shard (ala the <code>terms</code> aggregation)
fails because the long-tail nature of the problem means it is impossible to find the "top n" bottom values without
simply collecting all the values from all shards.</p>
</div>
<div class="paragraph">
<p>Instead, the Rare Terms aggregation uses a different approximate algorithm:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Values are placed in a map the first time they are seen.</p>
</li>
<li>
<p>Each addition occurrence of the term increments a counter in the map</p>
</li>
<li>
<p>If the counter &gt; the <code>max_doc_count</code> threshold, the term is removed from the map and placed in a
<a href="https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf">CuckooFilter</a></p>
</li>
<li>
<p>The CuckooFilter is consulted on each term.  If the value is inside the filter, it is known to be above the
threshold already and skipped.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>After execution, the map of values is the map of "rare" terms under the <code>max_doc_count</code> threshold.  This map and CuckooFilter
are then merged with all other shards.  If there are terms that are greater than the threshold (or appear in
a different shard&#8217;s CuckooFilter) the term is removed from the merged list.  The final map of values is returned
to the user as the "rare" terms.</p>
</div>
<div class="paragraph">
<p>CuckooFilters have the possibility of returning false positives (they can say a value exists in their collection when
it actually does not).  Since the CuckooFilter is being used to see if a term is over threshold, this means a false positive
from the CuckooFilter will mistakenly say a value is common when it is not (and thus exclude it from it final list of buckets).
Practically, this means the aggregations exhibits false-negative behavior since the filter is being used "in reverse"
of how people generally think of approximate set membership sketches.</p>
</div>
<div class="paragraph">
<p>CuckooFilters are described in more detail in the paper:</p>
</div>
<div class="paragraph">
<p><a href="https://www.cs.cmu.edu/~dga/papers/cuckoo-conext2014.pdf">Fan, Bin, et al. "Cuckoo filter: Practically better than bloom."</a>
Proceedings of the 10th ACM International on Conference on emerging Networking Experiments and Technologies. ACM, 2014.</p>
</div>
</div>
<div class="sect3">
<h4 id="_precision">Precision</h4>
<div class="paragraph">
<p>Although the internal CuckooFilter is approximate in nature, the false-negative rate can be controlled with a
<code>precision</code> parameter.  This allows the user to trade more runtime memory for more accurate results.</p>
</div>
<div class="paragraph">
<p>The default precision is <code>0.001</code>, and the smallest (e.g. most accurate and largest memory overhead) is <code>0.00001</code>.
Below are some charts which demonstrate how the accuracy of the aggregation is affected by precision and number
of distinct terms.</p>
</div>
<div class="paragraph">
<p>The X-axis shows the number of distinct values the aggregation has seen, and the Y-axis shows the percent error.
Each line series represents one "rarity" condition (ranging from one rare item to 100,000 rare items).  For example,
the orange "10" line means ten of the values were "rare" (<code>doc_count == 1</code>), out of 1-20m distinct values (where the
rest of the values had <code>doc_count &gt; 1</code>)</p>
</div>
<div class="paragraph">
<p>This first chart shows precision <code>0.01</code>:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/rare_terms/accuracy_01.png" alt="accuracy 01"></span></p>
</div>
<div class="paragraph">
<p>And precision <code>0.001</code> (the default):</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/rare_terms/accuracy_001.png" alt="accuracy 001"></span></p>
</div>
<div class="paragraph">
<p>And finally <code>precision 0.0001</code>:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/rare_terms/accuracy_0001.png" alt="accuracy 0001"></span></p>
</div>
<div class="paragraph">
<p>The default precision of <code>0.001</code> maintains an accuracy of &lt; 2.5% for the tested conditions, and accuracy slowly
degrades in a controlled, linear fashion as the number of distinct values increases.</p>
</div>
<div class="paragraph">
<p>The default precision of <code>0.001</code> has a memory profile of <code>1.748⁻⁶ * n</code> bytes, where <code>n</code> is the number
of distinct values the aggregation has seen (it can also be roughly eyeballed, e.g. 20 million unique values is about
30mb of memory).  The memory usage is linear to the number of distinct values regardless of which precision is chosen,
the precision only affects the slope of the memory profile as seen in this chart:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="images/rare_terms/memory.png" alt="memory"></span></p>
</div>
<div class="paragraph">
<p>For comparison, an equivalent terms aggregation at 20 million buckets would be roughly
<code>20m * 69b == ~1.38gb</code> (with 69 bytes being a very optimistic estimate of an empty bucket cost, far lower than what
the circuit breaker accounts for).  So although the <code>rare_terms</code> agg is relatively heavy, it is still orders of
magnitude smaller than the equivalent terms aggregation</p>
</div>
</div>
<div class="sect3">
<h4 id="_filtering_values">Filtering Values</h4>
<div class="paragraph">
<p>It is possible to filter the values for which buckets will be created. This can be done using the <code>include</code> and
<code>exclude</code> parameters which are based on regular expression strings or arrays of exact values. Additionally,
<code>include</code> clauses can filter using <code>partition</code> expressions.</p>
</div>
<div class="sect4">
<h5 id="_filtering_values_with_regular_expressions">Filtering Values with regular expressions</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "genres": {
      "rare_terms": {
        "field": "genre",
        "include": "swi*",
        "exclude": "electro*"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, buckets will be created for all the tags that starts with <code>swi</code>, except those starting
with <code>electro</code> (so the tag <code>swing</code> will be aggregated but not <code>electro_swing</code>). The <code>include</code> regular expression will determine what
values are "allowed" to be aggregated, while the <code>exclude</code> determines the values that should not be aggregated. When
both are defined, the <code>exclude</code> has precedence, meaning, the <code>include</code> is evaluated first and only then the <code>exclude</code>.</p>
</div>
<div class="paragraph">
<p>The syntax is the same as <a href="regexp-syntax.html">regexp queries</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_filtering_values_with_exact_values">Filtering Values with exact values</h5>
<div class="paragraph">
<p>For matching based on exact values the <code>include</code> and <code>exclude</code> parameters can simply take an array of
strings that represent the terms as they are found in the index:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "genres": {
      "rare_terms": {
        "field": "genre",
        "include": [ "swing", "rock" ],
        "exclude": [ "jazz" ]
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_missing_value_3">Missing value</h4>
<div class="paragraph">
<p>The <code>missing</code> parameter defines how documents that are missing a value should be treated.
By default they will be ignored but it is also possible to treat them as if they
had a value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "genres": {
      "rare_terms": {
        "field": "genre",
        "missing": "N/A" <b class="conum">(1)</b>
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Documents without a value in the <code>tags</code> field will fall into the same bucket as documents that have the value <code>N/A</code>.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_nested_rareterms_and_scoring_sub_aggregations">Nested, RareTerms, and scoring sub-aggregations</h4>
<div class="paragraph">
<p>The RareTerms aggregation has to operate in <code>breadth_first</code> mode, since it needs to prune terms as doc count thresholds
are breached.  This requirement means the RareTerms aggregation is incompatible with certain combinations of aggregations
that require <code>depth_first</code>. In particular, scoring sub-aggregations that are inside a <code>nested</code> force the entire aggregation tree to run
in <code>depth_first</code> mode.  This will throw an exception since RareTerms is unable to process <code>depth_first</code>.</p>
</div>
<div class="paragraph">
<p>As a concrete example, if <code>rare_terms</code> aggregation is the child of a <code>nested</code> aggregation, and one of the child aggregations of <code>rare_terms</code>
needs document scores (like a <code>top_hits</code> aggregation), this will throw an exception.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-reverse-nested-aggregation">Reverse nested aggregation</h3>
<titleabbrev>Reverse nested</titleabbrev>
<div class="paragraph">
<p>A special single bucket aggregation that enables aggregating on parent docs from nested documents. Effectively this
aggregation can break out of the nested block structure and link to other nested structures or the root document,
which allows nesting other aggregations that aren&#8217;t part of the nested object in a nested aggregation.</p>
</div>
<div class="paragraph">
<p>The <code>reverse_nested</code> aggregation must be defined inside a <code>nested</code> aggregation.</p>
</div>
<div class="ulist">
<div class="title">Options:</div>
<ul>
<li>
<p><code>path</code> - Which defines to what nested object field should be joined back. The default is empty,
which means that it joins back to the root / main document level. The path cannot contain a reference to
a nested object field that falls outside the <code>nested</code> aggregation&#8217;s nested structure a <code>reverse_nested</code> is in.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, lets say we have an index for a ticket system with issues and comments. The comments are inlined into
the issue documents as nested documents. The mapping could look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT /issues
{
  "mappings": {
    "properties": {
      "tags": { "type": "keyword" },
      "comments": {                            <b class="conum">(1)</b>
        "type": "nested",
        "properties": {
          "username": { "type": "keyword" },
          "comment": { "type": "text" }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>comments</code> is an array that holds nested documents under the <code>issue</code> object.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following aggregations will return the top commenters' username that have commented and per top commenter the top
tags of the issues the user has commented on:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /issues/_search
{
  "query": {
    "match_all": {}
  },
  "aggs": {
    "comments": {
      "nested": {
        "path": "comments"
      },
      "aggs": {
        "top_usernames": {
          "terms": {
            "field": "comments.username"
          },
          "aggs": {
            "comment_to_issue": {
              "reverse_nested": {}, <b class="conum">(1)</b>
              "aggs": {
                "top_tags_per_comment": {
                  "terms": {
                    "field": "tags"
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see above, the <code>reverse_nested</code> aggregation is put in to a <code>nested</code> aggregation as this is the only place
in the dsl where the <code>reverse_nested</code> aggregation can be used. Its sole purpose is to join back to a parent doc higher
up in the nested structure.</p>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A <code>reverse_nested</code> aggregation that joins back to the root / main document level, because no <code>path</code> has been defined.
Via the <code>path</code> option the <code>reverse_nested</code> aggregation can join back to a different level, if multiple layered nested
object types have been defined in the mapping</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Possible response snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "aggregations": {
    "comments": {
      "doc_count": 1,
      "top_usernames": {
        "doc_count_error_upper_bound" : 0,
        "sum_other_doc_count" : 0,
        "buckets": [
          {
            "key": "username_1",
            "doc_count": 1,
            "comment_to_issue": {
              "doc_count": 1,
              "top_tags_per_comment": {
                "doc_count_error_upper_bound" : 0,
                "sum_other_doc_count" : 0,
                "buckets": [
                  {
                    "key": "tag_1",
                    "doc_count": 1
                  }
                  ...
                ]
              }
            }
          }
          ...
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-sampler-aggregation">Sampler aggregation</h3>
<titleabbrev>Sampler</titleabbrev>
<div class="paragraph">
<p>A filtering aggregation used to limit any sub aggregations' processing to a sample of the top-scoring documents.</p>
</div>
<div class="ulist">
<div class="title">Example use cases:</div>
<ul>
<li>
<p>Tightening the focus of analytics to high-relevance matches rather than the potentially very long tail of low-quality matches</p>
</li>
<li>
<p>Reducing the running cost of aggregations that can produce useful results using only samples e.g. <code>significant_terms</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="paragraph">
<p>A query on StackOverflow data for the popular term <code>javascript</code> OR the rarer term
<code>opensearch-dashboards</code> will match many documents - most of them missing the word opensearch-dashboards. To focus
the <code>significant_terms</code> aggregation on top-scoring documents that are more likely to match
the most interesting parts of our query we use a sample.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /stackoverflow/_search?size=0
{
  "query": {
    "query_string": {
      "query": "tags:opensearch\\-dashboards OR tags:javascript"
    }
  },
  "aggs": {
    "sample": {
      "sampler": {
        "shard_size": 200
      },
      "aggs": {
        "keywords": {
          "significant_terms": {
            "field": "tags",
            "exclude": [ "opensearch-dashboards", "javascript" ]
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "sample": {
      "doc_count": 200, <b class="conum">(1)</b>
      "keywords": {
        "doc_count": 200,
        "bg_count": 650,
        "buckets": [
          {
            "key": "opensearch",
            "doc_count": 150,
            "score": 1.078125,
            "bg_count": 200
          },
          {
            "key": "opensource",
            "doc_count": 50,
            "score": 0.5625,
            "bg_count": 50
          }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>200 documents were sampled in total. The cost of performing the nested significant_terms aggregation was
therefore limited rather than unbounded.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Without the <code>sampler</code> aggregation the request query considers the full "long tail" of low-quality matches and therefore identifies
less significant terms such as <code>jquery</code> and <code>angular</code> rather than focusing on the more insightful OpenSearch-Dashboards-related terms.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /stackoverflow/_search?size=0
{
  "query": {
    "query_string": {
      "query": "tags:opensearch\\-dashboards OR tags:javascript"
    }
  },
  "aggs": {
    "low_quality_keywords": {
      "significant_terms": {
        "field": "tags",
        "size": 3,
        "exclude": [ "opensearch-dashboards", "javascript" ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "low_quality_keywords": {
      "doc_count": 600,
      "bg_count": 650,
      "buckets": [
        {
          "key": "angular",
          "doc_count": 200,
          "score": 0.02777,
          "bg_count": 200
        },
        {
          "key": "jquery",
          "doc_count": 200,
          "score": 0.02777,
          "bg_count": 200
        },
        {
          "key": "opensource",
          "doc_count": 50,
          "score": 0.0069,
          "bg_count": 50
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_shard_size_2">shard_size</h4>
<div class="paragraph">
<p>The <code>shard_size</code> parameter limits how many top-scoring documents are collected in the sample processed on each shard.
The default value is 100.</p>
</div>
</div>
<div class="sect3">
<h4 id="_limitations_4">Limitations</h4>
<div class="sect4">
<h5 id="sampler-breadth-first-nested-agg">Cannot be nested under <code>breadth_first</code> aggregations</h5>
<div class="paragraph">
<p>Being a quality-based filter the sampler aggregation needs access to the relevance score produced for each document.
It therefore cannot be nested under a <code>terms</code> aggregation which has the <code>collect_mode</code> switched from the default <code>depth_first</code> mode to <code>breadth_first</code> as this discards scores.
In this situation an error will be thrown.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-significantterms-aggregation">Significant terms aggregation</h3>
<titleabbrev>Significant terms</titleabbrev>
<div class="paragraph">
<p>An aggregation that returns interesting or unusual occurrences of terms in a set.</p>
</div>
<div class="ulist">
<div class="title">Example use cases:</div>
<ul>
<li>
<p>Suggesting "H5N1" when users search for "bird flu" in text</p>
</li>
<li>
<p>Identifying the merchant that is the "common point of compromise" from the transaction history of credit card owners reporting loss</p>
</li>
<li>
<p>Suggesting keywords relating to stock symbol $ATI for an automated news classifier</p>
</li>
<li>
<p>Spotting the fraudulent doctor who is diagnosing more than their fair share of whiplash injuries</p>
</li>
<li>
<p>Spotting the tire manufacturer who has a disproportionate number of blow-outs</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In all these cases the terms being selected are not simply the most popular terms in a set.
They are the terms that have undergone a significant change in popularity measured between a <em>foreground</em> and <em>background</em> set.
If the term "H5N1" only exists in 5 documents in a 10 million document index and yet is found in 4 of the 100 documents that make up a user&#8217;s search results
that is significant and probably very relevant to their search. 5/10,000,000 vs 4/100 is a big swing in frequency.</p>
</div>
<div class="sect3">
<h4 id="_single_set_analysis">Single-set analysis</h4>
<div class="paragraph">
<p>In the simplest case, the <em>foreground</em> set of interest is the search results matched by a query and the <em>background</em>
set used for statistical comparisons is the index or indices from which the results were gathered.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "terms": { "force": [ "British Transport Police" ] }
  },
  "aggregations": {
    "significant_crime_types": {
      "significant_terms": { "field": "crime_type" }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "significant_crime_types": {
      "doc_count": 47347,
      "bg_count": 5064554,
      "buckets": [
        {
          "key": "Bicycle theft",
          "doc_count": 3640,
          "score": 0.371235374214817,
          "bg_count": 66799
        }
              ...
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When querying an index of all crimes from all police forces, what these results show is that the British Transport Police force
stand out as a force dealing with a disproportionately large number of bicycle thefts. Ordinarily, bicycle thefts represent only 1% of crimes (66799/5064554)
but for the British Transport Police, who handle crime on railways and stations, 7% of crimes (3640/47347) is
a bike theft. This is a significant seven-fold increase in frequency and so this anomaly was highlighted as the top crime type.</p>
</div>
<div class="paragraph">
<p>The problem with using a query to spot anomalies is it only gives us one subset to use for comparisons.
To discover all the other police forces' anomalies we would have to repeat the query for each of the different forces.</p>
</div>
<div class="paragraph">
<p>This can be a tedious way to look for unusual patterns in an index</p>
</div>
</div>
<div class="sect3">
<h4 id="_multi_set_analysis">Multi-set analysis</h4>
<div class="paragraph">
<p>A simpler way to perform analysis across multiple categories is to use a parent-level aggregation to segment the data ready for analysis.</p>
</div>
<div class="paragraph">
<p>Example using a parent aggregation for segmentation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggregations": {
    "forces": {
      "terms": { "field": "force" },
      "aggregations": {
        "significant_crime_types": {
          "significant_terms": { "field": "crime_type" }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
 ...
 "aggregations": {
    "forces": {
        "doc_count_error_upper_bound": 1375,
        "sum_other_doc_count": 7879845,
        "buckets": [
            {
                "key": "Metropolitan Police Service",
                "doc_count": 894038,
                "significant_crime_types": {
                    "doc_count": 894038,
                    "bg_count": 5064554,
                    "buckets": [
                        {
                            "key": "Robbery",
                            "doc_count": 27617,
                            "score": 0.0599,
                            "bg_count": 53182
                        }
                        ...
                    ]
                }
            },
            {
                "key": "British Transport Police",
                "doc_count": 47347,
                "significant_crime_types": {
                    "doc_count": 47347,
                    "bg_count": 5064554,
                    "buckets": [
                        {
                            "key": "Bicycle theft",
                            "doc_count": 3640,
                            "score": 0.371,
                            "bg_count": 66799
                        }
                        ...
                    ]
                }
            }
        ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we have anomaly detection for each of the police forces using a single request.</p>
</div>
<div class="paragraph">
<p>We can use other forms of top-level aggregations to segment our data, for example segmenting by geographic
area to identify unusual hot-spots of a particular crime type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "hotspots": {
      "geohash_grid": {
        "field": "location",
        "precision": 5
      },
      "aggs": {
        "significant_crime_types": {
          "significant_terms": { "field": "crime_type" }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example uses the <code>geohash_grid</code> aggregation to create result buckets that represent geographic areas, and inside each
bucket we can identify anomalous levels of a crime type in these tightly-focused areas e.g.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Airports exhibit unusual numbers of weapon confiscations</p>
</li>
<li>
<p>Universities show uplifts of bicycle thefts</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>At a higher geohash_grid zoom-level with larger coverage areas we would start to see where an entire police-force may be
tackling an unusual volume of a particular crime type.</p>
</div>
<div class="paragraph">
<p>Obviously a time-based top-level segmentation would help identify current trends for each point in time
where a simple <code>terms</code> aggregation would typically show the very popular "constants" that persist across all time slots.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">How are the scores calculated?</div>
<div class="paragraph">
<p>The numbers returned for scores are primarily intended for ranking different suggestions sensibly rather than something easily understood by end users. The scores are derived from the doc frequencies in <em>foreground</em> and <em>background</em> sets. In brief, a term is considered significant if there is a noticeable difference in the frequency in which a term appears in the subset and in the background. The way the terms are ranked can be configured, see "Parameters" section.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_use_on_free_text_fields">Use on free-text fields</h4>
<div class="paragraph">
<p>The significant_terms aggregation can be used effectively on tokenized free-text fields to suggest:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>keywords for refining end-user searches</p>
</li>
<li>
<p>keywords for use in percolator queries</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Picking a free-text field as the subject of a significant terms analysis can be expensive! It will attempt
to load every unique word into RAM. It is recommended to only use this on smaller indices.
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Use the <em>"like this but not this"</em> pattern</div>
<div class="paragraph">
<p>You can spot mis-categorized content by first searching a structured field e.g. <code>category:adultMovie</code> and use significant_terms on the
free-text "movie_description" field. Take the suggested words (I&#8217;ll leave them to your imagination) and then search for all movies NOT marked as category:adultMovie but containing these keywords.
You now have a ranked list of badly-categorized movies that you should reclassify or at least remove from the "familyFriendly" category.</p>
</div>
<div class="paragraph">
<p>The significance score from each term can also provide a useful <code>boost</code> setting to sort matches.
Using the <code>minimum_should_match</code> setting of the <code>terms</code> query with the keywords will help control the balance of precision/recall in the result set i.e
a high setting would have a small number of relevant results packed full of keywords and a setting of "1" would produce a more exhaustive results set with all documents containing <em>any</em> keyword.</p>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph">
<div class="title">Show significant_terms in context</div>
<p>Free-text significant_terms are much more easily understood when viewed in context. Take the results of <code>significant_terms</code> suggestions from a
free-text field and use them in a <code>terms</code> query on the same field with a <code>highlight</code> clause to present users with example snippets of documents. When the terms
are presented unstemmed, highlighted, with the right case, in the right order and with some context, their significance/meaning is more readily apparent.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_custom_background_sets">Custom background sets</h4>
<div class="paragraph">
<p>Ordinarily, the foreground set of documents is "diffed" against a background set of all the documents in your index.
However, sometimes it may prove useful to use a narrower background set as the basis for comparisons.
For example, a query on documents relating to "Madrid" in an index with content from all over the world might reveal that "Spanish"
was a significant term. This may be true but if you want some more focused terms you could use a <code>background_filter</code>
on the term 'spain' to establish a narrower set of documents as context. With this as a background "Spanish" would now
be seen as commonplace and therefore not as significant as words like "capital" that relate more strongly with Madrid.
Note that using a background filter will slow things down - each term&#8217;s background frequency must now be derived on-the-fly from filtering posting lists rather than reading the index&#8217;s pre-computed count for a term.</p>
</div>
</div>
<div class="sect3">
<h4 id="_limitations_5">Limitations</h4>
<div class="sect4">
<h5 id="_significant_terms_must_be_indexed_values">Significant terms must be indexed values</h5>
<div class="paragraph">
<p>Unlike the terms aggregation it is currently not possible to use script-generated terms for counting purposes.
Because of the way the significant_terms aggregation must consider both <em>foreground</em> and <em>background</em> frequencies
it would be prohibitively expensive to use a script on the entire index to obtain background frequencies for comparisons.
Also DocValues are not supported as sources of term data for similar reasons.</p>
</div>
</div>
<div class="sect4">
<h5 id="_no_analysis_of_floating_point_fields">No analysis of floating point fields</h5>
<div class="paragraph">
<p>Floating point fields are currently not supported as the subject of significant_terms analysis.
While integer or long fields can be used to represent concepts like bank account numbers or category numbers which
can be interesting to track, floating point fields are usually used to represent quantities of something.
As such, individual floating point terms are not useful for this form of frequency analysis.</p>
</div>
</div>
<div class="sect4">
<h5 id="_use_as_a_parent_aggregation">Use as a parent aggregation</h5>
<div class="paragraph">
<p>If there is the equivalent of a <code>match_all</code> query or no query criteria providing a subset of the index the significant_terms aggregation should not be used as the
top-most aggregation - in this scenario the <em>foreground</em> set is exactly the same as the <em>background</em> set and
so there is no difference in document frequencies to observe and from which to make sensible suggestions.</p>
</div>
<div class="paragraph">
<p>Another consideration is that  the significant_terms aggregation produces many candidate results at shard level
that are only later pruned on the reducing node once all statistics from all shards are merged. As a result,
it can be inefficient and costly in terms of RAM to embed large child aggregations under a significant_terms
aggregation that later discards many candidate terms. It is advisable in these cases to perform two searches - the first to provide a rationalized list of
significant_terms and then add this shortlist of terms to a second query to go back and fetch the required child aggregations.</p>
</div>
</div>
<div class="sect4">
<h5 id="_approximate_counts">Approximate counts</h5>
<div class="paragraph">
<p>The counts of how many documents contain a term provided in results are based on summing the samples returned from each shard and
as such may be:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>low if certain shards did not provide figures for a given term in their top sample</p>
</li>
<li>
<p>high when considering the background frequency as it may count occurrences found in deleted documents</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Like most design decisions, this is the basis of a trade-off in which we have chosen to provide fast performance at the cost of some (typically small) inaccuracies.
However, the <code>size</code> and <code>shard size</code> settings covered in the next section provide tools to help control the accuracy levels.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="significantterms-aggregation-parameters">Parameters</h4>
<div class="sect4">
<h5 id="_jlh_score">JLH score</h5>
<div class="paragraph">
<p>The JLH score can be used as a significance score by adding the parameter</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">	 "jlh": {
	 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The scores are derived from the doc frequencies in <em>foreground</em> and <em>background</em> sets. The <em>absolute</em> change in popularity (foregroundPercent - backgroundPercent) would favor common terms whereas the <em>relative</em> change in popularity (foregroundPercent/ backgroundPercent) would favor rare terms. Rare vs common is essentially a precision vs recall balance and so the absolute and relative changes are multiplied to provide a sweet spot between precision and recall.</p>
</div>
</div>
<div class="sect4">
<h5 id="_mutual_information">Mutual information</h5>
<div class="paragraph">
<p>Mutual information as described in "Information Retrieval", Manning et al., Chapter 13.5.1 can be used as significance score by adding the parameter</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">	 "mutual_information": {
	      "include_negatives": true
	 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mutual information does not differentiate between terms that are descriptive for the subset or for documents outside the subset. The significant terms therefore can contain terms that appear more or less frequent in the subset than outside the subset. To filter out the terms that appear less often in the subset than in documents outside the subset, <code>include_negatives</code> can be set to <code>false</code>.</p>
</div>
<div class="paragraph">
<p>Per default, the assumption is that the documents in the bucket are also contained in the background. If instead you defined a custom background filter that represents a different set of documents that you want to compare to, set</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">"background_is_superset": false</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_chi_square">Chi square</h5>
<div class="paragraph">
<p>Chi square as described in "Information Retrieval", Manning et al., Chapter 13.5.2 can be used as significance score by adding the parameter</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">	 "chi_square": {
	 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Chi square behaves like mutual information and can be configured with the same parameters <code>include_negatives</code> and <code>background_is_superset</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_google_normalized_distance">Google normalized distance</h5>
<div class="paragraph">
<p>Google normalized distance  as described in "The Google Similarity Distance", Cilibrasi and Vitanyi, 2007 (<a href="https://arxiv.org/pdf/cs/0412098v3.pdf" class="bare">https://arxiv.org/pdf/cs/0412098v3.pdf</a>) can be used as significance score by adding the parameter</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">	 "gnd": {
	 }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>gnd</code> also accepts the <code>background_is_superset</code> parameter.</p>
</div>
</div>
<div class="sect4">
<h5 id="_percentage">Percentage</h5>
<div class="paragraph">
<p>A simple calculation of the number of documents in the foreground sample with a term divided by the number of documents in the background with the term.
By default this produces a score greater than zero and less than one.</p>
</div>
<div class="paragraph">
<p>The benefit of this heuristic is that the scoring logic is simple to explain to anyone familiar with a "per capita" statistic. However, for fields with high cardinality there is a tendency for this heuristic to select the rarest terms such as typos that occur only once because they score 1/1 = 100%.</p>
</div>
<div class="paragraph">
<p>It would be hard for a seasoned boxer to win a championship if the prize was awarded purely on the basis of percentage of fights won - by these rules a newcomer with only one fight under their belt would be impossible to beat.
Multiple observations are typically required to reinforce a view so it is recommended in these cases to set both <code>min_doc_count</code> and <code>shard_min_doc_count</code> to a higher value such as 10 in order to filter out the low-frequency terms that otherwise take precedence.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">	 "percentage": {
	 }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_which_one_is_best">Which one is best?</h5>
<div class="paragraph">
<p>Roughly, <code>mutual_information</code> prefers high frequent terms even if they occur also frequently in the background. For example, in an analysis of natural language text this might lead to selection of stop words. <code>mutual_information</code> is unlikely to select very rare terms like misspellings. <code>gnd</code> prefers terms with a high co-occurrence and avoids selection of stopwords. It might be better suited for synonym detection. However, <code>gnd</code> has a tendency to select very rare terms that are, for example, a result of misspelling. <code>chi_square</code> and <code>jlh</code> are somewhat in-between.</p>
</div>
<div class="paragraph">
<p>It is hard to say which one of the different heuristics will be the best choice as it depends on what the significant terms are used for (see for example [Yang and Pedersen, "A Comparative Study on Feature Selection in Text Categorization", 1997](<a href="http://courses.ischool.berkeley.edu/i256/f06/papers/yang97comparative.pdf" class="bare">http://courses.ischool.berkeley.edu/i256/f06/papers/yang97comparative.pdf</a>) for a study on using significant terms for feature selection for text classification).</p>
</div>
<div class="paragraph">
<p>If none of the above measures suits your usecase than another option is to implement a custom significance measure:</p>
</div>
</div>
<div class="sect4">
<h5 id="_scripted">Scripted</h5>
<div class="paragraph">
<p>Customized scores can be implemented via a script:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">	    "script_heuristic": {
              "script": {
	        "lang": "painless",
	        "source": "params._subset_freq/(params._superset_freq - params._subset_freq + 1)"
	      }
            }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Scripts can be inline (as in above example), indexed or stored on disk. For details on the options, see <a href="modules-scripting.html">script documentation</a>.</p>
</div>
<div class="paragraph">
<p>Available parameters in the script are</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>_subset_freq</code>
</td>
<td class="hdlist2">
<p>Number of documents the term appears in the subset.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>_superset_freq</code>
</td>
<td class="hdlist2">
<p>Number of documents the term appears in the superset.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>_subset_size</code>
</td>
<td class="hdlist2">
<p>Number of documents in the subset.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>_superset_size</code>
</td>
<td class="hdlist2">
<p>Number of documents in the superset.</p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="sig-terms-shard-size">Size &amp; Shard Size</h5>
<div class="paragraph">
<p>The <code>size</code> parameter can be set to define how many term buckets should be returned out of the overall terms list. By
default, the node coordinating the search process will request each shard to provide its own top term buckets
and once all shards respond, it will reduce the results to the final list that will then be returned to the client.
If the number of unique terms is greater than <code>size</code>, the returned list can be slightly off and not accurate
(it could be that the term counts are slightly off and it could even be that a term that should have been in the top
size buckets was not returned).</p>
</div>
<div class="paragraph">
<p>To ensure better accuracy a multiple of the final <code>size</code> is used as the number of terms to request from each shard
(<code>2 * (size * 1.5 + 10)</code>). To take manual control of this setting the <code>shard_size</code> parameter
can be  used to control the volumes of candidate terms produced by each shard.</p>
</div>
<div class="paragraph">
<p>Low-frequency terms can turn out to be the most interesting ones once all results are combined so the
significant_terms aggregation can produce higher-quality results when the <code>shard_size</code> parameter is set to
values significantly higher than the <code>size</code> setting. This ensures that a bigger volume of promising candidate terms are given
a consolidated review by the reducing node before the final selection. Obviously large candidate term lists
will cause extra network traffic and RAM usage so this is  quality/cost trade off that needs to be balanced.  If <code>shard_size</code> is set to -1 (the default) then <code>shard_size</code> will be automatically estimated based on the number of shards and the <code>size</code> parameter.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>shard_size</code> cannot be smaller than <code>size</code> (as it doesn&#8217;t make much sense). When it is, OpenSearch will
        override it and reset it to be equal to <code>size</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_minimum_document_count_2">Minimum document count</h5>
<div class="paragraph">
<p>It is possible to only return terms that match more than a configured number of hits using the <code>min_doc_count</code> option:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "tags": {
      "significant_terms": {
        "field": "tag",
        "min_doc_count": 10
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above aggregation would only return tags which have been found in 10 hits or more. Default value is <code>3</code>.</p>
</div>
<div class="paragraph">
<p>Terms that score highly will be collected on a shard level and merged with the terms collected from other shards in a second step. However, the shard does not have the information about the global term frequencies available. The decision if a term is added to a candidate list depends only on the score computed on the shard using local shard frequencies, not the global frequencies of the word. The <code>min_doc_count</code> criterion is only applied after merging local terms statistics of all shards. In a way the decision to add the term as a candidate is made without being very <em>certain</em> about if the term will actually reach the required <code>min_doc_count</code>. This might cause many (globally) high frequent terms to be missing in the final result if low frequent but high scoring terms populated the candidate lists. To avoid this, the <code>shard_size</code> parameter can be increased to allow more candidate terms on the shards. However, this increases memory consumption and network traffic.</p>
</div>
<div class="paragraph">
<p><code>shard_min_doc_count</code> parameter</p>
</div>
<div class="paragraph">
<p>The parameter <code>shard_min_doc_count</code> regulates the <em>certainty</em> a shard has if the term should actually be added to the candidate list or not with respect to the <code>min_doc_count</code>. Terms will only be considered if their local shard frequency within the set is higher than the <code>shard_min_doc_count</code>. If your dictionary contains many low frequent words and you are not interested in these (for example misspellings), then you can set the <code>shard_min_doc_count</code> parameter to filter out candidate terms on a shard level that will with a reasonable certainty not reach the required <code>min_doc_count</code> even after merging the local frequencies. <code>shard_min_doc_count</code> is set to <code>1</code> per default and has no effect unless you explicitly set it.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Setting <code>min_doc_count</code> to <code>1</code> is generally not advised as it tends to return terms that
         are typos or other bizarre curiosities. Finding more than one instance of a term helps
         reinforce that, while still rare, the term was not the result of a one-off accident. The
         default value of 3 is used to provide a minimum weight-of-evidence.
         Setting <code>shard_min_doc_count</code> too high will cause significant candidate terms to be filtered out on a shard level. This value should be set much lower than <code>min_doc_count/#shards</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_custom_background_context">Custom background context</h5>
<div class="paragraph">
<p>The default source of statistical information for background term frequencies is the entire index and this
scope can be narrowed through the use of a <code>background_filter</code> to focus in on significant terms within a narrower
context:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "match": {
      "city": "madrid"
    }
  },
  "aggs": {
    "tags": {
      "significant_terms": {
        "field": "tag",
        "background_filter": {
          "term": { "text": "spain" }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above filter would help focus in on terms that were peculiar to the city of Madrid rather than revealing
terms like "Spanish" that are unusual in the full index&#8217;s worldwide context but commonplace in the subset of documents containing the
word "Spain".</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Use of background filters will slow the query as each term&#8217;s postings must be filtered to determine a frequency
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_filtering_values_2">Filtering Values</h5>
<div class="paragraph">
<p>It is possible (although rarely required) to filter the values for which buckets will be created. This can be done using the <code>include</code> and
<code>exclude</code> parameters which are based on a regular expression string or arrays of exact terms. This functionality mirrors the features
described in the <a href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation">terms aggregation</a> documentation.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_collect_mode">Collect mode</h4>
<div class="paragraph">
<p>To avoid memory issues, the <code>significant_terms</code> aggregation always computes child aggregations in <code>breadth_first</code> mode.
A description of the different collection modes can be found in the
<a href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-collect">terms aggregation</a> documentation.</p>
</div>
</div>
<div class="sect3">
<h4 id="_execution_hint_2">Execution hint</h4>
<div class="paragraph">
<p>There are different mechanisms by which terms aggregations can be executed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>by using field values directly in order to aggregate data per-bucket (<code>map</code>)</p>
</li>
<li>
<p>by using <a href="mapping-params.html#eager-global-ordinals">global ordinals</a> of the field and allocating one bucket per global ordinal (<code>global_ordinals</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>OpenSearch tries to have sensible defaults so this is something that generally doesn&#8217;t need to be configured.</p>
</div>
<div class="paragraph">
<p><code>global_ordinals</code> is the default option for <code>keyword</code> field, it uses global ordinals to allocates buckets dynamically
so memory usage is linear to the number of values of the documents that are part of the aggregation scope.</p>
</div>
<div class="paragraph">
<p><code>map</code> should only be considered when very few documents match a query. Otherwise the ordinals-based execution mode
is significantly faster. By default, <code>map</code> is only used when running an aggregation on scripts, since they don&#8217;t have
ordinals.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "tags": {
      "significant_terms": {
        "field": "tags",
        "execution_hint": "map" <b class="conum">(1)</b>
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>the possible values are <code>map</code>, <code>global_ordinals</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Please note that OpenSearch will ignore this execution hint if it is not applicable.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-significanttext-aggregation">Significant text aggregation</h3>
<titleabbrev>Significant text</titleabbrev>
<div class="paragraph">
<p>An aggregation that returns interesting or unusual occurrences of free-text terms in a set.
It is like the <a href="search-aggregations-bucket.html#search-aggregations-bucket-significantterms-aggregation">significant terms</a> aggregation but differs in that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is specifically designed for use on type <code>text</code> fields</p>
</li>
<li>
<p>It does not require field data or doc-values</p>
</li>
<li>
<p>It re-analyzes text content on-the-fly meaning it can also filter duplicate sections of
noisy text that otherwise tend to skew statistics.</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Re-analyzing <em>large</em> result sets will require a lot of time and memory. It is recommended that the significant_text
         aggregation is used as a child of either the <a href="search-aggregations-bucket.html#search-aggregations-bucket-sampler-aggregation">sampler</a> or
         <a href="search-aggregations-bucket.html#search-aggregations-bucket-diversified-sampler-aggregation">diversified sampler</a> aggregation to limit the analysis
         to a <em>small</em> selection of top-matching documents e.g. 200. This will typically improve speed, memory use and quality of
         results.
</td>
</tr>
</table>
</div>
<div class="ulist">
<div class="title">Example use cases:</div>
<ul>
<li>
<p>Suggesting "H5N1" when users search for "bird flu" to help expand queries</p>
</li>
<li>
<p>Suggesting keywords relating to stock symbol $ATI for use in an automated news classifier</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In these cases the words being selected are not simply the most popular terms in results. The most popular words tend to be
very boring (<em>and, of, the, we, I, they</em> &#8230;&#8203;).
The significant words are the ones that have undergone a significant change in popularity measured between a <em>foreground</em> and <em>background</em> set.
If the term "H5N1" only exists in 5 documents in a 10 million document index and yet is found in 4 of the 100 documents that make up a user&#8217;s search results
that is significant and probably very relevant to their search. 5/10,000,000 vs 4/100 is a big swing in frequency.</p>
</div>
<div class="sect3">
<h4 id="_basic_use">Basic use</h4>
<div class="paragraph">
<p>In the typical use case, the <em>foreground</em> set of interest is a selection of the top-matching search results for a query
and the _background_set used for statistical comparisons is the index or indices from which the results were gathered.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET news/_search
{
  "query": {
    "match": { "content": "Bird flu" }
  },
  "aggregations": {
    "my_sample": {
      "sampler": {
        "shard_size": 100
      },
      "aggregations": {
        "keywords": {
          "significant_text": { "field": "content" }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "took": 9,
  "timed_out": false,
  "_shards": ...,
  "hits": ...,
    "aggregations" : {
        "my_sample": {
            "doc_count": 100,
            "keywords" : {
                "doc_count": 100,
                "buckets" : [
                    {
                        "key": "h5n1",
                        "doc_count": 4,
                        "score": 4.71235374214817,
                        "bg_count": 5
                    }
                    ...
                ]
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The results show that "h5n1" is one of several terms strongly associated with bird flu.
It only occurs 5 times in our index as a whole (see the <code>bg_count</code>) and yet 4 of these
were lucky enough to appear in our 100 document sample of "bird flu" results. That suggests
a significant word and one which the user can potentially add to their search.</p>
</div>
</div>
<div class="sect3">
<h4 id="filter-duplicate-text-noisy-data">Dealing with noisy data using <code>filter_duplicate_text</code></h4>
<div class="paragraph">
<p>Free-text fields often contain a mix of original content and mechanical copies of text (cut-and-paste biographies, email reply chains,
retweets, boilerplate headers/footers, page navigation menus, sidebar news links, copyright notices, standard disclaimers, addresses).</p>
</div>
<div class="paragraph">
<p>In real-world data these duplicate sections of text tend to feature heavily in <code>significant_text</code> results if they aren&#8217;t filtered out.
Filtering near-duplicate text is a difficult task at index-time but we can cleanse the data on-the-fly at query time using the
<code>filter_duplicate_text</code> setting.</p>
</div>
<div class="paragraph">
<p>First let&#8217;s look at an unfiltered real-world example using the <a href="https://research.signalmedia.co/newsir16/signal-dataset.html">Signal media dataset</a> of
a million news articles covering a wide variety of news. Here are the raw significant text results for a search for the articles
mentioning "&lt;keyword&gt;":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  ...
  "aggregations": {
    "sample": {
      "doc_count": 35,
      "keywords": {
        "doc_count": 35,
        "buckets": [
          {
            "key": "&lt;keyword&gt;",
            "doc_count": 35,
            "score": 28570.428571428572,
            "bg_count": 35
          },
          ...
          {
            "key": "currensee",
            "doc_count": 8,
            "score": 6530.383673469388,
            "bg_count": 8
          },
          ...
          {
            "key": "pozmantier",
            "doc_count": 4,
            "score": 3265.191836734694,
            "bg_count": 4
          },
          ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The uncleansed documents have thrown up some odd-looking terms that are, on the face of it, statistically
correlated with appearances of our search term "&lt;keyword&gt;" e.g. "pozmantier".
We can drill down into examples of these documents to see why pozmantier is connected using this query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET news/_search
{
  "query": {
    "simple_query_string": {
      "query": "+\\&lt;keyword\\&gt;  +pozmantier"
    }
  },
  "_source": [
    "title",
    "source"
  ],
  "highlight": {
    "fields": {
      "content": {}
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The results show a series of very similar news articles about a judging panel for a number of tech projects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  ...
  "hits": {
    "hits": [
      {
        ...
        "_source": {
          "source": "Presentation Master",
          "title": "T.E.N. Announces Nominees for the 2015 ISE® North America Awards"
        },
        "highlight": {
          "content": [
            "City of San Diego Mike &lt;em&gt;Pozmantier&lt;/em&gt;, Program Manager, Cyber Security Division, Department of",
            " Janus, Janus &lt;em&gt;&lt;keyword&gt;&lt;/em&gt; Security Visualization Engine "
          ]
        }
      },
      {
        ...
        "_source": {
          "source": "RCL Advisors",
          "title": "T.E.N. Announces Nominees for the 2015 ISE(R) North America Awards"
        },
        "highlight": {
          "content": [
            "Mike &lt;em&gt;Pozmantier&lt;/em&gt;, Program Manager, Cyber Security Division, Department of Homeland Security S&amp;T",
            "Janus, Janus &lt;em&gt;&lt;keyword&gt;&lt;/em&gt; Security Visualization Engine"
          ]
        }
      },
      ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mike Pozmantier was one of many judges on a panel and &lt;keyword&gt; was used in one of many projects being judged.</p>
</div>
<div class="paragraph">
<p>As is typical, this lengthy press release was cut-and-paste by a variety of news sites and consequently any rare names, numbers or
typos they contain become statistically correlated with our matching query.</p>
</div>
<div class="paragraph">
<p>Fortunately similar documents tend to rank similarly so as part of examining the stream of top-matching documents the significant_text
aggregation can apply a filter to remove sequences of any 6 or more tokens that have already been seen. Let&#8217;s try this same query now but
with the <code>filter_duplicate_text</code> setting turned on:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET news/_search
{
  "query": {
    "match": {
      "content": "&lt;keyword&gt;"
    }
  },
  "aggs": {
    "sample": {
      "sampler": {
        "shard_size": 100
      },
      "aggs": {
        "keywords": {
          "significant_text": {
            "field": "content",
            "filter_duplicate_text": true
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The results from analysing our deduplicated text are obviously of higher quality to anyone familiar with opensearch:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  ...
  "aggregations": {
    "sample": {
      "doc_count": 35,
      "keywords": {
        "doc_count": 35,
        "buckets": [
          {
            "key": "&lt;keyword&gt;",
            "doc_count": 22,
            "score": 11288.001166180758,
            "bg_count": 35
          },
          {
            "key": "&lt;keyword_2&gt;",
            "doc_count": 3,
            "score": 1836.648979591837,
            "bg_count": 4
          },
          {
            "key": "&lt;keyword_3&gt;",
            "doc_count": 3,
            "score": 1469.3020408163263,
            "bg_count": 5
          }
        ]
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mr Pozmantier and other one-off associations with &lt;keyword&gt; no longer appear in the aggregation
results as a consequence of copy-and-paste operations or other forms of mechanical repetition.</p>
</div>
<div class="paragraph">
<p>If your duplicate or near-duplicate content is identifiable via a single-value indexed field  (perhaps
a hash of the article&#8217;s <code>title</code> text or an <code>original_press_release_url</code> field) then it would be more
efficient to use a parent <a href="search-aggregations-bucket.html#search-aggregations-bucket-diversified-sampler-aggregation">diversified sampler</a> aggregation
to eliminate these documents from the sample set based on that single key. The less duplicate content you can feed into
the significant_text aggregation up front the better in terms of performance.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">How are the significance scores calculated?</div>
<div class="paragraph">
<p>The numbers returned for scores are primarily intended for ranking different suggestions sensibly rather than something easily
understood by end users. The scores are derived from the doc frequencies in <em>foreground</em> and <em>background</em> sets. In brief, a
term is considered significant if there is a noticeable difference in the frequency in which a term appears in the subset and
in the background. The way the terms are ranked can be configured, see "Parameters" section.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Use the <em>"like this but not this"</em> pattern</div>
<div class="paragraph">
<p>You can spot mis-categorized content by first searching a structured field e.g. <code>category:adultMovie</code> and use significant_text on the
text "movie_description" field. Take the suggested words (I&#8217;ll leave them to your imagination) and then search for all movies NOT marked as category:adultMovie but containing these keywords.
You now have a ranked list of badly-categorized movies that you should reclassify or at least remove from the "familyFriendly" category.</p>
</div>
<div class="paragraph">
<p>The significance score from each term can also provide a useful <code>boost</code> setting to sort matches.
Using the <code>minimum_should_match</code> setting of the <code>terms</code> query with the keywords will help control the balance of precision/recall in the result set i.e
a high setting would have a small number of relevant results packed full of keywords and a setting of "1" would produce a more exhaustive results set with all documents containing <em>any</em> keyword.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_limitations_6">Limitations</h4>
<div class="sect4">
<h5 id="_no_support_for_child_aggregations">No support for child aggregations</h5>
<div class="paragraph">
<p>The significant_text aggregation intentionally does not support the addition of child aggregations because:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It would come with a high memory cost</p>
</li>
<li>
<p>It isn&#8217;t a generally useful feature and there is a workaround for those that need it</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The volume of candidate terms is generally very high and these are pruned heavily before the final
results are returned. Supporting child aggregations would generate additional churn and be inefficient.
Clients can always take the heavily-trimmed set of results from a <code>significant_text</code> request and
make a subsequent follow-up query using a <code>terms</code> aggregation with an <code>include</code> clause and child
aggregations to perform further analysis of selected keywords in a more efficient fashion.</p>
</div>
</div>
<div class="sect4">
<h5 id="_no_support_for_nested_objects">No support for nested objects</h5>
<div class="paragraph">
<p>The significant_text aggregation currently also cannot be used with text fields in
nested objects, because it works with the document JSON source. This makes this
feature inefficient when matching nested docs from stored JSON given a matching
Lucene docID.</p>
</div>
</div>
<div class="sect4">
<h5 id="_approximate_counts_2">Approximate counts</h5>
<div class="paragraph">
<p>The counts of how many documents contain a term provided in results are based on summing the samples returned from each shard and
as such may be:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>low if certain shards did not provide figures for a given term in their top sample</p>
</li>
<li>
<p>high when considering the background frequency as it may count occurrences found in deleted documents</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Like most design decisions, this is the basis of a trade-off in which we have chosen to provide fast performance at the cost of some (typically small) inaccuracies.
However, the <code>size</code> and <code>shard size</code> settings covered in the next section provide tools to help control the accuracy levels.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="significanttext-aggregation-parameters">Parameters</h4>
<div class="sect4">
<h5 id="_significance_heuristics">Significance heuristics</h5>
<div class="paragraph">
<p>This aggregation supports the same scoring heuristics (JLH, mutual_information, gnd, chi_square etc) as the <a href="search-aggregations-bucket.html#search-aggregations-bucket-significantterms-aggregation">significant terms</a> aggregation</p>
</div>
</div>
<div class="sect4">
<h5 id="sig-text-shard-size">Size &amp; Shard Size</h5>
<div class="paragraph">
<p>The <code>size</code> parameter can be set to define how many term buckets should be returned out of the overall terms list. By
default, the node coordinating the search process will request each shard to provide its own top term buckets
and once all shards respond, it will reduce the results to the final list that will then be returned to the client.
If the number of unique terms is greater than <code>size</code>, the returned list can be slightly off and not accurate
(it could be that the term counts are slightly off and it could even be that a term that should have been in the top
size buckets was not returned).</p>
</div>
<div class="paragraph">
<p>To ensure better accuracy a multiple of the final <code>size</code> is used as the number of terms to request from each shard
(<code>2 * (size * 1.5 + 10)</code>). To take manual control of this setting the <code>shard_size</code> parameter
can be  used to control the volumes of candidate terms produced by each shard.</p>
</div>
<div class="paragraph">
<p>Low-frequency terms can turn out to be the most interesting ones once all results are combined so the
significant_terms aggregation can produce higher-quality results when the <code>shard_size</code> parameter is set to
values significantly higher than the <code>size</code> setting. This ensures that a bigger volume of promising candidate terms are given
a consolidated review by the reducing node before the final selection. Obviously large candidate term lists
will cause extra network traffic and RAM usage so this is  quality/cost trade off that needs to be balanced.  If <code>shard_size</code> is set to -1 (the default) then <code>shard_size</code> will be automatically estimated based on the number of shards and the <code>size</code> parameter.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>shard_size</code> cannot be smaller than <code>size</code> (as it doesn&#8217;t make much sense). When it is, opensearch will
        override it and reset it to be equal to <code>size</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_minimum_document_count_3">Minimum document count</h5>
<div class="paragraph">
<p>It is possible to only return terms that match more than a configured number of hits using the <code>min_doc_count</code> option.
The Default value is 3.</p>
</div>
<div class="paragraph">
<p>Terms that score highly will be collected on a shard level and merged with the terms collected from other shards in a second step.
However, the shard does not have the information about the global term frequencies available. The decision if a term is added to a
candidate list depends only on the score computed on the shard using local shard frequencies, not the global frequencies of the word.
The <code>min_doc_count</code> criterion is only applied after merging local terms statistics of all shards. In a way the decision to add the
term as a candidate is made without being very <em>certain</em> about if the term will actually reach the required <code>min_doc_count</code>.
This might cause many (globally) high frequent terms to be missing in the final result if low frequent but high scoring terms populated
the candidate lists. To avoid this, the <code>shard_size</code> parameter can be increased to allow more candidate terms on the shards.
However, this increases memory consumption and network traffic.</p>
</div>
<div class="paragraph">
<p><code>shard_min_doc_count</code> parameter</p>
</div>
<div class="paragraph">
<p>The parameter <code>shard_min_doc_count</code> regulates the <em>certainty</em> a shard has if the term should actually be added to the candidate list or
not with respect to the <code>min_doc_count</code>. Terms will only be considered if their local shard frequency within the set is higher than the
<code>shard_min_doc_count</code>. If your dictionary contains many low frequent words and you are not interested in these (for example misspellings),
then you can set the <code>shard_min_doc_count</code> parameter to filter out candidate terms on a shard level that will with a reasonable certainty
not reach the required <code>min_doc_count</code> even after merging the local frequencies. <code>shard_min_doc_count</code> is set to <code>1</code> per default and has
no effect unless you explicitly set it.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Setting <code>min_doc_count</code> to <code>1</code> is generally not advised as it tends to return terms that
         are typos or other bizarre curiosities. Finding more than one instance of a term helps
         reinforce that, while still rare, the term was not the result of a one-off accident. The
         default value of 3 is used to provide a minimum weight-of-evidence.
         Setting <code>shard_min_doc_count</code> too high will cause significant candidate terms to be filtered out on a shard level.
         This value should be set much lower than <code>min_doc_count/#shards</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_custom_background_context_2">Custom background context</h5>
<div class="paragraph">
<p>The default source of statistical information for background term frequencies is the entire index and this
scope can be narrowed through the use of a <code>background_filter</code> to focus in on significant terms within a narrower
context:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET news/_search
{
  "query": {
    "match": {
      "content": "madrid"
    }
  },
  "aggs": {
    "tags": {
      "significant_text": {
        "field": "content",
        "background_filter": {
          "term": { "content": "spain" }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above filter would help focus in on terms that were peculiar to the city of Madrid rather than revealing
terms like "Spanish" that are unusual in the full index&#8217;s worldwide context but commonplace in the subset of documents containing the
word "Spain".</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Use of background filters will slow the query as each term&#8217;s postings must be filtered to determine a frequency
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_dealing_with_source_and_index_mappings">Dealing with source and index mappings</h5>
<div class="paragraph">
<p>Ordinarily the indexed field name and the original JSON field being retrieved share the same name.
However with more complex field mappings using features like <code>copy_to</code> the source
JSON field(s) and the indexed field being aggregated can differ.
In these cases it is possible to list the JSON _source fields from which text
will be analyzed using the <code>source_fields</code> parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET news/_search
{
  "query": {
    "match": {
      "custom_all": "opensearch"
    }
  },
  "aggs": {
    "tags": {
      "significant_text": {
        "field": "custom_all",
        "source_fields": [ "content", "title" ]
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_filtering_values_3">Filtering Values</h5>
<div class="paragraph">
<p>It is possible (although rarely required) to filter the values for which buckets will be created. This can be done using the <code>include</code> and
<code>exclude</code> parameters which are based on a regular expression string or arrays of exact terms. This functionality mirrors the features
described in the <a href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation">terms aggregation</a> documentation.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-terms-aggregation">Terms aggregation</h3>
<titleabbrev>Terms</titleabbrev>
<div class="paragraph">
<p>A multi-bucket value source based aggregation where buckets are dynamically built - one per unique value.</p>
</div>
<div class="paragraph">
<p>Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "genres": {
      "terms": { "field": "genre" } <b class="conum">(1)</b>
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>terms</code> aggregation should be a field of type <code>keyword</code> or any other data type suitable for bucket aggregations. In order to use it with <code>text</code> you will need to enable
<a href="getting-started-modify-data.html#fielddata">fielddata</a>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "genres": {
      "doc_count_error_upper_bound": 0,   <b class="conum">(1)</b>
      "sum_other_doc_count": 0,           <b class="conum">(2)</b>
      "buckets": [                        <b class="conum">(3)</b>
        {
          "key": "electronic",
          "doc_count": 6
        },
        {
          "key": "rock",
          "doc_count": 3
        },
        {
          "key": "jazz",
          "doc_count": 2
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>an upper bound of the error on the document counts for each term, see <a href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-approximate-counts">below</a></p>
</li>
<li>
<p>when there are lots of unique terms, OpenSearch only returns the top terms; this number is the sum of the document counts for all buckets that are not part of the response</p>
</li>
<li>
<p>the list of the top buckets, the meaning of <code>top</code> being defined by the <a href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-order">order</a></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By default, the <code>terms</code> aggregation will return the buckets for the top ten terms ordered by the <code>doc_count</code>. One can
change this default behaviour by setting the <code>size</code> parameter.</p>
</div>
<div class="sect3">
<h4 id="search-aggregations-bucket-terms-aggregation-size">Size</h4>
<div class="paragraph">
<p>The <code>size</code> parameter can be set to define how many term buckets should be returned out of the overall terms list. By
default, the node coordinating the search process will request each shard to provide its own top <code>size</code> term buckets
and once all shards respond, it will reduce the results to the final list that will then be returned to the client.
This means that if the number of unique terms is greater than <code>size</code>, the returned list is slightly off and not accurate
(it could be that the term counts are slightly off and it could even be that a term that should have been in the top
size buckets was not returned).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
If you want to retrieve <strong>all</strong> terms or all combinations of terms in a nested <code>terms</code> aggregation
      you should use the <a href="search-aggregations-bucket.html#search-aggregations-bucket-composite-aggregation">Composite</a> aggregation which
      allows to paginate over all possible terms rather than setting a size greater than the cardinality of the field in the
      <code>terms</code> aggregation. The <code>terms</code> aggregation is meant to return the <code>top</code> terms and does not allow pagination.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="search-aggregations-bucket-terms-aggregation-approximate-counts">Document counts are approximate</h4>
<div class="paragraph">
<p>Document counts (and the results of any sub aggregations) in the terms
aggregation are not always accurate. Each shard provides its own view of what
the ordered list of terms should be. These views are combined to give a final
view.</p>
</div>
</div>
<div class="sect3">
<h4 id="_shard_size_3">Shard Size</h4>
<div class="paragraph">
<p>The higher the requested <code>size</code> is, the more accurate the results will be, but also, the more expensive it will be to
compute the final results (both due to bigger priority queues that are managed on a shard level and due to bigger data
transfers between the nodes and the client).</p>
</div>
<div class="paragraph">
<p>The <code>shard_size</code> parameter can be  used to minimize the extra work that comes with bigger requested <code>size</code>. When defined,
it will determine how many terms the coordinating node will request from each shard. Once all the shards responded, the
coordinating node will then reduce them to a final result which will be based on the <code>size</code> parameter - this way,
one can increase the accuracy of the returned terms and avoid the overhead of streaming a big list of buckets back to
the client.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>shard_size</code> cannot be smaller than <code>size</code> (as it doesn&#8217;t make much sense). When it is, OpenSearch will
        override it and reset it to be equal to <code>size</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The default <code>shard_size</code> is <code>(size * 1.5 + 10)</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_calculating_document_count_error">Calculating Document Count Error</h4>
<div class="paragraph">
<p>There are two error values which can be shown on the terms aggregation. The first gives a value for the aggregation as
a whole which represents the maximum potential document count for a term which did not make it into the final list of
terms. This is calculated as the sum of the document count from the last term returned from each shard.</p>
</div>
</div>
<div class="sect3">
<h4 id="_per_bucket_document_count_error">Per bucket document count error</h4>
<div class="paragraph">
<p>The second error value can be enabled by setting the <code>show_term_doc_count_error</code> parameter to true:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "products": {
      "terms": {
        "field": "product",
        "size": 5,
        "show_term_doc_count_error": true
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This shows an error value for each term returned by the aggregation which represents the 'worst case' error in the document count
and can be useful when deciding on a value for the <code>shard_size</code> parameter. This is calculated by summing the document counts for
the last term returned by all shards which did not return the term.</p>
</div>
<div class="paragraph">
<p>These errors can only be calculated in this way when the terms are ordered by descending document count. When the aggregation is
ordered by the terms values themselves (either ascending or descending) there is no error in the document count since if a shard
does not return a particular term which appears in the results from another shard, it must not have that term in its index. When the
aggregation is either sorted by a sub aggregation or in order of ascending document count, the error in the document counts cannot be
determined and is given a value of -1 to indicate this.</p>
</div>
</div>
<div class="sect3">
<h4 id="search-aggregations-bucket-terms-aggregation-order">Order</h4>
<div class="paragraph">
<p>The order of the buckets can be customized by setting the <code>order</code> parameter. By default, the buckets are ordered by
their <code>doc_count</code> descending.  It is possible to change this behaviour as documented below:</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Sorting by ascending <code>_count</code> or by sub aggregation is discouraged as it increases the
<a href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-approximate-counts">error</a> on document counts.
It is fine when a single shard is queried, or when the field that is being aggregated was used
as a routing key at index time: in these cases results will be accurate since shards have disjoint
values. However otherwise, errors are unbounded. One particular case that could still be useful
is sorting by <a href="search-aggregations-metrics.html#search-aggregations-metrics-min-aggregation"><code>min</code></a> or
<a href="search-aggregations-metrics.html#search-aggregations-metrics-max-aggregation"><code>max</code></a> aggregation: counts will not be accurate
but at least the top buckets will be correctly picked.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Ordering the buckets by their doc <code>_count</code> in an ascending manner:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "genres": {
      "terms": {
        "field": "genre",
        "order": { "_count": "asc" }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ordering the buckets alphabetically by their terms in an ascending manner:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "genres": {
      "terms": {
        "field": "genre",
        "order": { "_key": "asc" }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>deprecated[Use <code>_key</code> instead of <code>_term</code> to order buckets by their term]</p>
</div>
<div class="paragraph">
<p>Ordering the buckets by single value metrics sub-aggregation (identified by the aggregation name):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "genres": {
      "terms": {
        "field": "genre",
        "order": { "max_play_count": "desc" }
      },
      "aggs": {
        "max_play_count": { "max": { "field": "play_count" } }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ordering the buckets by multi value metrics sub-aggregation (identified by the aggregation name):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "genres": {
      "terms": {
        "field": "genre",
        "order": { "playback_stats.max": "desc" }
      },
      "aggs": {
        "playback_stats": { "stats": { "field": "play_count" } }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Pipeline aggs cannot be used for sorting</div>
<div class="paragraph">
<p><a href="search-aggregations-pipeline.html">Pipeline aggregations</a> are run during the
reduce phase after all other aggregations have already completed.  For this
reason, they cannot be used for ordering.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is also possible to order the buckets based on a "deeper" aggregation in the hierarchy. This is supported as long
as the aggregations path are of a single-bucket type, where the last aggregation in the path may either be a single-bucket
one or a metrics one. If it&#8217;s a single-bucket type, the order will be defined by the number of docs in the bucket (i.e. <code>doc_count</code>),
in case it&#8217;s a metrics one, the same rules as above apply (where the path must indicate the metric name to sort by in case of
a multi-value metrics aggregation, and in case of a single-value metrics aggregation the sort will be applied on that value).</p>
</div>
<div class="paragraph">
<p>The path must be defined in the following form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ebnf" data-lang="ebnf">AGG_SEPARATOR       =  '&gt;' ;
METRIC_SEPARATOR    =  '.' ;
AGG_NAME            =  &lt;the name of the aggregation&gt; ;
METRIC              =  &lt;the name of the metric (in case of multi-value metrics aggregation)&gt; ;
PATH                =  &lt;AGG_NAME&gt; [ &lt;AGG_SEPARATOR&gt;, &lt;AGG_NAME&gt; ]* [ &lt;METRIC_SEPARATOR&gt;, &lt;METRIC&gt; ] ;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "countries": {
      "terms": {
        "field": "artist.country",
        "order": { "rock&gt;playback_stats.avg": "desc" }
      },
      "aggs": {
        "rock": {
          "filter": { "term": { "genre": "rock" } },
          "aggs": {
            "playback_stats": { "stats": { "field": "play_count" } }
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above will sort the artist&#8217;s countries buckets based on the average play count among the rock songs.</p>
</div>
<div class="paragraph">
<p>Multiple criteria can be used to order the buckets by providing an array of order criteria such as the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "countries": {
      "terms": {
        "field": "artist.country",
        "order": [ { "rock&gt;playback_stats.avg": "desc" }, { "_count": "desc" } ]
      },
      "aggs": {
        "rock": {
          "filter": { "term": { "genre": "rock" } },
          "aggs": {
            "playback_stats": { "stats": { "field": "play_count" } }
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above will sort the artist&#8217;s countries buckets based on the average play count among the rock songs and then by
their <code>doc_count</code> in descending order.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
In the event that two buckets share the same values for all order criteria the bucket&#8217;s term value is used as a
tie-breaker in ascending alphabetical order to prevent non-deterministic ordering of buckets.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_minimum_document_count_4">Minimum document count</h4>
<div class="paragraph">
<p>It is possible to only return terms that match more than a configured number of hits using the <code>min_doc_count</code> option:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "tags": {
      "terms": {
        "field": "tags",
        "min_doc_count": 10
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above aggregation would only return tags which have been found in 10 hits or more. Default value is <code>1</code>.</p>
</div>
<div class="paragraph">
<p>Terms are collected and ordered on a shard level and merged with the terms collected from other shards in a second step. However, the shard does not have the information about the global document count available. The decision if a term is added to a candidate list depends only on the order computed on the shard using local shard frequencies. The <code>min_doc_count</code> criterion is only applied after merging local terms statistics of all shards. In a way the decision to add the term as a candidate is made without being very <em>certain</em> about if the term will actually reach the required <code>min_doc_count</code>. This might cause many (globally) high frequent terms to be missing in the final result if low frequent terms populated the candidate lists. To avoid this, the <code>shard_size</code> parameter can be increased to allow more candidate terms on the shards. However, this increases memory consumption and network traffic.</p>
</div>
<div class="paragraph">
<p><code>shard_min_doc_count</code> parameter</p>
</div>
<div class="paragraph">
<p>The parameter <code>shard_min_doc_count</code> regulates the <em>certainty</em> a shard has if the term should actually be added to the candidate list or not with respect to the <code>min_doc_count</code>. Terms will only be considered if their local shard frequency within the set is higher than the <code>shard_min_doc_count</code>. If your dictionary contains many low frequent terms and you are not interested in those (for example misspellings), then you can set the <code>shard_min_doc_count</code> parameter to filter out candidate terms on a shard level that will with a reasonable certainty not reach the required <code>min_doc_count</code> even after merging the local counts. <code>shard_min_doc_count</code> is set to <code>0</code> per default and has no effect unless you explicitly set it.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Setting <code>min_doc_count</code>=<code>0</code> will also return buckets for terms that didn&#8217;t match any hit. However, some of
         the returned terms which have a document count of zero might only belong to deleted documents or documents
         from other types, so there is no warranty that a <code>match_all</code> query would find a positive document count for
         those terms.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
When NOT sorting on <code>doc_count</code> descending, high values of <code>min_doc_count</code> may return a number of buckets
         which is less than <code>size</code> because not enough data was gathered from the shards. Missing buckets can be
         back by increasing <code>shard_size</code>.
         Setting <code>shard_min_doc_count</code> too high will cause terms to be filtered out on a shard level. This value should be set much lower than <code>min_doc_count/#shards</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="search-aggregations-bucket-terms-aggregation-script">Script</h4>
<div class="paragraph">
<p>Generating the terms using a script:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "genres": {
      "terms": {
        "script": {
          "source": "doc['genre'].value",
          "lang": "painless"
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will interpret the <code>script</code> parameter as an <code>inline</code> script with the default script language and no script parameters. To use a stored script use the following syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "genres": {
      "terms": {
        "script": {
          "id": "my_script",
          "params": {
            "field": "genre"
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_value_script_2">Value Script</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "genres": {
      "terms": {
        "field": "genre",
        "script": {
          "source": "'Genre: ' +_value",
          "lang": "painless"
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_filtering_values_4">Filtering Values</h4>
<div class="paragraph">
<p>It is possible to filter the values for which buckets will be created. This can be done using the <code>include</code> and
<code>exclude</code> parameters which are based on regular expression strings or arrays of exact values. Additionally,
<code>include</code> clauses can filter using <code>partition</code> expressions.</p>
</div>
<div class="sect4">
<h5 id="_filtering_values_with_regular_expressions_2">Filtering Values with regular expressions</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "tags": {
      "terms": {
        "field": "tags",
        "include": ".*sport.*",
        "exclude": "water_.*"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, buckets will be created for all the tags that has the word <code>sport</code> in them, except those starting
with <code>water_</code> (so the tag <code>water_sports</code> will not be aggregated). The <code>include</code> regular expression will determine what
values are "allowed" to be aggregated, while the <code>exclude</code> determines the values that should not be aggregated. When
both are defined, the <code>exclude</code> has precedence, meaning, the <code>include</code> is evaluated first and only then the <code>exclude</code>.</p>
</div>
<div class="paragraph">
<p>The syntax is the same as <a href="regexp-syntax.html">regexp queries</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_filtering_values_with_exact_values_2">Filtering Values with exact values</h5>
<div class="paragraph">
<p>For matching based on exact values the <code>include</code> and <code>exclude</code> parameters can simply take an array of
strings that represent the terms as they are found in the index:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "JapaneseCars": {
      "terms": {
        "field": "make",
        "include": [ "mazda", "honda" ]
      }
    },
    "ActiveCarManufacturers": {
      "terms": {
        "field": "make",
        "exclude": [ "rover", "jensen" ]
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_filtering_values_with_partitions">Filtering Values with partitions</h5>
<div class="paragraph">
<p>Sometimes there are too many unique terms to process in a single request/response pair so
it can be useful to break the analysis up into multiple requests.
This can be achieved by grouping the field&#8217;s values into a number of partitions at query-time and processing
only one partition in each request.
Consider this request which is looking for accounts that have not logged any access recently:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
   "size": 0,
   "aggs": {
      "expired_sessions": {
         "terms": {
            "field": "account_id",
            "include": {
               "partition": 0,
               "num_partitions": 20
            },
            "size": 10000,
            "order": {
               "last_access": "asc"
            }
         },
         "aggs": {
            "last_access": {
               "max": {
                  "field": "access_date"
               }
            }
         }
      }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This request is finding the last logged access date for a subset of customer accounts because we
might want to expire some customer accounts who haven&#8217;t been seen for a long while.
The <code>num_partitions</code> setting has requested that the unique account_ids are organized evenly into twenty
partitions (0 to 19). and the <code>partition</code> setting in this request filters to only consider account_ids falling
into partition 0. Subsequent requests should ask for partitions 1 then 2 etc to complete the expired-account analysis.</p>
</div>
<div class="paragraph">
<p>Note that the <code>size</code> setting for the number of results returned needs to be tuned with the <code>num_partitions</code>.
For this particular account-expiration example the process for balancing values for <code>size</code> and <code>num_partitions</code> would be as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Use the <code>cardinality</code> aggregation to estimate the total number of unique account_id values</p>
</li>
<li>
<p>Pick a value for <code>num_partitions</code> to break the number from 1) up into more manageable chunks</p>
</li>
<li>
<p>Pick a <code>size</code> value for the number of responses we want from each partition</p>
</li>
<li>
<p>Run a test request</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If we have a circuit-breaker error we are trying to do too much in one request and must increase <code>num_partitions</code>.
If the request was successful but the last account ID in the date-sorted test response was still an account we might want to
expire then we may be missing accounts of interest and have set our numbers too low. We must either</p>
</div>
<div class="ulist">
<ul>
<li>
<p>increase the <code>size</code> parameter to return more results per partition (could be heavy on memory) or</p>
</li>
<li>
<p>increase the <code>num_partitions</code> to consider less accounts per request (could increase overall processing time as we need to make more requests)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ultimately this is a balancing act between managing the OpenSearch resources required to process a single request and the volume
of requests that the client application must issue to complete a task.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_multi_field_terms_aggregation">Multi-field terms aggregation</h4>
<div class="paragraph">
<p>The <code>terms</code> aggregation does not support collecting terms from multiple fields
in the same document.  The reason is that the <code>terms</code> agg doesn&#8217;t collect the
string term values themselves, but rather uses
<a href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-execution-hint">global ordinals</a>
to produce a list of all of the unique values in the field.  Global ordinals
results in an important performance boost which would not be possible across
multiple fields.</p>
</div>
<div class="paragraph">
<p>There are two approaches that you can use to perform a <code>terms</code> agg across
multiple fields:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation-script">Script</a></dt>
<dd>
<p>Use a script to retrieve terms from multiple fields.  This disables the global
ordinals optimization and will be slower than collecting terms from a single
field, but it gives you the flexibility to implement this option at search
time.</p>
</dd>
<dt class="hdlist1"><a href="mapping-params.html#copy-to"><code>copy_to</code> field</a></dt>
<dd>
<p>If you know ahead of time that you want to collect the terms from two or more
fields, then use <code>copy_to</code> in your mapping to create a new dedicated field at
index time which contains the values from both fields.  You can aggregate on
this single field, which will benefit from the global ordinals optimization.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="search-aggregations-bucket-terms-aggregation-collect">Collect mode</h4>
<div class="paragraph">
<p>Deferring calculation of child aggregations</p>
</div>
<div class="paragraph">
<p>For fields with many unique terms and a small number of required results it can be more efficient to delay the calculation
of child aggregations until the top parent-level aggs have been pruned. Ordinarily, all branches of the aggregation tree
are expanded in one depth-first pass and only then any pruning occurs.
In some scenarios this can be very wasteful and can hit memory constraints.
An example problem scenario is querying a movie database for the 10 most popular actors and their 5 most common co-stars:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "actors": {
      "terms": {
        "field": "actors",
        "size": 10
      },
      "aggs": {
        "costars": {
          "terms": {
            "field": "actors",
            "size": 5
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Even though the number of actors may be comparatively small and we want only 50 result buckets there is a combinatorial explosion of buckets
during calculation - a single actor can produce n² buckets where n is the number of actors. The sane option would be to first determine
the 10 most popular actors and only then examine the top co-stars for these 10 actors. This alternative strategy is what we call the <code>breadth_first</code> collection
mode as opposed to the <code>depth_first</code> mode.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The <code>breadth_first</code> is the default mode for fields with a cardinality bigger than the requested size or when the cardinality is unknown (numeric fields or scripts for instance).
It is possible to override the default heuristic and to provide a collect mode directly in the request:
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "actors": {
      "terms": {
        "field": "actors",
        "size": 10,
        "collect_mode": "breadth_first" <b class="conum">(1)</b>
      },
      "aggs": {
        "costars": {
          "terms": {
            "field": "actors",
            "size": 5
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>the possible values are <code>breadth_first</code> and <code>depth_first</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When using <code>breadth_first</code> mode the set of documents that fall into the uppermost buckets are
cached for subsequent replay so there is a memory overhead in doing this which is linear with the number of matching documents.
Note that the <code>order</code> parameter can still be used to refer to data from a child aggregation when using the <code>breadth_first</code> setting - the parent
aggregation understands that this child aggregation will need to be called first before any of the other child aggregations.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Nested aggregations such as <code>top_hits</code> which require access to score information under an aggregation that uses the <code>breadth_first</code>
collection mode need to replay the query on the second pass but only for the documents belonging to the top buckets.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="search-aggregations-bucket-terms-aggregation-execution-hint">Execution hint</h4>
<div class="paragraph">
<p>There are different mechanisms by which terms aggregations can be executed:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>by using field values directly in order to aggregate data per-bucket (<code>map</code>)</p>
</li>
<li>
<p>by using global ordinals of the field and allocating one bucket per global ordinal (<code>global_ordinals</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>OpenSearch tries to have sensible defaults so this is something that generally doesn&#8217;t need to be configured.</p>
</div>
<div class="paragraph">
<p><code>global_ordinals</code> is the default option for <code>keyword</code> field, it uses global ordinals to allocates buckets dynamically
so memory usage is linear to the number of values of the documents that are part of the aggregation scope.</p>
</div>
<div class="paragraph">
<p><code>map</code> should only be considered when very few documents match a query. Otherwise the ordinals-based execution mode
is significantly faster. By default, <code>map</code> is only used when running an aggregation on scripts, since they don&#8217;t have
ordinals.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "tags": {
      "terms": {
        "field": "tags",
        "execution_hint": "map" <b class="conum">(1)</b>
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The possible values are <code>map</code>, <code>global_ordinals</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Please note that OpenSearch will ignore this execution hint if it is not applicable and that there is no backward compatibility guarantee on these hints.</p>
</div>
</div>
<div class="sect3">
<h4 id="_missing_value_4">Missing value</h4>
<div class="paragraph">
<p>The <code>missing</code> parameter defines how documents that are missing a value should be treated.
By default they will be ignored but it is also possible to treat them as if they
had a value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "aggs": {
    "tags": {
      "terms": {
        "field": "tags",
        "missing": "N/A" <b class="conum">(1)</b>
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Documents without a value in the <code>tags</code> field will fall into the same bucket as documents that have the value <code>N/A</code>.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_mixing_field_types">Mixing field types</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
When aggregating on multiple indices the type of the aggregated field may not be the same in all indices.
Some types are compatible with each other (<code>integer</code> and <code>long</code> or <code>float</code> and <code>double</code>) but when the types are a mix
of decimal and non-decimal number the terms aggregation will promote the non-decimal numbers to decimal numbers.
This can result in a loss of precision in the bucket values.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-variablewidthhistogram-aggregation">Variable width histogram aggregation</h3>
<titleabbrev>Variable width histogram</titleabbrev>
<div class="paragraph">
<p>experimental::["This functionality is experimental and may be changed or removed completely in a future release. OpenSearch will take a best effort approach to fix any issues, but experimental features are not subject to the support SLA of official GA features.</p>
</div>
<div class="paragraph">
<p>This is a multi-bucket aggregation similar to <a href="search-aggregations-bucket.html#search-aggregations-bucket-histogram-aggregation">Histogram aggregation</a>.
However, the width of each bucket is not specified. Rather, a target number of buckets is provided and bucket intervals
are dynamically determined based on the document distribution. This is done using a simple one-pass document clustering algorithm
that aims to obtain low distances between bucket centroids. Unlike other multi-bucket aggregations, the intervals will not
necessarily have a uniform width.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
The number of buckets returned will always be less than or equal to the target number.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Requesting a target of 2 buckets.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /sales/_search?size=0
{
  "aggs": {
    "prices": {
      "variable_width_histogram": {
        "field": "price",
        "buckets": 2
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations": {
    "prices": {
      "buckets": [
        {
          "min": 10.0,
          "key": 30.0,
          "max": 50.0,
          "doc_count": 2
        },
        {
          "min": 150.0,
          "key": 185.0,
          "max": 200.0,
          "doc_count": 5
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
This aggregation cannot currently be nested under any aggregation that collects from more than a single bucket.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_clustering_algorithm">Clustering Algorithm</h4>
<div class="paragraph">
<p>Each shard fetches the first <code>initial_buffer</code> documents and stores them in memory. Once the buffer is full, these documents
are sorted and linearly separated into <code>3/4 * shard_size buckets</code>.
Next each remaining documents is either collected into the nearest bucket, or placed into a new bucket if it is distant
from all the existing ones. At most <code>shard_size</code> total buckets are created.</p>
</div>
<div class="paragraph">
<p>In the reduce step, the coordinating node sorts the buckets from all shards by their centroids. Then, the two buckets
with the nearest centroids are repeatedly merged until the target number of buckets is achieved.
This merging procedure is a form of <a href="https://en.wikipedia.org/wiki/Hierarchical_clustering">agglomerative hierarchical clustering</a>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
A shard can return fewer than <code>shard_size</code> buckets, but it cannot return more.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_shard_size_4">Shard size</h4>
<div class="paragraph">
<p>The <code>shard_size</code> parameter specifies the number of buckets that the coordinating node will request from each shard.
A higher <code>shard_size</code> leads each shard to produce smaller buckets. This reduce the likelihood of buckets overlapping
after the reduction step. Increasing the <code>shard_size</code> will improve the accuracy of the histogram, but it will
also make it more expensive to compute the final result because bigger priority queues will have to be managed on a
shard level, and the data transfers between the nodes and the client will be larger.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Parameters <code>buckets</code>, <code>shard_size</code>, and <code>initial_buffer</code> are optional. By default, <code>buckets = 10</code>, <code>shard_size = buckets * 50</code>, and <code>initial_buffer = min(10 * shard_size, 50000)</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_initial_buffer">Initial Buffer</h4>
<div class="paragraph">
<p>The <code>initial_buffer</code> parameter can be used to specify the number of individual documents that will be stored in memory
on a shard before the initial bucketing algorithm is run. Bucket distribution is determined using this sample
of <code>initial_buffer</code> documents. So, although a higher <code>initial_buffer</code> will use more memory, it will lead to more representative
clusters.</p>
</div>
</div>
<div class="sect3">
<h4 id="_bucket_bounds_are_approximate">Bucket bounds are approximate</h4>
<div class="paragraph">
<p>During the reduce step, the master node continuously merges the two buckets with the nearest centroids. If two buckets have
overlapping bounds but distant centroids, then it is possible that they will not be merged. Because of this, after
reduction the maximum value in some interval (<code>max</code>) might be greater than the minimum value in the subsequent
bucket (<code>min</code>). To reduce the impact of this error, when such an overlap occurs the bound between these intervals is adjusted to be <code>(max + min) / 2</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Bucket bounds are very sensitive to outliers
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="search-aggregations-bucket-range-field-note">Subtleties of bucketing range fields</h3>
<div class="sect3">
<h4 id="_documents_are_counted_for_each_bucket_they_land_in">Documents are counted for each bucket they land in</h4>
<div class="paragraph">
<p>Since a range represents multiple values, running a bucket aggregation over a
range field can result in the same document landing in multiple buckets. This
can lead to surprising behavior, such as the sum of bucket counts being higher
than the number of matched documents.  For example, consider the following
index:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT range_index
{
  "settings": {
    "number_of_shards": 2
  },
  "mappings": {
    "properties": {
      "expected_attendees": {
        "type": "integer_range"
      },
      "time_frame": {
        "type": "date_range",
        "format": "yyyy-MM-dd||epoch_millis"
      }
    }
  }
}

PUT range_index/_doc/1?refresh
{
  "expected_attendees" : {
    "gte" : 10,
    "lte" : 20
  },
  "time_frame" : {
    "gte" : "2019-10-28",
    "lte" : "2019-11-04"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The range is wider than the interval in the following aggregation, and thus the
document will land in multiple buckets.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /range_index/_search?size=0
{
  "aggs": {
    "range_histo": {
      "histogram": {
        "field": "expected_attendees",
        "interval": 5
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the interval is <code>5</code> (and the offset is <code>0</code> by default), we expect buckets <code>10</code>,
<code>15</code>, and <code>20</code>. Our range document will fall in all three of these buckets.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations" : {
    "range_histo" : {
      "buckets" : [
        {
          "key" : 10.0,
          "doc_count" : 1
        },
        {
          "key" : 15.0,
          "doc_count" : 1
        },
        {
          "key" : 20.0,
          "doc_count" : 1
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A document cannot exist partially in a bucket; For example, the above document
cannot count as one-third in each of the above three buckets. In this example,
since the document&#8217;s range landed in multiple buckets, the full value of that
document would also be counted in any sub-aggregations for each bucket as well.</p>
</div>
</div>
<div class="sect3">
<h4 id="_query_bounds_are_not_aggregation_filters">Query bounds are not aggregation filters</h4>
<div class="paragraph">
<p>Another unexpected behavior can arise when a query is used to filter on the
field being aggregated. In this case, a document could match the query but
still have one or both of the endpoints of the range outside the query.
Consider the following aggregation on the above document:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /range_index/_search?size=0
{
  "query": {
    "range": {
      "time_frame": {
        "gte": "2019-11-01",
        "format": "yyyy-MM-dd"
      }
    }
  },
  "aggs": {
    "november_data": {
      "date_histogram": {
        "field": "time_frame",
        "calendar_interval": "day",
        "format": "yyyy-MM-dd"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Even though the query only considers days in November, the aggregation
generates 8 buckets (4 in October, 4 in November) because the aggregation is
calculated over the ranges of all matching documents.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...
  "aggregations" : {
    "november_data" : {
      "buckets" : [
              {
          "key_as_string" : "2019-10-28",
          "key" : 1572220800000,
          "doc_count" : 1
        },
        {
          "key_as_string" : "2019-10-29",
          "key" : 1572307200000,
          "doc_count" : 1
        },
        {
          "key_as_string" : "2019-10-30",
          "key" : 1572393600000,
          "doc_count" : 1
        },
        {
          "key_as_string" : "2019-10-31",
          "key" : 1572480000000,
          "doc_count" : 1
        },
        {
          "key_as_string" : "2019-11-01",
          "key" : 1572566400000,
          "doc_count" : 1
        },
        {
          "key_as_string" : "2019-11-02",
          "key" : 1572652800000,
          "doc_count" : 1
        },
        {
          "key_as_string" : "2019-11-03",
          "key" : 1572739200000,
          "doc_count" : 1
        },
        {
          "key_as_string" : "2019-11-04",
          "key" : 1572825600000,
          "doc_count" : 1
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Depending on the use case, a <code>CONTAINS</code> query could limit the documents to only
those that fall entirely in the queried range.  In this example, the one
document would not be included and the aggregation would be empty.  Filtering
the buckets after the aggregation is also an option, for use cases where the
document should be counted but the out of bounds data can be safely ignored.</p>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph nav-footer">
<p>↑ Up: <a href="search-aggregations.html">Aggregations</a> | ⌂ Home: <a href="index.html">OpenSearch Reference</a> | Next: <a href="search-aggregations-metrics.html">Metrics aggregations</a> →</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-04-12 14:08:20 -0700
</div>
</div>
</body>
</html>