<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<title>OpenSearch Reference</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:50%;border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<style>.toc-current{font-weight: bold;} .toc-root{font-family: "Open Sans","DejaVu Sans",sans-serif;
                       font-size: 0.9em;} #content{display: flex; flex-direction: column; flex: 1 1 auto;}
             .nav-footer{text-align: center; margin-top: auto;}
             .nav-footer > p > a {white-space: nowrap;}</style>
</head>
<body id="mapping-types" class="book toc2 toc-left">
<div id="header">
<h1>OpenSearch Reference</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<p><span class="toc-root"><a href="index.html">OpenSearch Reference</a></span></p><ul class="sectlevel1">
<li><a href="opensearch-intro.html">What is OpenSearch?</a>
</li>
<li><a href="getting-started.html">Getting started with OpenSearch</a>
</li>
<li><a href="setup.html">Set up OpenSearch</a>
</li>
<li><a href="setup-upgrade.html">Upgrade OpenSearch</a>
</li>
<li><a href="index-modules.html">Index modules</a>
</li>
<li><a href="mapping.html">Mapping</a>
<ul class="sectlevel1">
<li><a href="mapping-types.html"><span class="toc-current">Field data types</span></a>
<ul class="sectlevel2">
<li><a href="mapping-types.html#alias">Alias field type</a>
</li>
<li><a href="mapping-types.html#array">Arrays</a>
</li>
<li><a href="mapping-types.html#binary">Binary field type</a>
</li>
<li><a href="mapping-types.html#boolean">Boolean field type</a>
</li>
<li><a href="mapping-types.html#date">Date field type</a>
</li>
<li><a href="mapping-types.html#date_nanos">Date nanoseconds field type</a>
</li>
<li><a href="mapping-types.html#geo-point">Geo-point field type</a>
</li>
<li><a href="mapping-types.html#geo-shape">Geo-shape field type</a>
</li>
<li><a href="mapping-types.html#ip">IP field type</a>
</li>
<li><a href="mapping-types.html#parent-join">Join field type</a>
</li>
<li><a href="mapping-types.html#keyword">Keyword type family</a>
</li>
<li><a href="mapping-types.html#nested">Nested field type</a>
</li>
<li><a href="mapping-types.html#number">Numeric field types</a>
</li>
<li><a href="mapping-types.html#object">Object field type</a>
</li>
<li><a href="mapping-types.html#percolator">Percolator field type</a>
</li>
<li><a href="mapping-types.html#range">Range field types</a>
</li>
<li><a href="mapping-types.html#rank-feature">Rank feature field type</a>
</li>
<li><a href="mapping-types.html#rank-features">Rank features field type</a>
</li>
<li><a href="mapping-types.html#search-as-you-type">Search-as-you-type field type</a>
</li>
<li><a href="mapping-types.html#text">Text field type</a>
</li>
<li><a href="mapping-types.html#token-count">Token count field type</a>
</li>
</ul>
</li>
<li><a href="mapping-fields.html">Metadata fields</a>
</li>
<li><a href="mapping-params.html">Mapping parameters</a>
</li>
<li><a href="dynamic-mapping.html">Dynamic Mapping</a>
</li>
</ul>
</li>
<li><a href="analysis.html">Text analysis</a>
</li>
<li><a href="index-templates.html">Index templates</a>
</li>
<li><a href="ingest.html">Ingest node</a>
</li>
<li><a href="search-your-data.html">Search your data</a>
</li>
<li><a href="query-dsl.html">Query DSL</a>
</li>
<li><a href="search-aggregations.html">Aggregations</a>
</li>
<li><a href="modules-scripting.html">Scripting</a>
</li>
<li><a href="high-availability.html">Set up a cluster for high availability</a>
</li>
<li><a href="snapshot-restore.html">Snapshot and restore</a>
</li>
<li><a href="commands.html">Command line tools</a>
</li>
<li><a href="how-to.html">How To</a>
</li>
<li><a href="glossary.html">Glossary of terms</a>
</li>
<li><a href="rest-apis.html">REST APIs</a>
</li>
<li><a href="breaking-changes.html">Migration guide</a>
</li>
<li><a href="opensearch-release-notes.html">Release notes</a>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="mapping-types">Field data types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Each field has a <em>field data type</em>, or <em>field type</em>. This type indicates the
kind of data the field contains, such as strings or boolean values, and its
intended use. For example, you can index strings to both <code>text</code> and <code>keyword</code>
fields. However, <code>text</code> field values are <a href="analysis.html">analyzed</a> for full-text
search while <code>keyword</code> strings are left as-is for filtering and sorting.</p>
</div>
<div class="paragraph">
<p>Field types are grouped by <em>family</em>. Types in the same family support the same
search functionality but may have different space usage or performance
characteristics.</p>
</div>
<div class="paragraph">
<p>Currently, the only type family is <code>keyword</code>, which consists of the <code>keyword</code>,
<code>constant_keyword</code>, and <code>wildcard</code> field types. Other type families have only a
single field type. For example, the <code>boolean</code> type family consists of one field
type: <code>boolean</code>.</p>
</div>
<h4 id="_core_datatypes" class="discrete">Common types</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="mapping-types.html#binary"><code>binary</code></a></dt>
<dd>
<p>Binary value encoded as a Base64 string.</p>
</dd>
<dt class="hdlist1"><a href="mapping-types.html#boolean"><code>boolean</code></a></dt>
<dd>
<p><code>true</code> and <code>false</code> values.</p>
</dd>
<dt class="hdlist1"><a href="mapping-types.html#keyword">Keywords</a></dt>
<dd>
<p>The keyword family, including <code>keyword</code>, <code>constant_keyword</code>,
and <code>wildcard</code>.</p>
</dd>
<dt class="hdlist1"><a href="mapping-types.html#number">Numbers</a></dt>
<dd>
<p>Numeric types, such as <code>long</code> and <code>double</code>, used to
express amounts.</p>
</dd>
<dt class="hdlist1">Dates</dt>
<dd>
<p>Date types, including <a href="mapping-types.html#date"><code>date</code></a> and
<a href="mapping-types.html#date_nanos"><code>date_nanos</code></a>.</p>
</dd>
<dt class="hdlist1"><a href="mapping-types.html#alias"><code>alias</code></a></dt>
<dd>
<p>Defines an alias for an existing field.</p>
</dd>
</dl>
</div>
<h4 id="object-types" class="discrete">Objects and relational types</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="mapping-types.html#object"><code>object</code></a></dt>
<dd>
<p>A JSON object.</p>
</dd>
<dt class="hdlist1"><a href="mapping-types.html#nested"><code>nested</code></a></dt>
<dd>
<p>A JSON object that preserves the relationship
between its subfields.</p>
</dd>
<dt class="hdlist1"><a href="mapping-types.html#parent-join"><code>join</code></a></dt>
<dd>
<p>Defines a parent/child relationship for documents
in the same index.</p>
</dd>
</dl>
</div>
<h4 id="structured-data-types" class="discrete">Structured data types</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="mapping-types.html#range">Range</a></dt>
<dd>
<p>Range types, such as <code>long_range</code>, <code>double_range</code>,
<code>date_range</code>, and <code>ip_range</code>.</p>
</dd>
<dt class="hdlist1"><a href="mapping-types.html#ip"><code>ip</code></a></dt>
<dd>
<p>IPv4 and IPv6 addresses.</p>
</dd>
<dt class="hdlist1"><a href="https://www.opensearch.org/guide/en/opensearch/plugins/{branch}/mapper-murmur3.html"><code>murmur3</code></a></dt>
<dd>
<p>Compute and stores hashes of
values.</p>
</dd>
</dl>
</div>
<h4 id="aggregated-data-types" class="discrete">Aggregate data types</h4>
<h4 id="text-search-types" class="discrete">Text search types</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="mapping-types.html#text"><code>text</code></a></dt>
<dd>
<p>Analyzed, unstructured text.</p>
</dd>
<dt class="hdlist1"><a href="https://www.opensearch.org/guide/en/opensearch/plugins/{branch}/mapper-annotated-text.html"><code>annotated-text</code></a></dt>
<dd>
<p>Text containing special
markup. Used for identifying named entities.</p>
</dd>
<dt class="hdlist1"><a href="search.html#completion-suggester"><code>completion</code></a></dt>
<dd>
<p>Used for auto-complete suggestions.</p>
</dd>
<dt class="hdlist1"><a href="mapping-types.html#search-as-you-type"><code>search_as_you_type</code></a></dt>
<dd>
<p><code>text</code>-like type for
as-you-type completion.</p>
</dd>
<dt class="hdlist1"><a href="mapping-types.html#token-count"><code>token_count</code></a></dt>
<dd>
<p>A count of tokens in a text.</p>
</dd>
</dl>
</div>
<h4 id="document-ranking-types" class="discrete">Document ranking types</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="mapping-types.html#rank-feature"><code>rank_feature</code></a></dt>
<dd>
<p>Records a numeric feature to boost hits at
query time.</p>
</dd>
<dt class="hdlist1"><a href="mapping-types.html#rank-features"><code>rank_features</code></a></dt>
<dd>
<p>Records numeric features to boost hits at
query time.</p>
</dd>
</dl>
</div>
<h4 id="spatial_datatypes" class="discrete">Spatial data types</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="mapping-types.html#geo-point"><code>geo_point</code></a></dt>
<dd>
<p>Latitude and longitude points.</p>
</dd>
<dt class="hdlist1"><a href="mapping-types.html#geo-shape"><code>geo_shape</code></a></dt>
<dd>
<p>Complex shapes, such as polygons.</p>
</dd>
</dl>
</div>
<h4 id="other-types" class="discrete">Other types</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="mapping-types.html#percolator"><code>percolator</code></a></dt>
<dd>
<p>Indexes queries written in <a href="query-dsl.html">Query DSL</a>.</p>
</dd>
</dl>
</div>
<h3 id="types-array-handling" class="discrete">Arrays</h3>
<div class="paragraph">
<p>In OpenSearch, arrays do not require a dedicated field data type. Any field can contain
zero or more values by default, however, all values in the array must be of the
same field type. See <a href="mapping-types.html#array">Arrays</a>.</p>
</div>
<h3 id="_multi_fields" class="discrete">Multi-fields</h3>
<div class="paragraph">
<p>It is often useful to index the same field in different ways for different
purposes. For instance, a <code>string</code> field could be mapped as
a <code>text</code> field for full-text search, and as a <code>keyword</code> field for
sorting or aggregations.  Alternatively, you could index a text field with
the <a href="analysis-analyzers.html#analysis-standard-analyzer"><code>standard</code> analyzer</a>, the
<a href="analysis-analyzers.html#english-analyzer"><code>english</code></a> analyzer, and the
<a href="analysis-analyzers.html#french-analyzer"><code>french</code> analyzer</a>.</p>
</div>
<div class="paragraph">
<p>This is the purpose of <em>multi-fields</em>. Most field types support multi-fields
via the <a href="mapping-params.html#multi-fields"><code>fields</code></a> parameter.</p>
</div>
<div class="sect2">
<h3 id="alias">Alias field type</h3>
<titleabbrev>Alias</titleabbrev>
<div class="paragraph">
<p>An <code>alias</code> mapping defines an alternate name for a field in the  index.
The alias can be used in place of the target field in <a href="search.html">search</a> requests,
and selected other APIs like <a href="search.html#search-field-caps">field capabilities</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT trips
{
  "mappings": {
    "properties": {
      "distance": {
        "type": "long"
      },
      "route_length_miles": {
        "type": "alias",
        "path": "distance" <b class="conum">(1)</b>
      },
      "transit_mode": {
        "type": "keyword"
      }
    }
  }
}

GET _search
{
  "query": {
    "range" : {
      "route_length_miles" : {
        "gte" : 39
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The path to the target field. Note that this must be the full path, including any parent
objects (e.g. <code>object1.object2.field</code>).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Almost all components of the search request accept field aliases. In particular, aliases can be
used in queries, aggregations, and sort fields, as well as when requesting <code>docvalue_fields</code>,
<code>stored_fields</code>, suggestions, and highlights. Scripts also support aliases when accessing
field values. Please see the section on <a href="mapping-types.html#unsupported-apis">unsupported APIs</a> for exceptions.</p>
</div>
<div class="paragraph">
<p>In some parts of the search request and when requesting field capabilities, field wildcard patterns can be
provided. In these cases, the wildcard pattern will match field aliases in addition to concrete fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET trips/_field_caps?fields=route_*,transit_mode</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="alias-targets">Alias targets</h4>
<div class="paragraph">
<p>There are a few restrictions on the target of an alias:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The target must be a concrete field, and not an object or another field alias.</p>
</li>
<li>
<p>The target field must exist at the time the alias is created.</p>
</li>
<li>
<p>If nested objects are defined, a field alias must have the same nested scope as its target.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additionally, a field alias can only have one target. This means that it is not possible to use a
field alias to query over multiple target fields in a single clause.</p>
</div>
<div class="paragraph">
<p>An alias can be changed to refer to a new target through a mappings update. A known limitation is that
if any stored percolator queries contain the field alias, they will still refer to its original target.
More information can be found in the <a href="mapping-types.html#percolator">percolator documentation</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="unsupported-apis">Unsupported APIs</h4>
<div class="paragraph">
<p>Writes to field aliases are not supported: attempting to use an alias in an index or update request
will result in a failure. Likewise, aliases cannot be used as the target of <code>copy_to</code> or in multi-fields.</p>
</div>
<div class="paragraph">
<p>Because alias names are not present in the document source, aliases cannot be used when performing
source filtering. For example, the following request will return an empty result for <code>_source</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query" : {
    "match_all": {}
  },
  "_source": "route_length_miles"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Currently only the search and field capabilities APIs will accept and resolve field aliases.
Other APIs that accept field names, such as <a href="docs.html#docs-termvectors">term vectors</a>, cannot be used
with field aliases.</p>
</div>
<div class="paragraph">
<p>Finally, some queries, such as <code>terms</code>, <code>geo_shape</code>, and <code>more_like_this</code>, allow for fetching query
information from an indexed document. Because field aliases aren&#8217;t supported when fetching documents,
the part of the query that specifies the lookup path cannot refer to a field by its alias.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="array">Arrays</h3>
<div class="paragraph">
<p>In OpenSearch, there is no dedicated <code>array</code> data type.  Any field can contain
zero or more values by default, however, all values in the array must be of the
same data type. For instance:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>an array of strings: [ <code>"one"</code>, <code>"two"</code> ]</p>
</li>
<li>
<p>an array of integers: [ <code>1</code>, <code>2</code> ]</p>
</li>
<li>
<p>an array of arrays: [ <code>1</code>, [ <code>2</code>, <code>3</code> ]] which is the equivalent of [ <code>1</code>, <code>2</code>, <code>3</code> ]</p>
</li>
<li>
<p>an array of objects: [ <code>{ "name": "Mary", "age": 12 }</code>, <code>{ "name": "John", "age": 10 }</code>]</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Arrays of objects</div>
<div class="paragraph">
<p>Arrays of objects do not work as you would expect: you cannot query each
object independently of the other objects in the array.  If you need to be
able to do this then you should use the <a href="mapping-types.html#nested"><code>nested</code></a> data type instead
of the <a href="mapping-types.html#object"><code>object</code></a> data type.</p>
</div>
<div class="paragraph">
<p>This is explained in more detail in <a href="mapping-types.html#nested">Nested field type</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When adding a field dynamically, the first value in the array determines the
field <code>type</code>.  All subsequent values must be of the same data type or it must
at least be possible to <a href="mapping-params.html#coerce">coerce</a> subsequent values to the same
data type.</p>
</div>
<div class="paragraph">
<p>Arrays with a mixture of data types are <em>not</em> supported: [ <code>10</code>, <code>"some string"</code> ]</p>
</div>
<div class="paragraph">
<p>An array may contain <code>null</code> values, which are either replaced by the
configured <a href="mapping-params.html#null-value"><code>null_value</code></a> or skipped entirely.  An empty array
<code>[]</code> is treated as a missing field&#8201;&#8212;&#8201;a field with no values.</p>
</div>
<div class="paragraph">
<p>Nothing needs to be pre-configured in order to use arrays in documents, they
are supported out of the box:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001/_doc/1
{
  "message": "some arrays in this document...",
  "tags":  [ "opensearch", "wow" ], <b class="conum">(1)</b>
  "lists": [ <b class="conum">(2)</b>
    {
      "name": "prog_list",
      "description": "programming list"
    },
    {
      "name": "cool_list",
      "description": "cool stuff list"
    }
  ]
}

PUT my-index-000001/_doc/2 <b class="conum">(3)</b>
{
  "message": "no arrays in this document...",
  "tags":  "opensearch",
  "lists": {
    "name": "prog_list",
    "description": "programming list"
  }
}

GET my-index-000001/_search
{
  "query": {
    "match": {
      "tags": "opensearch" <b class="conum">(4)</b>
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>tags</code> field is dynamically added as a <code>string</code> field.</p>
</li>
<li>
<p>The <code>lists</code> field is dynamically added as an <code>object</code> field.</p>
</li>
<li>
<p>The second document contains no arrays, but can be indexed into the same fields.</p>
</li>
<li>
<p>The query looks for <code>opensearch</code> in the <code>tags</code> field, and matches both documents.</p>
</li>
</ol>
</div>
<div id="multi-value-fields-inverted-index" class="sidebarblock">
<div class="content">
<div class="title">Multi-value fields and the inverted index</div>
<div class="paragraph">
<p>The fact that all field types support multi-value fields out of the box is a
consequence of the origins of Lucene.  Lucene was designed to be a full text
search engine.  In order to be able to search for individual words within a
big block of text, Lucene tokenizes the text into individual terms, and
adds each term to the inverted index separately.</p>
</div>
<div class="paragraph">
<p>This means that even a simple text field must be able to support multiple
values by default.  When other data types were added, such as numbers and
dates, they used the same data structure as strings, and so got multi-values
for free.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="binary">Binary field type</h3>
<titleabbrev>Binary</titleabbrev>
<div class="paragraph">
<p>The <code>binary</code> type accepts a binary value as a
<a href="https://en.wikipedia.org/wiki/Base64">Base64</a> encoded string. The field is not
stored by default and is not searchable:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001
{
  "mappings": {
    "properties": {
      "name": {
        "type": "text"
      },
      "blob": {
        "type": "binary"
      }
    }
  }
}

PUT my-index-000001/_doc/1
{
  "name": "Some binary blob",
  "blob": "U29tZSBiaW5hcnkgYmxvYg==" <b class="conum">(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The Base64 encoded binary value must not have embedded newlines <code>\n</code>.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="binary-params">Parameters for <code>binary</code> fields</h4>
<div class="paragraph">
<p>The following parameters are accepted by <code>binary</code> fields:</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#doc-values"><code>doc_values</code></a>
</td>
<td class="hdlist2">
<p>Should the field be stored on disk in a column-stride fashion, so that it
can later be used for sorting, aggregations, or scripting? Accepts <code>true</code>
or <code>false</code> (default).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-store"><code>store</code></a>
</td>
<td class="hdlist2">
<p>Whether the field value should be stored and retrievable separately from
the <a href="mapping-fields.html#mapping-source-field"><code>_source</code></a> field. Accepts <code>true</code> or <code>false</code>
(default).</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="boolean">Boolean field type</h3>
<titleabbrev>Boolean</titleabbrev>
<div class="paragraph">
<p>Boolean fields accept JSON <code>true</code> and <code>false</code> values, but can also accept
strings which are interpreted as either true or false:</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
False values
</td>
<td class="hdlist2">
<p><code>false</code>, <code>"false"</code>, <code>""</code> (empty string)</p>
</td>
</tr>
<tr>
<td class="hdlist1">
True values
</td>
<td class="hdlist2">
<p><code>true</code>, <code>"true"</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001
{
  "mappings": {
    "properties": {
      "is_published": {
        "type": "boolean"
      }
    }
  }
}

POST my-index-000001/_doc/1
{
  "is_published": "true" <b class="conum">(1)</b>
}

GET my-index-000001/_search
{
  "query": {
    "term": {
      "is_published": true <b class="conum">(2)</b>
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Indexing a document with <code>"true"</code>, which is interpreted as <code>true</code>.</p>
</li>
<li>
<p>Searching for documents with a JSON <code>true</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Aggregations like the <a href="search-aggregations-bucket.html#search-aggregations-bucket-terms-aggregation"><code>terms</code>
aggregation</a>  use <code>1</code> and <code>0</code> for the <code>key</code>, and the strings <code>"true"</code> and
<code>"false"</code> for the <code>key_as_string</code>. Boolean fields  when used in scripts,
return <code>1</code> and <code>0</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST my-index-000001/_doc/1
{
  "is_published": true
}

POST my-index-000001/_doc/2
{
  "is_published": false
}

GET my-index-000001/_search
{
  "aggs": {
    "publish_state": {
      "terms": {
        "field": "is_published"
      }
    }
  },
  "script_fields": {
    "is_published": {
      "script": {
        "lang": "painless",
        "source": "doc['is_published'].value"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="boolean-params">Parameters for <code>boolean</code> fields</h4>
<div class="paragraph">
<p>The following parameters are accepted by <code>boolean</code> fields:</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-boost"><code>boost</code></a>
</td>
<td class="hdlist2">
<p>Mapping field-level query time boosting. Accepts a floating point number, defaults
to <code>1.0</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#doc-values"><code>doc_values</code></a>
</td>
<td class="hdlist2">
<p>Should the field be stored on disk in a column-stride fashion, so that it
can later be used for sorting, aggregations, or scripting? Accepts <code>true</code>
(default) or <code>false</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-index"><code>index</code></a>
</td>
<td class="hdlist2">
<p>Should the field be searchable? Accepts <code>true</code> (default) and <code>false</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#null-value"><code>null_value</code></a>
</td>
<td class="hdlist2">
<p>Accepts any of the true or false values listed above. The value is
substituted for any explicit <code>null</code> values.  Defaults to <code>null</code>, which
means the field is treated as missing.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-store"><code>store</code></a>
</td>
<td class="hdlist2">
<p>Whether the field value should be stored and retrievable separately from
the <a href="mapping-fields.html#mapping-source-field"><code>_source</code></a> field. Accepts <code>true</code> or <code>false</code>
(default).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-field-meta"><code>meta</code></a>
</td>
<td class="hdlist2">
<p>Metadata about the field.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="date">Date field type</h3>
<titleabbrev>Date</titleabbrev>
<div class="paragraph">
<p>JSON doesn&#8217;t have a date data type, so dates in OpenSearch can either be:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>strings containing formatted dates, e.g. <code>"2015-01-01"</code> or <code>"2015/01/01 12:10:30"</code>.</p>
</li>
<li>
<p>a long number representing <em>milliseconds-since-the-epoch</em>.</p>
</li>
<li>
<p>an integer representing <em>seconds-since-the-epoch</em>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Values for <em>milliseconds-since-the-epoch</em> and <em>seconds-since-the-epoch</em>
must be non-negative. Use a formatted date to represent dates before 1970.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Internally, dates are converted to UTC (if the time-zone is specified) and
stored as a long number representing milliseconds-since-the-epoch.</p>
</div>
<div class="paragraph">
<p>Queries on dates are internally converted to range queries on this long
representation, and the result of aggregations and stored fields is converted
back to a string depending on the date format that is associated with the field.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Dates will always be rendered as strings, even if they were initially
supplied as a long in the JSON document.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Date formats can be customised, but if no <code>format</code> is specified then it uses
the default:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"strict_date_optional_time||epoch_millis"</pre>
</div>
</div>
<div class="paragraph">
<p>This means that it will accept dates with optional timestamps, which conform
to the formats supported by <a href="mapping-params.html#strict-date-time"><code>strict_date_optional_time</code></a>
or milliseconds-since-the-epoch.</p>
</div>
<div class="paragraph">
<p>For instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001
{
  "mappings": {
    "properties": {
      "date": {
        "type": "date" <b class="conum">(1)</b>
      }
    }
  }
}

PUT my-index-000001/_doc/1
{ "date": "2015-01-01" } <b class="conum">(2)</b>

PUT my-index-000001/_doc/2
{ "date": "2015-01-01T12:10:30Z" } <b class="conum">(3)</b>

PUT my-index-000001/_doc/3
{ "date": 1420070400001 } <b class="conum">(4)</b>

GET my-index-000001/_search
{
  "sort": { "date": "asc"} <b class="conum">(5)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>date</code> field uses the default <code>format</code>.</p>
</li>
<li>
<p>This document uses a plain date.</p>
</li>
<li>
<p>This document includes a time.</p>
</li>
<li>
<p>This document uses milliseconds-since-the-epoch.</p>
</li>
<li>
<p>Note that the <code>sort</code> values that are returned are all in milliseconds-since-the-epoch.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="multiple-date-formats">Multiple date formats</h4>
<div class="paragraph">
<p>Multiple formats can be specified by separating them with <code>||</code> as a separator.
Each format will be tried in turn until a matching format is found.  The first
format will be used to convert the <em>milliseconds-since-the-epoch</em> value back
into a string.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001
{
  "mappings": {
    "properties": {
      "date": {
        "type":   "date",
        "format": "yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis"
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="date-params">Parameters for <code>date</code> fields</h4>
<div class="paragraph">
<p>The following parameters are accepted by <code>date</code> fields:</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-boost"><code>boost</code></a>
</td>
<td class="hdlist2">
<p>Mapping field-level query time boosting. Accepts a floating point number, defaults
to <code>1.0</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#doc-values"><code>doc_values</code></a>
</td>
<td class="hdlist2">
<p>Should the field be stored on disk in a column-stride fashion, so that it
can later be used for sorting, aggregations, or scripting? Accepts <code>true</code>
(default) or <code>false</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-date-format"><code>format</code></a>
</td>
<td class="hdlist2">
<p>The date format(s) that can be parsed.  Defaults to
<code>strict_date_optional_time||epoch_millis</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>locale</code>
</td>
<td class="hdlist2">
<p>The locale to use when parsing dates since months do not have the same names
and/or abbreviations in all languages. The default is the
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html#ROOT"><code>ROOT</code> locale</a>,</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#ignore-malformed"><code>ignore_malformed</code></a>
</td>
<td class="hdlist2">
<p>If <code>true</code>, malformed numbers are ignored. If <code>false</code> (default), malformed
numbers throw an exception and reject the whole document.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-index"><code>index</code></a>
</td>
<td class="hdlist2">
<p>Should the field be searchable? Accepts <code>true</code> (default) and <code>false</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#null-value"><code>null_value</code></a>
</td>
<td class="hdlist2">
<p>Accepts a date value in one of the configured format's as the field
which is substituted for any explicit <code>null</code> values.  Defaults to <code>null</code>,
which means the field is treated as missing.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-store"><code>store</code></a>
</td>
<td class="hdlist2">
<p>Whether the field value should be stored and retrievable separately from
the <a href="mapping-fields.html#mapping-source-field"><code>_source</code></a> field. Accepts <code>true</code> or <code>false</code>
(default).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-field-meta"><code>meta</code></a>
</td>
<td class="hdlist2">
<p>Metadata about the field.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="date_nanos">Date nanoseconds field type</h3>
<titleabbrev>Date nanoseconds</titleabbrev>
<div class="paragraph">
<p>This data type is an addition to the <code>date</code> data type. However there is an
important distinction between the two. The existing <code>date</code> data type stores
dates in millisecond resolution. The <code>date_nanos</code> data type stores dates
in nanosecond resolution, which limits its range of dates from roughly
1970 to 2262, as dates are still stored as a long representing nanoseconds
since the epoch.</p>
</div>
<div class="paragraph">
<p>Queries on nanoseconds are internally converted to range queries on this long
representation, and the result of aggregations and stored fields is converted
back to a string depending on the date format that is associated with the field.</p>
</div>
<div class="paragraph">
<p>Date formats can be customised, but if no <code>format</code> is specified then it uses
the default:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"strict_date_optional_time||epoch_millis"</pre>
</div>
</div>
<div class="paragraph">
<p>This means that it will accept dates with optional timestamps, which conform
to the formats supported by
<a href="mapping-params.html#strict-date-time"><code>strict_date_optional_time</code></a> including up to nine second
fractionals or milliseconds-since-the-epoch (thus losing precision on the
nano second part). Using <a href="mapping-params.html#strict-date-time"><code>strict_date_optional_time</code></a> will
format the result up to only three second fractionals. To
print and parse up to nine digits of resolution, use <a href="mapping-params.html#strict-date-time-nanos"><code>strict_date_optional_time_nanos</code></a>.</p>
</div>
<div class="paragraph">
<p>For instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001?include_type_name=true
{
  "mappings": {
    "_doc": {
      "properties": {
        "date": {
          "type": "date_nanos" <b class="conum">(1)</b>
        }
      }
    }
  }
}

PUT my-index-000001/_doc/1
{ "date": "2015-01-01" } <b class="conum">(2)</b>

PUT my-index-000001/_doc/2
{ "date": "2015-01-01T12:10:30.123456789Z" } <b class="conum">(3)</b>

PUT my-index-000001/_doc/3
{ "date": 1420070400 } <b class="conum">(4)</b>

GET my-index-000001/_search
{
  "sort": { "date": "asc"} <b class="conum">(5)</b>
}

GET my-index-000001/_search
{
  "script_fields" : {
    "my_field" : {
      "script" : {
        "lang" : "painless",
        "source" : "doc['date'].value.nano" <b class="conum">(6)</b>
      }
    }
  }
}

GET my-index-000001/_search
{
  "docvalue_fields" : [
    {
      "field" : "date",
      "format": "strict_date_time" <b class="conum">(7)</b>
    }
  ]
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>date</code> field uses the default <code>format</code>.</p>
</li>
<li>
<p>This document uses a plain date.</p>
</li>
<li>
<p>This document includes a time.</p>
</li>
<li>
<p>This document uses milliseconds-since-the-epoch.</p>
</li>
<li>
<p>Note that the <code>sort</code> values that are returned are all in
nanoseconds-since-the-epoch.</p>
</li>
<li>
<p>Access the nanosecond part of the date in a script</p>
</li>
<li>
<p>Use doc value fields, which can be formatted in nanosecond
resolution</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You can also specify multiple date formats separated by <code>||</code>. The
same mapping parameters than with the <code>date</code> field can be used.</p>
</div>
<div class="sect3">
<h4 id="date-nanos-limitations">Limitations</h4>
<div class="paragraph">
<p>Aggregations are still on millisecond resolution, even when using a <code>date_nanos</code>
field.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="geo-point">Geo-point field type</h3>
<titleabbrev>Geo-point</titleabbrev>
<div class="paragraph">
<p>Fields of type <code>geo_point</code> accept latitude-longitude pairs, which can be used:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>to find geo-points within a <a href="geo-queries.html#query-dsl-geo-bounding-box-query">bounding box</a>,
within a certain <a href="geo-queries.html#query-dsl-geo-distance-query">distance</a> of a central point,
or within a <a href="geo-queries.html#query-dsl-geo-polygon-query">polygon</a> or within a <a href="geo-queries.html#query-dsl-geo-shape-query">geo_shape query</a>.</p>
</li>
<li>
<p>to aggregate documents <a href="search-aggregations-bucket.html#search-aggregations-bucket-geohashgrid-aggregation">geographically</a>
or by <a href="search-aggregations-bucket.html#search-aggregations-bucket-geodistance-aggregation">distance</a> from a central point.</p>
</li>
<li>
<p>to integrate distance into a document&#8217;s <a href="compound-queries.html#query-dsl-function-score-query">relevance score</a>.</p>
</li>
<li>
<p>to <a href="sort-search-results.html#geo-sorting">sort</a> documents by distance.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are five ways that a geo-point may be specified, as demonstrated below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001
{
  "mappings": {
    "properties": {
      "location": {
        "type": "geo_point"
      }
    }
  }
}

PUT my-index-000001/_doc/1
{
  "text": "Geo-point as an object",
  "location": { <b class="conum">(1)</b>
    "lat": 41.12,
    "lon": -71.34
  }
}

PUT my-index-000001/_doc/2
{
  "text": "Geo-point as a string",
  "location": "41.12,-71.34" <b class="conum">(2)</b>
}

PUT my-index-000001/_doc/3
{
  "text": "Geo-point as a geohash",
  "location": "drm3btev3e86" <b class="conum">(3)</b>
}

PUT my-index-000001/_doc/4
{
  "text": "Geo-point as an array",
  "location": [ -71.34, 41.12 ] <b class="conum">(4)</b>
}

PUT my-index-000001/_doc/5
{
  "text": "Geo-point as a WKT POINT primitive",
  "location" : "POINT (-71.34 41.12)" <b class="conum">(5)</b>
}

GET my-index-000001/_search
{
  "query": {
    "geo_bounding_box": { <b class="conum">(6)</b>
      "location": {
        "top_left": {
          "lat": 42,
          "lon": -72
        },
        "bottom_right": {
          "lat": 40,
          "lon": -74
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Geo-point expressed as an object, with <code>lat</code> and <code>lon</code> keys.</p>
</li>
<li>
<p>Geo-point expressed as a string with the format: <code>"lat,lon"</code>.</p>
</li>
<li>
<p>Geo-point expressed as a geohash.</p>
</li>
<li>
<p>Geo-point expressed as an array with the format: [ <code>lon</code>, <code>lat</code>]</p>
</li>
<li>
<p>Geo-point expressed as a <a href="https://docs.opengeospatial.org/is/12-063r5/12-063r5.html">Well-Known Text</a>
POINT with the format: <code>"POINT(lon lat)"</code></p>
</li>
<li>
<p>A geo-bounding box query which finds all geo-points that fall inside the box.</p>
</li>
</ol>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="title">Geo-points expressed as an array or string</div>
<div class="paragraph">
<p>Please note that string geo-points are ordered as <code>lat,lon</code>, while array
geo-points are ordered as the reverse: <code>lon,lat</code>.</p>
</div>
<div class="paragraph">
<p>Originally, <code>lat,lon</code> was used for both array and string, but the array
format was changed early on to conform to the format used by GeoJSON.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
A point can be expressed as a <a href="https://en.wikipedia.org/wiki/Geohash">geohash</a>.
Geohashes are <a href="https://en.wikipedia.org/wiki/Base32">base32</a> encoded strings of
the bits of the latitude and longitude interleaved. Each character in a geohash
adds additional 5 bits to the precision. So the longer the hash, the more
precise it is. For the indexing purposed geohashs are translated into
latitude-longitude pairs. During this process only first 12 characters are
used, so specifying more than 12 characters in a geohash doesn&#8217;t increase the
precision. The 12 characters provide 60 bits, which should reduce a possible
error to less than 2cm.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="geo-point-params">Parameters for <code>geo_point</code> fields</h4>
<div class="paragraph">
<p>The following parameters are accepted by <code>geo_point</code> fields:</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#ignore-malformed"><code>ignore_malformed</code></a>
</td>
<td class="hdlist2">
<p>If <code>true</code>, malformed geo-points are ignored. If <code>false</code> (default),
malformed geo-points throw an exception and reject the whole document.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>ignore_z_value</code>
</td>
<td class="hdlist2">
<p>If <code>true</code> (default) three dimension points will be accepted (stored in source)
but only latitude and longitude values will be indexed; the third dimension is
ignored. If <code>false</code>, geo-points containing any more than latitude and longitude
(two dimensions) values throw an exception and reject the whole document.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#null-value"><code>null_value</code></a>
</td>
<td class="hdlist2">
<p>Accepts an geopoint value which is substituted for any explicit <code>null</code> values.
Defaults to <code>null</code>, which means the field is treated as missing.</p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_using_geo_points_in_scripts">Using geo-points in scripts</h4>
<div class="paragraph">
<p>When accessing the value of a geo-point in a script, the value is returned as
a <code>GeoPoint</code> object, which allows access to the <code>.lat</code> and <code>.lon</code> values
respectively:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-painless" data-lang="painless">def geopoint = doc['location'].value;
def lat      = geopoint.lat;
def lon      = geopoint.lon;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For performance reasons, it is better to access the lat/lon values directly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-painless" data-lang="painless">def lat      = doc['location'].lat;
def lon      = doc['location'].lon;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="geo-shape">Geo-shape field type</h3>
<titleabbrev>Geo-shape</titleabbrev>
<div class="paragraph">
<p>The <code>geo_shape</code> data type facilitates the indexing of and searching
with arbitrary geo shapes such as rectangles and polygons. It should be
used when either the data being indexed or the queries being executed
contain shapes other than just points.</p>
</div>
<div class="paragraph">
<p>You can query documents using this type using
<a href="geo-queries.html#query-dsl-geo-shape-query">geo_shape Query</a>.</p>
</div>
<h4 id="geo-shape-mapping-options" class="discrete">Mapping Options</h4>
<div class="paragraph">
<p>The geo_shape mapping maps geo_json geometry objects to the geo_shape
type. To enable it, users must explicitly map fields to the geo_shape
type.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Option</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Default</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tree</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Deprecated. Name of the PrefixTree
implementation to be used: <code>geohash</code> for GeohashPrefixTree and <code>quadtree</code>
for QuadPrefixTree. Note: This parameter is only relevant for <code>term</code> and
<code>recursive</code> strategies.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>quadtree</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>precision</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Deprecated. This parameter may
be used instead of <code>tree_levels</code> to set an appropriate value for the
<code>tree_levels</code> parameter. The value specifies the desired precision and
OpenSearch will calculate the best tree_levels value to honor this
precision. The value should be a number followed by an optional distance
unit. Valid distance units include: <code>in</code>, <code>inch</code>, <code>yd</code>, <code>yard</code>, <code>mi</code>,
<code>miles</code>, <code>km</code>, <code>kilometers</code>, <code>m</code>,<code>meters</code>, <code>cm</code>,<code>centimeters</code>, <code>mm</code>,
<code>millimeters</code>. Note: This parameter is only relevant for <code>term</code> and
<code>recursive</code> strategies.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>50m</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tree_levels</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Deprecated. Maximum number
of layers to be used by the PrefixTree. This can be used to control the
precision of shape representations andtherefore how many terms are
indexed. Defaults to the default value of the chosen PrefixTree
implementation. Since this parameter requires a certain level of
understanding of the underlying implementation, users may use the
<code>precision</code> parameter instead. However, OpenSearch only uses the
tree_levels parameter internally and this is what is returned via the
mapping API even if you use the precision parameter. Note: This parameter
is only relevant for <code>term</code> and <code>recursive</code> strategies.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">various</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>strategy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Deprecated. The strategy
parameter defines the approach for how to represent shapes at indexing
and search time. It also influences the capabilities available so it
is recommended to let OpenSearch set this parameter automatically.
There are two strategies available: <code>recursive</code>, and <code>term</code>.
Recursive and Term strategies are deprecated and will be removed in a
future version. While they are still available, the Term strategy
supports point types only (the <code>points_only</code> parameter will be
automatically set to true) while Recursive strategy supports all
shape types. (IMPORTANT: see <a href="mapping-types.html#prefix-trees">Prefix trees</a> for more
detailed information about these strategies)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>recursive</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>distance_error_pct</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Deprecated. Used as a
hint to the PrefixTree about how precise it should be. Defaults to 0.025 (2.5%)
with 0.5 as the maximum supported value. PERFORMANCE NOTE: This value will
default to 0 if a <code>precision</code> or <code>tree_level</code> definition is explicitly defined.
This guarantees spatial precision at the level defined in the mapping. This can
lead to significant memory usage for high resolution shapes with low error
(e.g., large shapes at 1m with &lt; 0.001 error). To improve indexing performance
(at the cost of query accuracy) explicitly define <code>tree_level</code> or <code>precision</code>
along with a reasonable <code>distance_error_pct</code>, noting that large shapes will have
greater false positives. Note: This parameter is only relevant for <code>term</code> and
<code>recursive</code> strategies.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0.025</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>orientation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Optional. Vertex order for the shape&#8217;s coordinates list.</p>
<p class="tableblock">This parameter sets and returns only a <code>RIGHT</code> (counterclockwise) or <code>LEFT</code>
(clockwise) value. However, you can specify either value in multiple ways.</p>
<p class="tableblock">To set <code>RIGHT</code>, use one of the following arguments or its uppercase
variant:</p>
<p class="tableblock">* <code>right</code><br>
* <code>counterclockwise</code><br>
* <code>ccw</code></p>
<p class="tableblock">To set <code>LEFT</code>, use one of the following arguments or its uppercase
variant:</p>
<p class="tableblock">* <code>left</code><br>
* <code>clockwise</code><br>
* <code>cw</code></p>
<p class="tableblock">Defaults to <code>RIGHT</code> to comply with <a href="https://www.ogc.org/docs/is">OGC standards</a>.
OGC standards define outer ring vertices in counterclockwise order with inner
ring (hole) vertices in clockwise order.</p>
<p class="tableblock">Individual GeoJSON or WKT documents can override this parameter.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RIGHT</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>points_only</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Deprecated. Setting this option to
<code>true</code> (defaults to <code>false</code>) configures the <code>geo_shape</code> field type for point
shapes only (NOTE: Multi-Points are not yet supported). This optimizes index and
search performance for the <code>geohash</code> and <code>quadtree</code> when it is known that only points
will be indexed. At present geo_shape queries can not be executed on <code>geo_point</code>
field types. This option bridges the gap by improving point performance on a
<code>geo_shape</code> field so that <code>geo_shape</code> queries are optimal on a point only field.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ignore_malformed</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If true, malformed GeoJSON or WKT shapes are ignored. If
false (default), malformed GeoJSON and WKT shapes throw an exception and reject the
entire document.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ignore_z_value</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If <code>true</code> (default) three dimension points will be accepted (stored in source)
but only latitude and longitude values will be indexed; the third dimension is ignored. If <code>false</code>,
geo-points containing any more than latitude and longitude (two dimensions) values throw an exception
and reject the whole document.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>coerce</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If <code>true</code> unclosed linear rings in polygons will be automatically closed.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
</tbody>
</table>
<h4 id="geoshape-indexing-approach" class="discrete">Indexing approach</h4>
<div class="paragraph">
<p>GeoShape types are indexed by decomposing the shape into a triangular mesh and
indexing each triangle as a 7 dimension point in a BKD tree. This provides
near perfect spatial resolution (down to 1e-7 decimal degree precision) since all
spatial relations are computed using an encoded vector representation of the
original shape instead of a raster-grid representation as used by the
<a href="mapping-types.html#prefix-trees">Prefix trees</a> indexing approach. Performance of the tessellator primarily
depends on the number of vertices that define the polygon/multi-polygon. While
this is the default indexing technique prefix trees can still be used by setting
the <code>tree</code> or <code>strategy</code> parameters according to the appropriate
<a href="mapping-types.html#geo-shape-mapping-options">Mapping Options</a>. Note that these parameters are now deprecated
and will be removed in a future version.</p>
</div>
<div class="paragraph">
<p><strong>IMPORTANT NOTES</strong></p>
</div>
<div class="paragraph">
<p><code>CONTAINS</code> relation query - when using the new default vector indexing strategy, <code>geo_shape</code>
queries with <code>relation</code> defined as <code>contains</code> are supported for indices created with
ElasticSearch 7.5.0 or higher.</p>
</div>
<h4 id="prefix-trees" class="discrete">Prefix trees</h4>
<div class="paragraph">
<p>Deprecated. To efficiently represent shapes in
an inverted index, Shapes are converted into a series of hashes representing
grid squares (commonly referred to as "rasters") using implementations of a
PrefixTree. The tree notion comes from the fact that the PrefixTree uses multiple
grid layers, each with an increasing level of precision to represent the Earth.
This can be thought of as increasing the level of detail of a map or image at higher
zoom levels. Since this approach causes precision issues with indexed shape, it has
been deprecated in favor of a vector indexing approach that indexes the shapes as a
triangular mesh (see <a href="mapping-types.html#geoshape-indexing-approach">Indexing approach</a>).</p>
</div>
<div class="paragraph">
<p>Multiple PrefixTree implementations are provided:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>GeohashPrefixTree - Uses
<a href="https://en.wikipedia.org/wiki/Geohash">geohashes</a> for grid squares.
Geohashes are base32 encoded strings of the bits of the latitude and
longitude interleaved. So the longer the hash, the more precise it is.
Each character added to the geohash represents another tree level and
adds 5 bits of precision to the geohash. A geohash represents a
rectangular area and has 32 sub rectangles. The maximum number of levels
in OpenSearch is 24; the default is 9.</p>
</li>
<li>
<p>QuadPrefixTree - Uses a
<a href="https://en.wikipedia.org/wiki/Quadtree">quadtree</a> for grid squares.
Similar to geohash, quad trees interleave the bits of the latitude and
longitude the resulting hash is a bit set. A tree level in a quad tree
represents 2 bits in this bit set, one for each coordinate. The maximum
number of levels for the quad trees in OpenSearch is 29; the default is 21.</p>
</li>
</ul>
</div>
<h5 id="spatial-strategy" class="discrete">Spatial strategies</h5>
<div class="paragraph">
<p>Deprecated. The indexing implementation
selected relies on a  SpatialStrategy for choosing how to decompose the shapes
(either as grid  squares or a tessellated triangular mesh). Each strategy
answers the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>What type of Shapes can be indexed?</p>
</li>
<li>
<p>What types of Query Operations and Shapes can be used?</p>
</li>
<li>
<p>Does it support more than one Shape per field?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following Strategy implementations (with corresponding capabilities)
are provided:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Strategy</th>
<th class="tableblock halign-left valign-top">Supported Shapes</th>
<th class="tableblock halign-left valign-top">Supported Queries</th>
<th class="tableblock halign-left valign-top">Multiple Shapes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>recursive</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="mapping-types.html#input-structure">All</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>INTERSECTS</code>, <code>DISJOINT</code>, <code>WITHIN</code>, <code>CONTAINS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>term</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="mapping-types.html#geo-point-type">Points</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>INTERSECTS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
</tbody>
</table>
<h5 id="_accuracy" class="discrete">Accuracy</h5>
<div class="paragraph">
<p><code>Recursive</code> and <code>Term</code> strategies do not provide 100% accuracy and depending on
how they are configured it may return some false positives for <code>INTERSECTS</code>,
<code>WITHIN</code> and <code>CONTAINS</code> queries, and some false negatives for <code>DISJOINT</code> queries.
To mitigate this, it is important to select an appropriate value for the tree_levels
parameter and to adjust expectations accordingly. For example, a point may be near
the border of a particular grid cell and may thus not match a query that only matches
the cell right next to it&#8201;&#8212;&#8201;even though the shape is very close to the point.</p>
</div>
<h5 id="_example" class="discrete">Example</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT /example
{
  "mappings": {
    "properties": {
      "location": {
        "type": "geo_shape"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This mapping definition maps the location field to the geo_shape
type using the default vector implementation. It provides
approximately 1e-7 decimal degree precision.</p>
</div>
<h5 id="_performance_considerations_with_prefix_trees" class="discrete">Performance considerations with Prefix Trees</h5>
<div class="paragraph">
<p>Deprecated. With prefix trees,
OpenSearch uses the paths in the tree as terms in the inverted index
and in queries. The higher the level (and thus the precision), the more
terms are generated. Of course, calculating the terms, keeping them in
memory, and storing them on disk all have a price. Especially with higher
tree levels, indices can become extremely large even with a modest amount
of data. Additionally, the size of the features also matters. Big, complex
polygons can take up a lot of space at higher tree levels. Which setting
is right depends on the use case. Generally one trades off accuracy against
index size and query performance.</p>
</div>
<div class="paragraph">
<p>The defaults in OpenSearch for both implementations are a compromise
between index size and a reasonable level of precision of 50m at the
equator. This allows for indexing tens of millions of shapes without
overly bloating the resulting index too much relative to the input size.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Geo-shape queries on geo-shapes implemented with PrefixTrees will not be executed if
<a href="query-dsl.html#query-dsl-allow-expensive-queries"><code>search.allow_expensive_queries</code></a> is set to false.
</td>
</tr>
</table>
</div>
<h4 id="input-structure" class="discrete">Input Structure</h4>
<div class="paragraph">
<p>Shapes can be represented using either the <a href="http://geojson.org">GeoJSON</a>
or <a href="https://docs.opengeospatial.org/is/12-063r5/12-063r5.html">Well-Known Text</a>
(WKT) format. The following table provides a mapping of GeoJSON and WKT
to OpenSearch types:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">GeoJSON Type</th>
<th class="tableblock halign-left valign-top">WKT Type</th>
<th class="tableblock halign-left valign-top">OpenSearch Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Point</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>POINT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>point</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A single geographic coordinate. Note: OpenSearch uses WGS-84 coordinates only.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LineString</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LINESTRING</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>linestring</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An arbitrary line given two or more points.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Polygon</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>POLYGON</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>polygon</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A <em>closed</em> polygon whose first and last point
must match, thus requiring <code>n + 1</code> vertices to create an <code>n</code>-sided
polygon and a minimum of <code>4</code> vertices.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MultiPoint</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MULTIPOINT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>multipoint</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An array of unconnected, but likely related
points.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MultiLineString</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MULTILINESTRING</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>multilinestring</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An array of separate linestrings.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MultiPolygon</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MULTIPOLYGON</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>multipolygon</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An array of separate polygons.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GeometryCollection</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GEOMETRYCOLLECTION</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>geometrycollection</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A GeoJSON shape similar to the
<code>multi*</code> shapes except that multiple types can coexist (e.g., a Point
and a LineString).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>N/A</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BBOX</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>envelope</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A bounding rectangle, or envelope, specified by
specifying only the top left and bottom right points.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>N/A</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>N/A</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>circle</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A circle specified by a center point and radius with
units, which default to <code>METERS</code>.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>For all types, both the inner <code>type</code> and <code>coordinates</code> fields are
required.</p>
</div>
<div class="paragraph">
<p>In GeoJSON and WKT, and therefore OpenSearch, the correct <strong>coordinate
order is longitude, latitude (X, Y)</strong> within coordinate arrays. This
differs from many Geospatial APIs (e.g., Google Maps) that generally
use the colloquial latitude, longitude (Y, X).</p>
</div>
</td>
</tr>
</table>
</div>
<h5 id="geo-point-type" class="discrete"><a href="http://geojson.org/geojson-spec.html#id2">Point</a></h5>
<div class="paragraph">
<p>A point is a single geographic coordinate, such as the location of a
building or the current position given by a smartphone&#8217;s Geolocation
API. The following is an example of a point in GeoJSON.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /example/_doc
{
  "location" : {
    "type" : "point",
    "coordinates" : [-77.03653, 38.897676]
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example of a point in WKT:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /example/_doc
{
  "location" : "POINT (-77.03653 38.897676)"
}</code></pre>
</div>
</div>
<h5 id="geo-linestring" class="discrete"><a href="http://geojson.org/geojson-spec.html#id3">LineString</a></h5>
<div class="paragraph">
<p>A <code>linestring</code> defined by an array of two or more positions. By
specifying only two points, the <code>linestring</code> will represent a straight
line.  Specifying more than two points creates an arbitrary path. The
following is an example of a LineString in GeoJSON.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /example/_doc
{
  "location" : {
    "type" : "linestring",
    "coordinates" : [[-77.03653, 38.897676], [-77.009051, 38.889939]]
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example of a LineString in WKT:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /example/_doc
{
  "location" : "LINESTRING (-77.03653 38.897676, -77.009051 38.889939)"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above <code>linestring</code> would draw a straight line starting at the White
House to the US Capitol Building.</p>
</div>
<h5 id="geo-polygon" class="discrete"><a href="http://geojson.org/geojson-spec.html#id4">Polygon</a></h5>
<div class="paragraph">
<p>A polygon is defined by a list of a list of points. The first and last
points in each (outer) list must be the same (the polygon must be
closed). The following is an example of a Polygon in GeoJSON.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /example/_doc
{
  "location" : {
    "type" : "polygon",
    "coordinates" : [
      [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0] ]
    ]
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example of a Polygon in WKT:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /example/_doc
{
  "location" : "POLYGON ((100.0 0.0, 101.0 0.0, 101.0 1.0, 100.0 1.0, 100.0 0.0))"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first array represents the outer boundary of the polygon, the other
arrays represent the interior shapes ("holes"). The following is a GeoJSON example
of a polygon with a hole:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /example/_doc
{
  "location" : {
    "type" : "polygon",
    "coordinates" : [
      [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0] ],
      [ [100.2, 0.2], [100.8, 0.2], [100.8, 0.8], [100.2, 0.8], [100.2, 0.2] ]
    ]
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example of a Polygon with a hole in WKT:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /example/_doc
{
  "location" : "POLYGON ((100.0 0.0, 101.0 0.0, 101.0 1.0, 100.0 1.0, 100.0 0.0), (100.2 0.2, 100.8 0.2, 100.8 0.8, 100.2 0.8, 100.2 0.2))"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>IMPORTANT NOTE:</strong> WKT does not enforce a specific order for vertices thus
ambiguous polygons around the dateline and poles are possible.
<a href="https://tools.ietf.org/html/rfc7946#section-3.1.6">GeoJSON</a> mandates that the
outer polygon must be counterclockwise and interior shapes must be clockwise,
which agrees with the Open Geospatial Consortium (OGC)
<a href="https://www.opengeospatial.org/standards/sfa">Simple Feature Access</a>
specification for vertex ordering.</p>
</div>
<div class="paragraph">
<p>OpenSearch accepts both clockwise and counterclockwise polygons if they
appear not to cross the dateline (i.e. they cross less than 180 of longitude),
but for polygons that do cross the dateline (or for other polygons wider than
180) OpenSearch requires the vertex ordering to comply with the OGC and
GeoJSON specifications. Otherwise, an unintended polygon may be created and
unexpected query/filter results will be returned.</p>
</div>
<div class="paragraph">
<p>The following provides an example of an ambiguous polygon.  OpenSearch will
apply the GeoJSON standard to eliminate ambiguity resulting in a polygon that
crosses the dateline.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /example/_doc
{
  "location" : {
    "type" : "polygon",
    "coordinates" : [
      [ [-177.0, 10.0], [176.0, 15.0], [172.0, 0.0], [176.0, -15.0], [-177.0, -10.0], [-177.0, 10.0] ],
      [ [178.2, 8.2], [-178.8, 8.2], [-180.8, -8.8], [178.2, 8.8] ]
    ]
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An <code>orientation</code> parameter can be defined when setting the geo_shape mapping (see <a href="mapping-types.html#geo-shape-mapping-options">Mapping Options</a>). This will define vertex
order for the coordinate list on the mapped geo_shape field. It can also be overridden on each document.  The following is an example for
overriding the orientation on a document:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /example/_doc
{
  "location" : {
    "type" : "polygon",
    "orientation" : "clockwise",
    "coordinates" : [
      [ [100.0, 0.0], [100.0, 1.0], [101.0, 1.0], [101.0, 0.0], [100.0, 0.0] ]
    ]
  }
}</code></pre>
</div>
</div>
<h5 id="geo-multipoint" class="discrete"><a href="http://geojson.org/geojson-spec.html#id5">MultiPoint</a></h5>
<div class="paragraph">
<p>The following is an example of a list of geojson points:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /example/_doc
{
  "location" : {
    "type" : "multipoint",
    "coordinates" : [
      [102.0, 2.0], [103.0, 2.0]
    ]
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example of a list of WKT points:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /example/_doc
{
  "location" : "MULTIPOINT (102.0 2.0, 103.0 2.0)"
}</code></pre>
</div>
</div>
<h5 id="geo-multilinestring" class="discrete"><a href="http://geojson.org/geojson-spec.html#id6">MultiLineString</a></h5>
<div class="paragraph">
<p>The following is an example of a list of geojson linestrings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /example/_doc
{
  "location" : {
    "type" : "multilinestring",
    "coordinates" : [
      [ [102.0, 2.0], [103.0, 2.0], [103.0, 3.0], [102.0, 3.0] ],
      [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0] ],
      [ [100.2, 0.2], [100.8, 0.2], [100.8, 0.8], [100.2, 0.8] ]
    ]
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example of a list of WKT linestrings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /example/_doc
{
  "location" : "MULTILINESTRING ((102.0 2.0, 103.0 2.0, 103.0 3.0, 102.0 3.0), (100.0 0.0, 101.0 0.0, 101.0 1.0, 100.0 1.0), (100.2 0.2, 100.8 0.2, 100.8 0.8, 100.2 0.8))"
}</code></pre>
</div>
</div>
<h5 id="geo-multipolygon" class="discrete"><a href="http://geojson.org/geojson-spec.html#id7">MultiPolygon</a></h5>
<div class="paragraph">
<p>The following is an example of a list of geojson polygons (second polygon contains a hole):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /example/_doc
{
  "location" : {
    "type" : "multipolygon",
    "coordinates" : [
      [ [[102.0, 2.0], [103.0, 2.0], [103.0, 3.0], [102.0, 3.0], [102.0, 2.0]] ],
      [ [[100.0, 0.0], [101.0, 0.0], [101.0, 1.0], [100.0, 1.0], [100.0, 0.0]],
        [[100.2, 0.2], [100.8, 0.2], [100.8, 0.8], [100.2, 0.8], [100.2, 0.2]] ]
    ]
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example of a list of WKT polygons (second polygon contains a hole):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /example/_doc
{
  "location" : "MULTIPOLYGON (((102.0 2.0, 103.0 2.0, 103.0 3.0, 102.0 3.0, 102.0 2.0)), ((100.0 0.0, 101.0 0.0, 101.0 1.0, 100.0 1.0, 100.0 0.0), (100.2 0.2, 100.8 0.2, 100.8 0.8, 100.2 0.8, 100.2 0.2)))"
}</code></pre>
</div>
</div>
<h5 id="geo-geometry_collection" class="discrete"><a href="http://geojson.org/geojson-spec.html#geometrycollection">Geometry Collection</a></h5>
<div class="paragraph">
<p>The following is an example of a collection of geojson geometry objects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /example/_doc
{
  "location" : {
    "type": "geometrycollection",
    "geometries": [
      {
        "type": "point",
        "coordinates": [100.0, 0.0]
      },
      {
        "type": "linestring",
        "coordinates": [ [101.0, 0.0], [102.0, 1.0] ]
      }
    ]
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example of a collection of WKT geometry objects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /example/_doc
{
  "location" : "GEOMETRYCOLLECTION (POINT (100.0 0.0), LINESTRING (101.0 0.0, 102.0 1.0))"
}</code></pre>
</div>
</div>
<h5 id="_envelope" class="discrete">Envelope</h5>
<div class="paragraph">
<p>OpenSearch supports an <code>envelope</code> type, which consists of coordinates
for upper left and lower right points of the shape to represent a
bounding rectangle in the format <code><a id="minLon"></a></code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /example/_doc
{
  "location" : {
    "type" : "envelope",
    "coordinates" : [ [100.0, 1.0], [101.0, 0.0] ]
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example of an envelope using the WKT BBOX format:</p>
</div>
<div class="paragraph">
<p><strong>NOTE:</strong> WKT specification expects the following order: minLon, maxLon, maxLat, minLat.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /example/_doc
{
  "location" : "BBOX (100.0, 102.0, 2.0, 0.0)"
}</code></pre>
</div>
</div>
<h5 id="_circle" class="discrete">Circle</h5>
<div class="paragraph">
<p>OpenSearch supports a <code>circle</code> type, which consists of a center
point with a radius. Note that this circle representation can only
be indexed when using the <code>recursive</code> Prefix Tree strategy. For
the default <a href="mapping-types.html#geoshape-indexing-approach">Indexing approach</a> circles should be approximated using
a <code>POLYGON</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /example/_doc
{
  "location" : {
    "type" : "circle",
    "coordinates" : [101.0, 1.0],
    "radius" : "100m"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note: The inner <code>radius</code> field is required. If not specified, then
the units of the <code>radius</code> will default to <code>METERS</code>.</p>
</div>
<div class="paragraph">
<p><strong>NOTE:</strong> Neither GeoJSON or WKT support a point-radius circle type.</p>
</div>
<h4 id="_sorting_and_retrieving_index_shapes" class="discrete">Sorting and Retrieving index Shapes</h4>
<div class="paragraph">
<p>Due to the complex input structure and index representation of shapes,
it is not currently possible to sort shapes or retrieve their fields
directly. The geo_shape value is only retrievable through the <code>_source</code>
field.</p>
</div>
</div>
<div class="sect2">
<h3 id="ip">IP field type</h3>
<titleabbrev>IP</titleabbrev>
<div class="paragraph">
<p>An <code>ip</code> field can index/store either <a href="https://en.wikipedia.org/wiki/IPv4">IPv4</a> or
<a href="https://en.wikipedia.org/wiki/IPv6">IPv6</a> addresses.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001
{
  "mappings": {
    "properties": {
      "ip_addr": {
        "type": "ip"
      }
    }
  }
}

PUT my-index-000001/_doc/1
{
  "ip_addr": "192.168.1.1"
}

GET my-index-000001/_search
{
  "query": {
    "term": {
      "ip_addr": "192.168.0.0/16"
    }
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
You can also store ip ranges in a single field using an <a href="mapping-types.html#range">ip_range data type</a>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="ip-params">Parameters for <code>ip</code> fields</h4>
<div class="paragraph">
<p>The following parameters are accepted by <code>ip</code> fields:</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-boost"><code>boost</code></a>
</td>
<td class="hdlist2">
<p>Mapping field-level query time boosting. Accepts a floating point number, defaults
to <code>1.0</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#doc-values"><code>doc_values</code></a>
</td>
<td class="hdlist2">
<p>Should the field be stored on disk in a column-stride fashion, so that it
can later be used for sorting, aggregations, or scripting? Accepts <code>true</code>
(default) or <code>false</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#ignore-malformed"><code>ignore_malformed</code></a>
</td>
<td class="hdlist2">
<p>If <code>true</code>, malformed IP addresses are ignored. If <code>false</code> (default), malformed
IP addresses throw an exception and reject the whole document.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-index"><code>index</code></a>
</td>
<td class="hdlist2">
<p>Should the field be searchable? Accepts <code>true</code> (default) and <code>false</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#null-value"><code>null_value</code></a>
</td>
<td class="hdlist2">
<p>Accepts an IPv4 or IPv6 value which is substituted for any explicit <code>null</code> values.
Defaults to <code>null</code>, which means the field is treated as missing.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-store"><code>store</code></a>
</td>
<td class="hdlist2">
<p>Whether the field value should be stored and retrievable separately from
the <a href="mapping-fields.html#mapping-source-field"><code>_source</code></a> field. Accepts <code>true</code> or <code>false</code>
(default).</p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="query-ip-fields">Querying <code>ip</code> fields</h4>
<div class="paragraph">
<p>The most common way to query ip addresses is to use the
<a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation">CIDR</a>
notation: <code>[ip_address]/[prefix_length]</code>. For instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET my-index-000001/_search
{
  "query": {
    "term": {
      "ip_addr": "192.168.0.0/16"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET my-index-000001/_search
{
  "query": {
    "term": {
      "ip_addr": "2001:db8::/48"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also beware that colons are special characters to the
<a href="full-text-queries.html#query-dsl-query-string-query"><code>query_string</code></a> query, so ipv6 addresses will
need to be escaped. The easiest way to do so is to put quotes around the
searched value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET my-index-000001/_search
{
  "query": {
    "query_string" : {
      "query": "ip_addr:\"2001:db8::/48\""
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="parent-join">Join field type</h3>
<titleabbrev>Join</titleabbrev>
<div class="paragraph">
<p>The <code>join</code> data type is a special field that creates
parent/child relation within documents of the same index.
The <code>relations</code> section defines a set of possible relations within the documents,
each relation being a parent name and a child name.
A parent/child relation can be defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001
{
  "mappings": {
    "properties": {
      "my_id": {
        "type": "keyword"
      },
      "my_join_field": { <b class="conum">(1)</b>
        "type": "join",
        "relations": {
          "question": "answer" <b class="conum">(2)</b>
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The name for the field</p>
</li>
<li>
<p>Defines a single relation where <code>question</code> is parent of <code>answer</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>To index a document with a join, the name of the relation and the optional parent
of the document must be provided in the <code>source</code>.
For instance the following example creates two <code>parent</code> documents in the <code>question</code> context:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001/_doc/1?refresh
{
  "my_id": "1",
  "text": "This is a question",
  "my_join_field": {
    "name": "question" <b class="conum">(1)</b>
  }
}

PUT my-index-000001/_doc/2?refresh
{
  "my_id": "2",
  "text": "This is another question",
  "my_join_field": {
    "name": "question"
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This document is a <code>question</code> document.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When indexing parent documents, you can choose to specify just the name of the relation
as a shortcut instead of encapsulating it in the normal object notation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001/_doc/1?refresh
{
  "my_id": "1",
  "text": "This is a question",
  "my_join_field": "question" <b class="conum">(1)</b>
}

PUT my-index-000001/_doc/2?refresh
{
  "my_id": "2",
  "text": "This is another question",
  "my_join_field": "question"
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Simpler notation for a parent document just uses the relation name.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When indexing a child, the name of the relation as well as the parent id of the document
must be added in the <code>_source</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
It is required to index the lineage of a parent in the same shard so you must
always route child documents using their greater parent id.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For instance the following example shows how to index two <code>child</code> documents:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001/_doc/3?routing=1&amp;refresh <b class="conum">(1)</b>
{
  "my_id": "3",
  "text": "This is an answer",
  "my_join_field": {
    "name": "answer", <b class="conum">(2)</b>
    "parent": "1" <b class="conum">(3)</b>
  }
}

PUT my-index-000001/_doc/4?routing=1&amp;refresh
{
  "my_id": "4",
  "text": "This is another answer",
  "my_join_field": {
    "name": "answer",
    "parent": "1"
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The routing value is mandatory because parent and child documents must be indexed on the same shard</p>
</li>
<li>
<p><code>answer</code> is the name of the join for this document</p>
</li>
<li>
<p>The parent id of this child document</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_parent_join_and_performance">Parent-join and performance</h4>
<div class="paragraph">
<p>The join field shouldn&#8217;t be used like joins in a relation database. In OpenSearch the key to good performance
is to de-normalize your data into documents. Each join field, <code>has_child</code> or <code>has_parent</code> query adds a
significant tax to your query performance. It can also trigger <a href="mapping-params.html#eager-global-ordinals">global ordinals</a> to be built.</p>
</div>
<div class="paragraph">
<p>The only case where the join field makes sense is if your data contains a one-to-many relationship where
one entity significantly outnumbers the other entity. An example of such case is a use case with products
and offers for these products. In the case that offers significantly outnumbers the number of products then
it makes sense to model the product as parent document and the offer as child document.</p>
</div>
</div>
<div class="sect3">
<h4 id="_parent_join_restrictions">Parent-join restrictions</h4>
<div class="ulist">
<ul>
<li>
<p>Only one <code>join</code> field mapping is allowed per index.</p>
</li>
<li>
<p>Parent and child documents must be indexed on the same shard.
This means that the same <code>routing</code> value needs to be provided when
<a href="docs.html#docs-get">getting</a>, <a href="docs.html#docs-delete">deleting</a>, or <a href="docs.html#docs-update">updating</a>
a child document.</p>
</li>
<li>
<p>An element can have multiple children but only one parent.</p>
</li>
<li>
<p>It is possible to add a new relation to an existing <code>join</code> field.</p>
</li>
<li>
<p>It is also possible to add a child to an existing element
but only if the element is already a parent.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_searching_with_parent_join">Searching with parent-join</h4>
<div class="paragraph">
<p>The parent-join creates one field to index the name of the relation
within the document (<code>my_parent</code>, <code>my_child</code>, &#8230;&#8203;).</p>
</div>
<div class="paragraph">
<p>It also creates one field per parent/child relation.
The name of this field is the name of the <code>join</code> field followed by <code>#</code> and the
name of the parent in the relation.
So for instance for the <code>my_parent</code> &#8594; [<code>my_child</code>, <code>another_child</code>] relation,
the <code>join</code> field creates an additional field named <code>my_join_field#my_parent</code>.</p>
</div>
<div class="paragraph">
<p>This field contains the parent <code>_id</code> that the document links to
if the document is a child (<code>my_child</code> or <code>another_child</code>) and the <code>_id</code> of
document if it&#8217;s a parent (<code>my_parent</code>).</p>
</div>
<div class="paragraph">
<p>When searching an index that contains a <code>join</code> field, these two fields are always
returned in the search response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET my-index-000001/_search
{
  "query": {
    "match_all": {}
  },
  "sort": ["my_id"]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Will return:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  ...,
  "hits": {
    "total": {
      "value": 4,
      "relation": "eq"
    },
    "max_score": null,
    "hits": [
      {
        "_index": "my-index-000001",
        "_type": "_doc",
        "_id": "1",
        "_score": null,
        "_source": {
          "my_id": "1",
          "text": "This is a question",
          "my_join_field": "question"         <b class="conum">(1)</b>
        },
        "sort": [
          "1"
        ]
      },
      {
        "_index": "my-index-000001",
        "_type": "_doc",
        "_id": "2",
        "_score": null,
        "_source": {
          "my_id": "2",
          "text": "This is another question",
          "my_join_field": "question"          <b class="conum">(2)</b>
        },
        "sort": [
          "2"
        ]
      },
      {
        "_index": "my-index-000001",
        "_type": "_doc",
        "_id": "3",
        "_score": null,
        "_routing": "1",
        "_source": {
          "my_id": "3",
          "text": "This is an answer",
          "my_join_field": {
            "name": "answer",                 <b class="conum">(3)</b>
            "parent": "1"                     <b class="conum">(4)</b>
          }
        },
        "sort": [
          "3"
        ]
      },
      {
        "_index": "my-index-000001",
        "_type": "_doc",
        "_id": "4",
        "_score": null,
        "_routing": "1",
        "_source": {
          "my_id": "4",
          "text": "This is another answer",
          "my_join_field": {
            "name": "answer",
            "parent": "1"
          }
        },
        "sort": [
          "4"
        ]
      }
    ]
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This document belongs to the <code>question</code> join</p>
</li>
<li>
<p>This document belongs to the <code>question</code> join</p>
</li>
<li>
<p>This document belongs to the <code>answer</code> join</p>
</li>
<li>
<p>The linked parent id for the child document</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_parent_join_queries_and_aggregations">Parent-join queries and aggregations</h4>
<div class="paragraph">
<p>See the <a href="joining-queries.html#query-dsl-has-child-query"><code>has_child</code></a> and
<a href="joining-queries.html#query-dsl-has-parent-query"><code>has_parent</code></a> queries,
the <a href="search-aggregations-bucket.html#search-aggregations-bucket-children-aggregation"><code>children</code></a> aggregation,
and <a href="inner-hits.html#parent-child-inner-hits">inner hits</a> for more information.</p>
</div>
<div class="paragraph">
<p>The value of the <code>join</code> field is accessible in aggregations
and scripts, and may be queried with the
<a href="joining-queries.html#query-dsl-parent-id-query"><code>parent_id</code> query</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET my-index-000001/_search
{
  "query": {
    "parent_id": { <b class="conum">(1)</b>
      "type": "answer",
      "id": "1"
    }
  },
  "aggs": {
    "parents": {
      "terms": {
        "field": "my_join_field#question", <b class="conum">(2)</b>
        "size": 10
      }
    }
  },
  "script_fields": {
    "parent": {
      "script": {
         "source": "doc['my_join_field#question']" <b class="conum">(3)</b>
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Querying the <code>parent id</code> field (also see the <a href="joining-queries.html#query-dsl-has-parent-query"><code>has_parent</code> query</a> and the <a href="joining-queries.html#query-dsl-has-child-query"><code>has_child</code> query</a>)</p>
</li>
<li>
<p>Aggregating on the <code>parent id</code> field (also see the <a href="search-aggregations-bucket.html#search-aggregations-bucket-children-aggregation"><code>children</code></a> aggregation)</p>
</li>
<li>
<p>Accessing the parent id` field in scripts</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_global_ordinals">Global ordinals</h4>
<div class="paragraph">
<p>The <code>join</code> field uses <a href="mapping-params.html#eager-global-ordinals">global ordinals</a> to speed up joins.
Global ordinals need to be rebuilt after any change to a shard. The more
parent id values are stored in a shard, the longer it takes to rebuild the
global ordinals for the <code>join</code> field.</p>
</div>
<div class="paragraph">
<p>Global ordinals, by default, are built eagerly: if the index has changed,
global ordinals for the <code>join</code> field will be rebuilt as part of the refresh.
This can add significant time to the refresh. However most of the times this is the
right trade-off, otherwise global ordinals are rebuilt when the first parent-join
query or aggregation is used. This can introduce a significant latency spike for
your users and usually this is worse as multiple global ordinals for the <code>join</code>
field may be attempt rebuilt within a single refresh interval when many writes
are occurring.</p>
</div>
<div class="paragraph">
<p>When the <code>join</code> field is used infrequently and writes occur frequently it may
make sense to disable eager loading:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001
{
  "mappings": {
    "properties": {
      "my_join_field": {
        "type": "join",
        "relations": {
           "question": "answer"
        },
        "eager_global_ordinals": false
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The amount of heap used by global ordinals can be checked per parent relation
as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console"># Per-index
GET _stats/fielddata?human&amp;fields=my_join_field#question

# Per-node per-index
GET _nodes/stats/indices/fielddata?human&amp;fields=my_join_field#question</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_multiple_children_per_parent">Multiple children per parent</h4>
<div class="paragraph">
<p>It is also possible to define multiple children for a single parent:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001
{
  "mappings": {
    "properties": {
      "my_join_field": {
        "type": "join",
        "relations": {
          "question": ["answer", "comment"]  <b class="conum">(1)</b>
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>question</code> is parent of <code>answer</code> and <code>comment</code>.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_multiple_levels_of_parent_join">Multiple levels of parent join</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Using multiple levels of relations to replicate a relational model is not recommended.
Each level of relation adds an overhead at query time in terms of memory and computation.
You should de-normalize your data if you care about performance.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Multiple levels of parent/child:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001
{
  "mappings": {
    "properties": {
      "my_join_field": {
        "type": "join",
        "relations": {
          "question": ["answer", "comment"],  <b class="conum">(1)</b>
          "answer": "vote" <b class="conum">(2)</b>
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>question</code> is parent of <code>answer</code> and <code>comment</code></p>
</li>
<li>
<p><code>answer</code> is parent of <code>vote</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The mapping above represents the following tree:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>   question
    /    \
   /      \
comment  answer
           |
           |
          vote</pre>
</div>
</div>
<div class="paragraph">
<p>Indexing a grandchild document requires a <code>routing</code> value equals
to the grand-parent (the greater parent of the lineage):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001/_doc/3?routing=1&amp;refresh <b class="conum">(1)</b>
{
  "text": "This is a vote",
  "my_join_field": {
    "name": "vote",
    "parent": "2" <b class="conum">(2)</b>
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This child document must be on the same shard than its grand-parent and parent</p>
</li>
<li>
<p>The parent id of this document (must points to an <code>answer</code> document)</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="keyword">Keyword type family</h3>
<titleabbrev>Keyword</titleabbrev>
<div class="paragraph">
<p>The keyword family includes the following field types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="mapping-types.html#keyword-field-type"><code>keyword</code></a>, which is used for structured content such as IDs, email
addresses, hostnames, status codes, zip codes, or tags.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Keyword fields are often used in <a href="sort-search-results.html">sorting</a>,
<a href="search-aggregations.html">aggregations</a>, and <a href="term-level-queries.html">term-level
queries</a>, such as <a href="term-level-queries.html#query-dsl-term-query"><code>term</code></a>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
Avoid using keyword fields for full-text search. Use the <a href="mapping-types.html#text"><code>text</code></a>
field type instead.
</td>
</tr>
</table>
</div>
<h3 id="keyword-field-type" class="discrete">Keyword field type</h3>
<div class="paragraph">
<p>Below is an example of a mapping for a basic <code>keyword</code> field:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001
{
  "mappings": {
    "properties": {
      "tags": {
        "type":  "keyword"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">Mapping numeric identifiers</div>
<div class="paragraph">
<p>Not all numeric data should be mapped as a <a href="mapping-types.html#number">numeric</a> field data type.
OpenSearch optimizes numeric fields, such as <code>integer</code> or <code>long</code>, for
<a href="term-level-queries.html#query-dsl-range-query"><code>range</code></a> queries. However, <a href="mapping-types.html#keyword"><code>keyword</code></a> fields
are better for <a href="term-level-queries.html#query-dsl-term-query"><code>term</code></a> and other
<a href="term-level-queries.html">term-level</a> queries.</p>
</div>
<div class="paragraph">
<p>Identifiers, such as an ISBN or a product ID, are rarely used in <code>range</code>
queries. However, they are often retrieved using term-level queries.</p>
</div>
<div class="paragraph">
<p>Consider mapping a numeric identifier as a <code>keyword</code> if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You don&#8217;t plan to search for the identifier data using
<a href="term-level-queries.html#query-dsl-range-query"><code>range</code></a> queries.</p>
</li>
<li>
<p>Fast retrieval is important. <code>term</code> query searches on <code>keyword</code> fields are
often faster than <code>term</code> searches on numeric fields.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you&#8217;re unsure which to use, you can use a <a href="mapping-params.html#multi-fields">multi-field</a> to map
the data as both a <code>keyword</code> <em>and</em> a numeric data type.</p>
</div>
</td>
</tr>
</table>
</div>
<h4 id="keyword-params" class="discrete">Parameters for basic keyword fields</h4>
<div class="paragraph">
<p>The following parameters are accepted by <code>keyword</code> fields:</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-boost"><code>boost</code></a>
</td>
<td class="hdlist2">
<p>Mapping field-level query time boosting. Accepts a floating point number, defaults
to <code>1.0</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#doc-values"><code>doc_values</code></a>
</td>
<td class="hdlist2">
<p>Should the field be stored on disk in a column-stride fashion, so that it
can later be used for sorting, aggregations, or scripting? Accepts <code>true</code>
(default) or <code>false</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#eager-global-ordinals"><code>eager_global_ordinals</code></a>
</td>
<td class="hdlist2">
<p>Should global ordinals be loaded eagerly on refresh? Accepts <code>true</code> or <code>false</code>
(default). Enabling this is a good idea on fields that are frequently used for
terms aggregations.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#multi-fields"><code>fields</code></a>
</td>
<td class="hdlist2">
<p>Multi-fields allow the same string value to be indexed in multiple ways for
different purposes, such as one field for search and a multi-field for
sorting and aggregations.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#ignore-above"><code>ignore_above</code></a>
</td>
<td class="hdlist2">
<p>Do not index any string longer than this value.  Defaults to <code>2147483647</code>
so that all values would be accepted. Please however note that default
dynamic mapping rules create a sub <code>keyword</code> field that overrides this
default by setting <code>ignore_above: 256</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-index"><code>index</code></a>
</td>
<td class="hdlist2">
<p>Should the field be searchable? Accepts <code>true</code> (default) or <code>false</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#index-options"><code>index_options</code></a>
</td>
<td class="hdlist2">
<p>What information should be stored in the index, for scoring purposes.
Defaults to <code>docs</code> but can also be set to <code>freqs</code> to take term frequency into account
when computing scores.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#norms"><code>norms</code></a>
</td>
<td class="hdlist2">
<p>Whether field-length should be taken into account when scoring queries.
Accepts <code>true</code> or <code>false</code> (default).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#null-value"><code>null_value</code></a>
</td>
<td class="hdlist2">
<p>Accepts a string value which is substituted for any explicit <code>null</code>
values.  Defaults to <code>null</code>, which means the field is treated as missing.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-store"><code>store</code></a>
</td>
<td class="hdlist2">
<p>Whether the field value should be stored and retrievable separately from
the <a href="mapping-fields.html#mapping-source-field"><code>_source</code></a> field. Accepts <code>true</code> or <code>false</code>
(default).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#similarity"><code>similarity</code></a>
</td>
<td class="hdlist2">
<p>Which scoring algorithm or <em>similarity</em> should be used. Defaults
to <code>BM25</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#normalizer"><code>normalizer</code></a>
</td>
<td class="hdlist2">
<p>How to pre-process the keyword prior to indexing. Defaults to <code>null</code>,
meaning the keyword is kept as-is.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>split_queries_on_whitespace</code>
</td>
<td class="hdlist2">
<p>Whether <a href="full-text-queries.html">full text queries</a> should split the input on whitespace
when building a query for this field.
Accepts <code>true</code> or <code>false</code> (default).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-field-meta"><code>meta</code></a>
</td>
<td class="hdlist2">
<p>Metadata about the field.</p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="nested">Nested field type</h3>
<titleabbrev>Nested</titleabbrev>
<div class="paragraph">
<p>The <code>nested</code> type is a specialised version of the <a href="mapping-types.html#object"><code>object</code></a> data type
that allows arrays of objects to be indexed in a way that they can be queried
independently of each other.</p>
</div>
<div class="sect3">
<h4 id="nested-arrays-flattening-objects">How arrays of objects are flattened</h4>
<div class="paragraph">
<p>OpenSearch has no concept of inner objects. Therefore, it flattens object
hierarchies into a simple list of field names and values. For instance, consider the
following document:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001/_doc/1
{
  "group" : "fans",
  "user" : [ <b class="conum">(1)</b>
    {
      "first" : "John",
      "last" :  "Smith"
    },
    {
      "first" : "Alice",
      "last" :  "White"
    }
  ]
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>user</code> field is dynamically added as a field of type <code>object</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The previous document would be transformed internally into a document that looks more like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "group" :        "fans",
  "user.first" : [ "alice", "john" ],
  "user.last" :  [ "smith", "white" ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>user.first</code> and <code>user.last</code> fields are flattened into multi-value fields,
and the association between <code>alice</code> and <code>white</code> is lost.  This document would
incorrectly match a query for <code>alice AND smith</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET my-index-000001/_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "user.first": "Alice" }},
        { "match": { "user.last":  "Smith" }}
      ]
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nested-fields-array-objects">Using <code>nested</code> fields for arrays of objects</h4>
<div class="paragraph">
<p>If you need to index arrays of objects and to maintain the independence of
each object in the array, use the <code>nested</code> data type instead of the
<a href="mapping-types.html#object"><code>object</code></a> data type.</p>
</div>
<div class="paragraph">
<p>Internally, nested objects index each object in
the array as a separate hidden document, meaning that each nested object can be
queried independently of the others with the <a href="joining-queries.html#query-dsl-nested-query"><code>nested</code> query</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001
{
  "mappings": {
    "properties": {
      "user": {
        "type": "nested" <b class="conum">(1)</b>
      }
    }
  }
}

PUT my-index-000001/_doc/1
{
  "group" : "fans",
  "user" : [
    {
      "first" : "John",
      "last" :  "Smith"
    },
    {
      "first" : "Alice",
      "last" :  "White"
    }
  ]
}

GET my-index-000001/_search
{
  "query": {
    "nested": {
      "path": "user",
      "query": {
        "bool": {
          "must": [
            { "match": { "user.first": "Alice" }},
            { "match": { "user.last":  "Smith" }} <b class="conum">(2)</b>
          ]
        }
      }
    }
  }
}

GET my-index-000001/_search
{
  "query": {
    "nested": {
      "path": "user",
      "query": {
        "bool": {
          "must": [
            { "match": { "user.first": "Alice" }},
            { "match": { "user.last":  "White" }} <b class="conum">(3)</b>
          ]
        }
      },
      "inner_hits": { <b class="conum">(4)</b>
        "highlight": {
          "fields": {
            "user.first": {}
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>user</code> field is mapped as type <code>nested</code> instead of type <code>object</code>.</p>
</li>
<li>
<p>This query doesn&#8217;t match because <code>Alice</code> and <code>Smith</code> are not in the same nested object.</p>
</li>
<li>
<p>This query matches because <code>Alice</code> and <code>White</code> are in the same nested object.</p>
</li>
<li>
<p><code>inner_hits</code> allow us to highlight the matching nested documents.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="nested-accessing-documents">Interacting with <code>nested</code> documents</h4>
<div class="paragraph">
<p>Nested documents can be:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>queried with the <a href="joining-queries.html#query-dsl-nested-query"><code>nested</code></a> query.</p>
</li>
<li>
<p>analyzed with the <a href="search-aggregations-bucket.html#search-aggregations-bucket-nested-aggregation"><code>nested</code></a>
and <a href="search-aggregations-bucket.html#search-aggregations-bucket-reverse-nested-aggregation"><code>reverse_nested</code></a>
aggregations.</p>
</li>
<li>
<p>sorted with <a href="sort-search-results.html#nested-sorting">nested sorting</a>.</p>
</li>
<li>
<p>retrieved and highlighted with <a href="inner-hits.html#nested-inner-hits">nested inner hits</a>.</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>Because nested documents are indexed as separate documents, they can only be
accessed  within the scope of the <code>nested</code> query, the
<code>nested</code>/<code>reverse_nested</code> aggregations, or <a href="inner-hits.html#nested-inner-hits">nested inner hits</a>.</p>
</div>
<div class="paragraph">
<p>For instance, if a string field within a nested document has
<a href="mapping-params.html#index-options"><code>index_options</code></a> set to <code>offsets</code> to allow use of the postings
during the highlighting, these offsets will not be available during the main highlighting
phase.  Instead, highlighting needs to be performed via
<a href="inner-hits.html#nested-inner-hits">nested inner hits</a>. The same consideration applies when loading
fields during a search through <a href="search-fields.html#docvalue-fields"><code>docvalue_fields</code></a> or <a href="search-fields.html#stored-fields"><code>stored_fields</code></a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="nested-params">Parameters for <code>nested</code> fields</h4>
<div class="paragraph">
<p>The following parameters are accepted by <code>nested</code> fields:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="mapping-params.html#dynamic"><code>dynamic</code></a></dt>
<dd>
<p>(Optional, string)
Whether or not new <code>properties</code> should be added dynamically to an existing
nested object.  Accepts <code>true</code> (default), <code>false</code> and <code>strict</code>.</p>
</dd>
<dt class="hdlist1"><a href="mapping-params.html#properties"><code>properties</code></a></dt>
<dd>
<p>(Optional, object)
The fields within the nested object, which can be of any
<a href="mapping-types.html">data type</a>, including <code>nested</code>. New properties
may be added to an existing nested object.</p>
</dd>
</dl>
</div>
<div id="nested-include-in-parent-parm" class="dlist">
<dl>
<dt class="hdlist1"><code>include_in_parent</code></dt>
<dd>
<p>(Optional, Boolean)
If <code>true</code>, all fields in the nested object are also added to the parent document
as standard (flat) fields. Defaults to <code>false</code>.</p>
</dd>
</dl>
</div>
<div id="nested-include-in-root-parm" class="dlist">
<dl>
<dt class="hdlist1"><code>include_in_root</code></dt>
<dd>
<p>(Optional, Boolean)
If <code>true</code>, all fields in the nested object are also added to the root
document as standard (flat) fields. Defaults to <code>false</code>.</p>
</dd>
</dl>
</div>
<h3 id="_limits_on_nested_mappings_and_objects" class="discrete">Limits on <code>nested</code> mappings and objects</h3>
<div class="paragraph">
<p>As described earlier, each nested object is indexed as a separate Lucene document.
Continuing with the previous example, if we indexed a single document containing 100 <code>user</code> objects,
then 101 Lucene documents would be created: one for the parent document, and one for each
nested object. Because of the expense associated with <code>nested</code> mappings, OpenSearch puts
settings in place to guard against performance problems:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>index.mapping.nested_fields.limit</code></dt>
<dd>
<p>The maximum number of distinct <code>nested</code> mappings in an index. The <code>nested</code> type should only be used in special cases, when arrays of objects need to be queried independently of each other. To safeguard against poorly designed mappings, this setting
limits the number of unique <code>nested</code> types per index. Default is <code>50</code>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>In the previous example, the <code>user</code> mapping would count as only 1 towards this limit.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>index.mapping.nested_objects.limit</code></dt>
<dd>
<p>The maximum number of nested JSON objects that a single document can contain across all
<code>nested</code> types. This limit helps to prevent out of memory errors when a document contains too many nested
objects. Default is <code>10000</code>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>To illustrate how this setting works, consider adding another <code>nested</code> type called <code>comments</code>
to the previous example mapping. For each document, the combined number of <code>user</code> and <code>comment</code>
objects it contains must be below the limit.</p>
</div>
<div class="paragraph">
<p>See <a href="mapping.html#mapping-limit-settings">Settings to prevent mappings explosion</a> regarding additional settings for preventing mappings explosion.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="number">Numeric field types</h3>
<titleabbrev>Numeric</titleabbrev>
<div class="paragraph">
<p>The following numeric types are supported:</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>long</code>
</td>
<td class="hdlist2">
<p>A signed 64-bit integer with a minimum value of -2^63^ and a maximum value of 2^63^-1.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>integer</code>
</td>
<td class="hdlist2">
<p>A signed 32-bit integer with a minimum value of -2^31^ and a maximum value of 2^31^-1.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>short</code>
</td>
<td class="hdlist2">
<p>A signed 16-bit integer with a minimum value of -32,768 and a maximum value of 32,767.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>byte</code>
</td>
<td class="hdlist2">
<p>A signed 8-bit integer with a minimum value of -128 and a maximum value of 127.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>double</code>
</td>
<td class="hdlist2">
<p>A double-precision 64-bit IEEE 754 floating point number, restricted to finite values.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>float</code>
</td>
<td class="hdlist2">
<p>A single-precision 32-bit IEEE 754 floating point number, restricted to finite values.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>half_float</code>
</td>
<td class="hdlist2">
<p>A half-precision 16-bit IEEE 754 floating point number, restricted to finite values.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>scaled_float</code>
</td>
<td class="hdlist2">
<p>A floating point number that is backed by a <code>long</code>, scaled by a fixed <code>double</code> scaling factor.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>unsigned_long</code>
</td>
<td class="hdlist2">
<p>An unsigned 64-bit integer with a minimum value of 0 and a maximum value of 2^64^-1.</p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Below is an example of configuring a mapping with numeric fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001
{
  "mappings": {
    "properties": {
      "number_of_bytes": {
        "type": "integer"
      },
      "time_in_seconds": {
        "type": "float"
      },
      "price": {
        "type": "scaled_float",
        "scaling_factor": 100
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The <code>double</code>, <code>float</code> and <code>half_float</code> types consider that <code>-0.0</code> and
<code>+0.0</code> are different values. As a consequence, doing a <code>term</code> query on
<code>-0.0</code> will not match <code>+0.0</code> and vice-versa. Same is true for range queries:
if the upper bound is <code>-0.0</code> then <code>+0.0</code> will not match, and if the lower
bound is <code>+0.0</code> then <code>-0.0</code> will not match.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_which_type_should_i_use">Which type should I use?</h4>
<div class="paragraph">
<p>As far as integer types (<code>byte</code>, <code>short</code>, <code>integer</code> and <code>long</code>) are concerned,
you should pick the smallest type which is enough for your use-case. This will
help indexing and searching be more efficient. Note however that storage is
optimized based on the actual values that are stored, so picking one type over
another one will have no impact on storage requirements.</p>
</div>
<div class="paragraph">
<p>For floating-point types, it is often more efficient to store floating-point
data into an integer using a scaling factor, which is what the <code>scaled_float</code>
type does under the hood. For instance, a <code>price</code> field could be stored in a
<code>scaled_float</code> with a <code>scaling_factor</code> of 100. All APIs would work as if
the field was stored as a double, but under the hood OpenSearch would be
working with the number of cents, price*100, which is an integer. This is
mostly helpful to save disk space since integers are way easier to compress
than floating points. <code>scaled_float</code> is also fine to use in order to trade
accuracy for disk space. For instance imagine that you are tracking cpu
utilization as a number between 0 and 1. It usually does not matter much
whether cpu utilization is 12.7% or 13%, so you could use a <code>scaled_float</code>
with a <code>scaling_factor</code> of 100 in order to round cpu utilization to the
closest percent in order to save space.</p>
</div>
<div class="paragraph">
<p>If <code>scaled_float</code> is not a good fit, then you should pick the smallest type
that is enough for the use-case among the floating-point types: <code>double</code>,
<code>float</code> and <code>half_float</code>. Here is a table that compares these types in order
to help make a decision.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Minimum value</th>
<th class="tableblock halign-left valign-top">Maximum value</th>
<th class="tableblock halign-left valign-top">Significant bits / digits</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>double</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2^-1074^</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(2-2^-52^)2^1023^</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">53 / 15.95</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>float</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2^-149^</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(2-2^-23^)2^127^</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">24 / 7.22</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>half_float</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2^-24^</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">65504</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11 / 3.31</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="title">Mapping numeric identifiers</div>
<div class="paragraph">
<p>Not all numeric data should be mapped as a <a href="mapping-types.html#number">numeric</a> field data type.
OpenSearch optimizes numeric fields, such as <code>integer</code> or <code>long</code>, for
<a href="term-level-queries.html#query-dsl-range-query"><code>range</code></a> queries. However, <a href="mapping-types.html#keyword"><code>keyword</code></a> fields
are better for <a href="term-level-queries.html#query-dsl-term-query"><code>term</code></a> and other
<a href="term-level-queries.html">term-level</a> queries.</p>
</div>
<div class="paragraph">
<p>Identifiers, such as an ISBN or a product ID, are rarely used in <code>range</code>
queries. However, they are often retrieved using term-level queries.</p>
</div>
<div class="paragraph">
<p>Consider mapping a numeric identifier as a <code>keyword</code> if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You don&#8217;t plan to search for the identifier data using
<a href="term-level-queries.html#query-dsl-range-query"><code>range</code></a> queries.</p>
</li>
<li>
<p>Fast retrieval is important. <code>term</code> query searches on <code>keyword</code> fields are
often faster than <code>term</code> searches on numeric fields.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you&#8217;re unsure which to use, you can use a <a href="mapping-params.html#multi-fields">multi-field</a> to map
the data as both a <code>keyword</code> <em>and</em> a numeric data type.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="number-params">Parameters for numeric fields</h4>
<div class="paragraph">
<p>The following parameters are accepted by numeric types:</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#coerce"><code>coerce</code></a>
</td>
<td class="hdlist2">
<p>Try to convert strings to numbers and truncate fractions for integers.
Accepts <code>true</code> (default) and <code>false</code>. Not applicable for <code>unsigned_long</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-boost"><code>boost</code></a>
</td>
<td class="hdlist2">
<p>Mapping field-level query time boosting. Accepts a floating point number, defaults
to <code>1.0</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#doc-values"><code>doc_values</code></a>
</td>
<td class="hdlist2">
<p>Should the field be stored on disk in a column-stride fashion, so that it
can later be used for sorting, aggregations, or scripting? Accepts <code>true</code>
(default) or <code>false</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#ignore-malformed"><code>ignore_malformed</code></a>
</td>
<td class="hdlist2">
<p>If <code>true</code>, malformed numbers are ignored. If <code>false</code> (default), malformed
numbers throw an exception and reject the whole document.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-index"><code>index</code></a>
</td>
<td class="hdlist2">
<p>Should the field be searchable? Accepts <code>true</code> (default) and <code>false</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#null-value"><code>null_value</code></a>
</td>
<td class="hdlist2">
<p>Accepts a numeric value of the same <code>type</code> as the field which is
substituted for any explicit <code>null</code> values.  Defaults to <code>null</code>, which
means the field is treated as missing.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-store"><code>store</code></a>
</td>
<td class="hdlist2">
<p>Whether the field value should be stored and retrievable separately from
the <a href="mapping-fields.html#mapping-source-field"><code>_source</code></a> field. Accepts <code>true</code> or <code>false</code>
(default).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-field-meta"><code>meta</code></a>
</td>
<td class="hdlist2">
<p>Metadata about the field.</p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="scaled-float-params">Parameters for <code>scaled_float</code></h4>
<div class="paragraph">
<p><code>scaled_float</code> accepts an additional parameter:</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>scaling_factor</code>
</td>
<td class="hdlist2">
<p>The scaling factor to use when encoding values. Values will be multiplied
by this factor at index time and rounded to the closest long value. For
instance, a <code>scaled_float</code> with a <code>scaling_factor</code> of 10 would internally
store 2.34 as 23 and all search-time operations (queries, aggregations,
sorting) will behave as if the document had a value of 2.3. High values
of <code>scaling_factor</code> improve accuracy but also increase space requirements.
This parameter is required.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="object">Object field type</h3>
<titleabbrev>Object</titleabbrev>
<div class="paragraph">
<p>JSON documents are hierarchical in nature: the document may contain inner
objects which, in turn, may contain inner objects themselves:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001/_doc/1
{ <b class="conum">(1)</b>
  "region": "US",
  "manager": { <b class="conum">(2)</b>
    "age":     30,
    "name": { <b class="conum">(3)</b>
      "first": "John",
      "last":  "Smith"
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The outer document is also a JSON object.</p>
</li>
<li>
<p>It contains an inner object called <code>manager</code>.</p>
</li>
<li>
<p>Which in turn contains an inner object called <code>name</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Internally, this document is indexed as a simple, flat list of key-value
pairs, something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "region":             "US",
  "manager.age":        30,
  "manager.name.first": "John",
  "manager.name.last":  "Smith"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An explicit mapping for the above document could look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001
{
  "mappings": {
    "properties": { <b class="conum">(1)</b>
      "region": {
        "type": "keyword"
      },
      "manager": { <b class="conum">(2)</b>
        "properties": {
          "age":  { "type": "integer" },
          "name": { <b class="conum">(3)</b>
            "properties": {
              "first": { "type": "text" },
              "last":  { "type": "text" }
            }
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Properties in the top-level mappings definition.</p>
</li>
<li>
<p>The <code>manager</code> field is an inner <code>object</code> field.</p>
</li>
<li>
<p>The <code>manager.name</code> field is an inner <code>object</code> field within the <code>manager</code> field.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You are not required to set the field <code>type</code> to <code>object</code> explicitly, as this is the default value.</p>
</div>
<div class="sect3">
<h4 id="object-params">Parameters for <code>object</code> fields</h4>
<div class="paragraph">
<p>The following parameters are accepted by <code>object</code> fields:</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#dynamic"><code>dynamic</code></a>
</td>
<td class="hdlist2">
<p>Whether or not new <code>properties</code> should be added dynamically
to an existing object.  Accepts <code>true</code> (default), <code>false</code>
and <code>strict</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#enabled"><code>enabled</code></a>
</td>
<td class="hdlist2">
<p>Whether the JSON value given for the object field should be
parsed and indexed (<code>true</code>, default) or completely ignored (<code>false</code>).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#properties"><code>properties</code></a>
</td>
<td class="hdlist2">
<p>The fields within the object, which can be of any
<a href="mapping-types.html">data type</a>, including <code>object</code>. New properties
may be added to an existing object.</p>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
If you need to index arrays of objects instead of single objects,
read <a href="mapping-types.html#nested">Nested field type</a> first.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="percolator">Percolator field type</h3>
<titleabbrev>Percolator</titleabbrev>
<div class="paragraph">
<p>The <code>percolator</code> field type parses a json structure into a native query and
stores that query, so that the <a href="specialized-queries.html#query-dsl-percolate-query">percolate query</a>
can use it to match provided documents.</p>
</div>
<div class="paragraph">
<p>Any field that contains a json object can be configured to be a percolator
field. The percolator field type has no settings. Just configuring the <code>percolator</code>
field type is sufficient to instruct OpenSearch to treat a field as a
query.</p>
</div>
<div class="paragraph">
<p>If the following mapping configures the <code>percolator</code> field type for the
<code>query</code> field:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001
{
  "mappings": {
    "properties": {
      "query": {
        "type": "percolator"
      },
      "field": {
        "type": "text"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then you can index a query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001/_doc/match_value
{
  "query": {
    "match": {
      "field": "value"
    }
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>Fields referred to in a percolator query must <strong>already</strong> exist in the mapping
associated with the index used for percolation. In order to make sure these fields exist,
add or update a mapping via the <a href="indices.html#indices-create-index">create index</a> or <a href="indices.html#indices-put-mapping">put mapping</a> APIs.</p>
</div>
</td>
</tr>
</table>
</div>
<h4 id="_reindexing_your_percolator_queries" class="discrete">Reindexing your percolator queries</h4>
<div class="paragraph">
<p>Reindexing percolator queries is sometimes required to benefit from improvements made to the <code>percolator</code> field type in
new releases.</p>
</div>
<div class="paragraph">
<p>Reindexing percolator queries can be reindexed by using the <a href="docs.html#docs-reindex">reindex api</a>.
Lets take a look at the following index with a percolator field type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT index
{
  "mappings": {
    "properties": {
      "query" : {
        "type" : "percolator"
      },
      "body" : {
        "type": "text"
      }
    }
  }
}

POST _aliases
{
  "actions": [
    {
      "add": {
        "index": "index",
        "alias": "queries" <b class="conum">(1)</b>
      }
    }
  ]
}

PUT queries/_doc/1?refresh
{
  "query" : {
    "match" : {
      "body" : "quick brown fox"
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>It is always recommended to define an alias for your index, so that in case of a reindex systems / applications
don&#8217;t need to be changed to know that the percolator queries are now in a different index.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Lets say you&#8217;re going to upgrade to a new major version and in order for the new OpenSearch version to still be able
to read your queries you need to reindex your queries into a new index on the current OpenSearch version:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT new_index
{
  "mappings": {
    "properties": {
      "query" : {
        "type" : "percolator"
      },
      "body" : {
        "type": "text"
      }
    }
  }
}

POST /_reindex?refresh
{
  "source": {
    "index": "index"
  },
  "dest": {
    "index": "new_index"
  }
}

POST _aliases
{
  "actions": [ <b class="conum">(1)</b>
    {
      "remove": {
        "index" : "index",
        "alias": "queries"
      }
    },
    {
      "add": {
        "index": "new_index",
        "alias": "queries"
      }
    }
  ]
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>If you have an alias don&#8217;t forget to point it to the new index.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Executing the <code>percolate</code> query via the <code>queries</code> alias:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /queries/_search
{
  "query": {
    "percolate" : {
      "field" : "query",
      "document" : {
        "body" : "fox jumps over the lazy dog"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>now returns matches from the new index:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "took": 3,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped" : 0,
    "failed": 0
  },
  "hits": {
    "total" : {
        "value": 1,
        "relation": "eq"
    },
    "max_score": 0.13076457,
    "hits": [
      {
        "_index": "new_index", <b class="conum">(1)</b>
        "_type": "_doc",
        "_id": "1",
        "_score": 0.13076457,
        "_source": {
          "query": {
            "match": {
              "body": "quick brown fox"
            }
          }
        },
        "fields" : {
          "_percolator_document_slot" : [0]
        }
      }
    ]
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Percolator query hit is now being presented from the new index.</p>
</li>
</ol>
</div>
<h4 id="_optimizing_query_time_text_analysis" class="discrete">Optimizing query time text analysis</h4>
<div class="paragraph">
<p>When the percolator verifies a percolator candidate match it is going to parse, perform query time text analysis and actually run
the percolator query on the document being percolated. This is done for each candidate match and every time the <code>percolate</code> query executes.
If your query time text analysis is relatively expensive part of query parsing then text analysis can become the
dominating factor time is being spent on when percolating. This query parsing overhead can become noticeable when the
percolator ends up verifying many candidate percolator query matches.</p>
</div>
<div class="paragraph">
<p>To avoid the most expensive part of text analysis at percolate time. One can choose to do the expensive part of text analysis
when indexing the percolator query. This requires using two different analyzers. The first analyzer actually performs
text analysis that needs be performed (expensive part). The second analyzer (usually whitespace) just splits the generated tokens
that the first analyzer has produced. Then before indexing a percolator query, the analyze api should be used to analyze the query
text with the more expensive analyzer. The result of the analyze api, the tokens, should be used to substitute the original query
text in the percolator query. It is important that the query should now be configured to override the analyzer from the mapping and
just the second analyzer. Most text based queries support an <code>analyzer</code> option (<code>match</code>, <code>query_string</code>, <code>simple_query_string</code>).
Using this approach the expensive text analysis is performed once instead of many times.</p>
</div>
<div class="paragraph">
<p>Lets demonstrate this workflow via a simplified example.</p>
</div>
<div class="paragraph">
<p>Lets say we want to index the following percolator query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "query" : {
    "match" : {
      "body" : {
        "query" : "missing bicycles"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>with these settings and mapping:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT /test_index
{
  "settings": {
    "analysis": {
      "analyzer": {
        "my_analyzer" : {
          "tokenizer": "standard",
          "filter" : ["lowercase", "porter_stem"]
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "query" : {
        "type": "percolator"
      },
      "body" : {
        "type": "text",
        "analyzer": "my_analyzer" <b class="conum">(1)</b>
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>For the purpose of this example, this analyzer is considered expensive.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>First we need to use the analyze api to perform the text analysis prior to indexing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /test_index/_analyze
{
  "analyzer" : "my_analyzer",
  "text" : "missing bicycles"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This results the following response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "tokens": [
    {
      "token": "miss",
      "start_offset": 0,
      "end_offset": 7,
      "type": "&lt;ALPHANUM&gt;",
      "position": 0
    },
    {
      "token": "bicycl",
      "start_offset": 8,
      "end_offset": 16,
      "type": "&lt;ALPHANUM&gt;",
      "position": 1
    }
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>All the tokens in the returned order need to replace the query text in the percolator query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT /test_index/_doc/1?refresh
{
  "query" : {
    "match" : {
      "body" : {
        "query" : "miss bicycl",
        "analyzer" : "whitespace" <b class="conum">(1)</b>
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>It is important to select a whitespace analyzer here, otherwise the analyzer defined in the mapping will be used,
which defeats the point of using this workflow. Note that <code>whitespace</code> is a built-in analyzer, if a different analyzer
needs to be used, it needs to be configured first in the index&#8217;s settings.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The analyze api prior to the indexing the percolator flow should be done for each percolator query.</p>
</div>
<div class="paragraph">
<p>At percolate time nothing changes and the <code>percolate</code> query can be defined normally:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /test_index/_search
{
  "query": {
    "percolate" : {
      "field" : "query",
      "document" : {
        "body" : "Bycicles are missing"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This results in a response like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "took": 6,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped" : 0,
    "failed": 0
  },
  "hits": {
    "total" : {
        "value": 1,
        "relation": "eq"
    },
    "max_score": 0.13076457,
    "hits": [
      {
        "_index": "test_index",
        "_type": "_doc",
        "_id": "1",
        "_score": 0.13076457,
        "_source": {
          "query": {
            "match": {
              "body": {
                "query": "miss bicycl",
                "analyzer": "whitespace"
              }
            }
          }
        },
        "fields" : {
          "_percolator_document_slot" : [0]
        }
      }
    ]
  }
}</code></pre>
</div>
</div>
<h4 id="_optimizing_wildcard_queries" class="discrete">Optimizing wildcard queries.</h4>
<div class="paragraph">
<p>Wildcard queries are  more expensive than other queries for the percolator,
especially if the wildcard expressions are large.</p>
</div>
<div class="paragraph">
<p>In the case of <code>wildcard</code> queries with prefix wildcard expressions or just the <code>prefix</code> query,
the <code>edge_ngram</code> token filter can be used to replace these queries with regular <code>term</code>
query on a field where the <code>edge_ngram</code> token filter is configured.</p>
</div>
<div class="paragraph">
<p>Creating an index with custom analysis settings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my_queries1
{
  "settings": {
    "analysis": {
      "analyzer": {
        "wildcard_prefix": { <b class="conum">(1)</b>
          "type": "custom",
          "tokenizer": "standard",
          "filter": [
            "lowercase",
            "wildcard_edge_ngram"
          ]
        }
      },
      "filter": {
        "wildcard_edge_ngram": { <b class="conum">(2)</b>
          "type": "edge_ngram",
          "min_gram": 1,
          "max_gram": 32
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "query": {
        "type": "percolator"
      },
      "my_field": {
        "type": "text",
        "fields": {
          "prefix": { <b class="conum">(3)</b>
            "type": "text",
            "analyzer": "wildcard_prefix",
            "search_analyzer": "standard"
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The analyzer that generates the prefix tokens to be used at index time only.</p>
</li>
<li>
<p>Increase the <code>min_gram</code> and decrease <code>max_gram</code> settings based on your prefix search needs.</p>
</li>
<li>
<p>This multifield should be used to do the prefix search
with a <code>term</code> or <code>match</code> query instead of a <code>prefix</code> or <code>wildcard</code> query.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Then instead of indexing the following query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "query": {
    "wildcard": {
      "my_field": "abc*"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>this query below should be indexed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT /my_queries1/_doc/1?refresh
{
  "query": {
    "term": {
      "my_field.prefix": "abc"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This way can handle the second query more efficiently than the first query.</p>
</div>
<div class="paragraph">
<p>The following search request will match with the previously indexed
percolator query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /my_queries1/_search
{
  "query": {
    "percolate": {
      "field": "query",
      "document": {
        "my_field": "abcd"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "took": 6,
  "timed_out": false,
  "_shards": {
    "total": 1,
    "successful": 1,
    "skipped": 0,
    "failed": 0
  },
  "hits": {
    "total" : {
        "value": 1,
        "relation": "eq"
    },
    "max_score": 0.18864399,
    "hits": [
      {
        "_index": "my_queries1",
        "_type": "_doc",
        "_id": "1",
        "_score": 0.18864399,
        "_source": {
          "query": {
            "term": {
              "my_field.prefix": "abc"
            }
          }
        },
        "fields": {
          "_percolator_document_slot": [
            0
          ]
        }
      }
    ]
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same technique can also be used to speed up suffix
wildcard searches. By using the <code>reverse</code> token filter
before the <code>edge_ngram</code> token filter.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my_queries2
{
  "settings": {
    "analysis": {
      "analyzer": {
        "wildcard_suffix": {
          "type": "custom",
          "tokenizer": "standard",
          "filter": [
            "lowercase",
            "reverse",
            "wildcard_edge_ngram"
          ]
        },
        "wildcard_suffix_search_time": {
          "type": "custom",
          "tokenizer": "standard",
          "filter": [
            "lowercase",
            "reverse"
          ]
        }
      },
      "filter": {
        "wildcard_edge_ngram": {
          "type": "edge_ngram",
          "min_gram": 1,
          "max_gram": 32
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "query": {
        "type": "percolator"
      },
      "my_field": {
        "type": "text",
        "fields": {
          "suffix": {
            "type": "text",
            "analyzer": "wildcard_suffix",
            "search_analyzer": "wildcard_suffix_search_time" <b class="conum">(1)</b>
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A custom analyzer is needed at search time too, because otherwise
the query terms are not being reversed and would otherwise not match
with the reserved suffix tokens.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Then instead of indexing the following query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "query": {
    "wildcard": {
      "my_field": "*xyz"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>the following query below should be indexed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT /my_queries2/_doc/2?refresh
{
  "query": {
    "match": { <b class="conum">(1)</b>
      "my_field.suffix": "xyz"
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>match</code> query should be used instead of the <code>term</code> query,
because text analysis needs to reverse the query terms.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following search request will match with the previously indexed
percolator query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /my_queries2/_search
{
  "query": {
    "percolate": {
      "field": "query",
      "document": {
        "my_field": "wxyz"
      }
    }
  }
}</code></pre>
</div>
</div>
<h4 id="_dedicated_percolator_index" class="discrete">Dedicated Percolator Index</h4>
<div class="paragraph">
<p>Percolate queries can be added to any index. Instead of adding percolate queries to the index the data resides in,
these queries can also be added to a dedicated index. The advantage of this is that this dedicated percolator index
can have its own index settings (For example the number of primary and replica shards). If you choose to have a dedicated
percolate index, you need to make sure that the mappings from the normal index are also available on the percolate index.
Otherwise percolate queries can be parsed incorrectly.</p>
</div>
<h4 id="_forcing_unmapped_fields_to_be_handled_as_strings" class="discrete">Forcing Unmapped Fields to be Handled as Strings</h4>
<div class="paragraph">
<p>In certain cases it is unknown what kind of percolator queries do get registered, and if no field mapping exists for fields
that are referred by percolator queries then adding a percolator query fails. This means the mapping needs to be updated
to have the field with the appropriate settings, and then the percolator query can be added. But sometimes it is sufficient
if all unmapped fields are handled as if these were default text fields. In those cases one can configure the
<code>index.percolator.map_unmapped_fields_as_text</code> setting to <code>true</code> (default to <code>false</code>) and then if a field referred in
a percolator query does not exist, it will be handled as a default text field so that adding the percolator query doesn&#8217;t
fail.</p>
</div>
<h4 id="_limitations" class="discrete">Limitations</h4>
<h5 id="parent-child" class="discrete">Parent/child</h5>
<div class="paragraph">
<p>Because the <code>percolate</code> query is processing one document at a time, it doesn&#8217;t support queries and filters that run
against child documents such as <code>has_child</code> and <code>has_parent</code>.</p>
</div>
<h5 id="_fetching_queries" class="discrete">Fetching queries</h5>
<div class="paragraph">
<p>There are a number of queries that fetch data via a get call during query parsing. For example the <code>terms</code> query when
using terms lookup, <code>template</code> query when using indexed scripts and <code>geo_shape</code> when using pre-indexed shapes. When these
queries are indexed by the <code>percolator</code> field type then the get call is executed once. So each time the <code>percolator</code>
query evaluates these queries, the fetches terms, shapes etc. as the were upon index time will be used. Important to note
is that fetching of terms that these queries do, happens both each time the percolator query gets indexed on both primary
and replica shards, so the terms that are actually indexed can be different between shard copies, if the source index
changed while indexing.</p>
</div>
<h5 id="_script_query" class="discrete">Script query</h5>
<div class="paragraph">
<p>The script inside a <code>script</code> query can only access doc values fields. The <code>percolate</code> query indexes the provided document
into an in-memory index. This in-memory index doesn&#8217;t support stored fields and because of that the <code>_source</code> field and
other stored fields are not stored. This is the reason why in the <code>script</code> query the <code>_source</code> and other stored fields
aren&#8217;t available.</p>
</div>
<h5 id="_field_aliases" class="discrete">Field aliases</h5>
<div class="paragraph">
<p>Percolator queries that contain <a href="mapping-types.html#alias">field aliases</a> may not always behave as expected. In particular, if a
percolator query is registered that contains a field alias, and then that alias is updated in the mappings to refer
to a different field, the stored query will still refer to the original target field. To pick up the change to
the field alias, the percolator query must be explicitly reindexed.</p>
</div>
</div>
<div class="sect2">
<h3 id="range">Range field types</h3>
<titleabbrev>Range</titleabbrev>
<div class="paragraph">
<p>Range field types represent a continuous range of values between an upper and lower
bound. For example, a range can represent <em>any date in October</em> or <em>any
integer from 0 to 9</em>. They are defined using the operators
<code>gt</code> or <code>gte</code> for the lower bound, and <code>lt</code> or <code>lte</code> for the upper bound.
They can be used for querying, and have
limited support for aggregations. The only supported aggregations are
<a href="https://www.opensearch.org/guide/en/opensearch/reference/{branch}/search-aggregations-bucket-histogram-aggregation.html">histogram</a>,
<a href="https://www.opensearch.org/guide/en/opensearch/reference/{branch}/search-aggregations-metrics-cardinality-aggregation.html">cardinality</a>.</p>
</div>
<div class="paragraph">
<p>The following range types are supported:</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>integer_range</code>
</td>
<td class="hdlist2">
<p>A range of signed 32-bit integers with a minimum value of -2^31^ and maximum of 2^31^-1.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>float_range</code>
</td>
<td class="hdlist2">
<p>A range of single-precision 32-bit IEEE 754 floating point values.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>long_range</code>
</td>
<td class="hdlist2">
<p>A range of signed 64-bit integers with a minimum value of -2^63^ and maximum of 2^63^-1.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>double_range</code>
</td>
<td class="hdlist2">
<p>A range of double-precision 64-bit IEEE 754 floating point values.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>date_range</code>
</td>
<td class="hdlist2">
<p>A range of <a href="mapping-types.html#date"><code>date</code></a> values. Date ranges support various date formats
through the <a href="mapping-params.html#mapping-date-format"><code>format</code></a> mapping parameter. Regardless of
the format used, date values are parsed into an unsigned 64-bit integer
representing milliseconds since the Unix epoch in UTC. Values containing the
<code>now</code> <a href="api-conventions.html#date-math">date math</a> expression are not supported.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>ip_range</code> 
</td>
<td class="hdlist2">
<p>A range of ip values supporting either <a href="https://en.wikipedia.org/wiki/IPv4">IPv4</a> or
<a href="https://en.wikipedia.org/wiki/IPv6">IPv6</a> (or mixed) addresses.</p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Below is an example of configuring a mapping with various range fields followed by an example that indexes several range types.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT range_index
{
  "settings": {
    "number_of_shards": 2
  },
  "mappings": {
    "properties": {
      "expected_attendees": {
        "type": "integer_range"
      },
      "time_frame": {
        "type": "date_range", <b class="conum">(1)</b>
        "format": "yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis"
      }
    }
  }
}

PUT range_index/_doc/1?refresh
{
  "expected_attendees" : { <b class="conum">(2)</b>
    "gte" : 10,
    "lt" : 20
  },
  "time_frame" : {
    "gte" : "2015-10-31 12:00:00", <b class="conum">(3)</b>
    "lte" : "2015-11-01"
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>date_range</code> types accept the same field parameters defined by the <a href="mapping-types.html#date"><code>date</code></a> type.</p>
</li>
<li>
<p>Example indexing a meeting with 10 to 20 attendees, not including 20.</p>
</li>
<li>
<p>Example date range using date time stamp.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following is an example of a <a href="term-level-queries.html#query-dsl-term-query">term query</a> on the <code>integer_range</code> field named "expected_attendees".
12 is a value inside the range, so it will match.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET range_index/_search
{
  "query" : {
    "term" : {
      "expected_attendees" : {
        "value": 12
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result produced by the above query.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "took": 13,
  "timed_out": false,
  "_shards" : {
    "total": 2,
    "successful": 2,
    "skipped" : 0,
    "failed": 0
  },
  "hits" : {
    "total" : {
        "value": 1,
        "relation": "eq"
    },
    "max_score" : 1.0,
    "hits" : [
      {
        "_index" : "range_index",
        "_type" : "_doc",
        "_id" : "1",
        "_score" : 1.0,
        "_source" : {
          "expected_attendees" : {
            "gte" : 10, "lt" : 20
          },
          "time_frame" : {
            "gte" : "2015-10-31 12:00:00", "lte" : "2015-11-01"
          }
        }
      }
    ]
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is an example of a <code>date_range</code> query over the <code>date_range</code> field named "time_frame".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET range_index/_search
{
  "query" : {
    "range" : {
      "time_frame" : { <b class="conum">(1)</b>
        "gte" : "2015-10-31",
        "lte" : "2015-11-01",
        "relation" : "within" <b class="conum">(2)</b>
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Range queries work the same as described in <a href="term-level-queries.html#query-dsl-range-query">range query</a>.</p>
</li>
<li>
<p>Range queries over range <a href="mapping-types.html">fields</a> support a <code>relation</code> parameter which can be one of <code>WITHIN</code>, <code>CONTAINS</code>,
<code>INTERSECTS</code> (default).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This query produces a similar result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "took": 13,
  "timed_out": false,
  "_shards" : {
    "total": 2,
    "successful": 2,
    "skipped" : 0,
    "failed": 0
  },
  "hits" : {
    "total" : {
        "value": 1,
        "relation": "eq"
    },
    "max_score" : 1.0,
    "hits" : [
      {
        "_index" : "range_index",
        "_type" : "_doc",
        "_id" : "1",
        "_score" : 1.0,
        "_source" : {
          "expected_attendees" : {
            "gte" : 10, "lt" : 20
          },
          "time_frame" : {
            "gte" : "2015-10-31 12:00:00", "lte" : "2015-11-01"
          }
        }
      }
    ]
  }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="ip-range">IP Range</h4>
<div class="paragraph">
<p>In addition to the range format above, IP ranges can be provided in
<a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation">CIDR</a> notation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT range_index/_mapping
{
  "properties": {
    "ip_allowlist": {
      "type": "ip_range"
    }
  }
}

PUT range_index/_doc/2
{
  "ip_allowlist" : "192.168.0.0/16"
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="range-params">Parameters for range fields</h4>
<div class="paragraph">
<p>The following parameters are accepted by range types:</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#coerce"><code>coerce</code></a>
</td>
<td class="hdlist2">
<p>Try to convert strings to numbers and truncate fractions for integers.
Accepts <code>true</code> (default) and <code>false</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-boost"><code>boost</code></a>
</td>
<td class="hdlist2">
<p>Mapping field-level query time boosting. Accepts a floating point number, defaults
to <code>1.0</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-index"><code>index</code></a>
</td>
<td class="hdlist2">
<p>Should the field be searchable? Accepts <code>true</code> (default) and <code>false</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-store"><code>store</code></a>
</td>
<td class="hdlist2">
<p>Whether the field value should be stored and retrievable separately from
the <a href="mapping-fields.html#mapping-source-field"><code>_source</code></a> field. Accepts <code>true</code> or <code>false</code>
(default).</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rank-feature">Rank feature field type</h3>
<titleabbrev>Rank feature</titleabbrev>
<div class="paragraph">
<p>A <code>rank_feature</code> field can index numbers so that they can later be used to boost
documents in queries with a <a href="specialized-queries.html#query-dsl-rank-feature-query"><code>rank_feature</code></a> query.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001
{
  "mappings": {
    "properties": {
      "pagerank": {
        "type": "rank_feature" <b class="conum">(1)</b>
      },
      "url_length": {
        "type": "rank_feature",
        "positive_score_impact": false <b class="conum">(2)</b>
      }
    }
  }
}

PUT my-index-000001/_doc/1
{
  "pagerank": 8,
  "url_length": 22
}

GET my-index-000001/_search
{
  "query": {
    "rank_feature": {
      "field": "pagerank"
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Rank feature fields must use the <code>rank_feature</code> field type</p>
</li>
<li>
<p>Rank features that correlate negatively with the score need to declare it</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>rank_feature</code> fields only support single-valued fields and strictly positive
values. Multi-valued fields and negative values will be rejected.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>rank_feature</code> fields do not support querying, sorting or aggregating. They may
only be used within <a href="specialized-queries.html#query-dsl-rank-feature-query"><code>rank_feature</code></a> queries.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>rank_feature</code> fields only preserve 9 significant bits for the precision, which
translates to a relative error of about 0.4%.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Rank features that correlate negatively with the score should set
<code>positive_score_impact</code> to <code>false</code> (defaults to <code>true</code>). This will be used by
the <a href="specialized-queries.html#query-dsl-rank-feature-query"><code>rank_feature</code></a> query to modify the scoring formula
in such a way that the score decreases with the value of the feature instead of
increasing. For instance in web search, the url length is a commonly used
feature which correlates negatively with scores.</p>
</div>
</div>
<div class="sect2">
<h3 id="rank-features">Rank features field type</h3>
<titleabbrev>Rank features</titleabbrev>
<div class="paragraph">
<p>A <code>rank_features</code> field can index numeric feature vectors, so that they can
later be used to boost documents in queries with a
<a href="specialized-queries.html#query-dsl-rank-feature-query"><code>rank_feature</code></a> query.</p>
</div>
<div class="paragraph">
<p>It is analogous to the <a href="mapping-types.html#rank-feature"><code>rank_feature</code></a> data type but is better suited
when the list of features is sparse so that it wouldn&#8217;t be reasonable to add
one field to the mappings for each of them.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001
{
  "mappings": {
    "properties": {
      "topics": {
        "type": "rank_features" <b class="conum">(1)</b>
      }
    }
  }
}

PUT my-index-000001/_doc/1
{
  "topics": { <b class="conum">(2)</b>
    "politics": 20,
    "economics": 50.8
  }
}

PUT my-index-000001/_doc/2
{
  "topics": {
    "politics": 5.2,
    "sports": 80.1
  }
}

GET my-index-000001/_search
{
  "query": {
    "rank_feature": {
      "field": "topics.politics"
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Rank features fields must use the <code>rank_features</code> field type</p>
</li>
<li>
<p>Rank features fields must be a hash with string keys and strictly positive numeric values</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>rank_features</code> fields only support single-valued features and strictly
positive values. Multi-valued fields and zero or negative values will be rejected.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>rank_features</code> fields do not support sorting or aggregating and may
only be queried using <a href="specialized-queries.html#query-dsl-rank-feature-query"><code>rank_feature</code></a> queries.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>rank_features</code> fields only preserve 9 significant bits for the
precision, which translates to a relative error of about 0.4%.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="search-as-you-type">Search-as-you-type field type</h3>
<titleabbrev>Search-as-you-type</titleabbrev>
<div class="paragraph">
<p>The <code>search_as_you_type</code> field type is a text-like field that is optimized to
provide out-of-the-box support for queries that serve an as-you-type completion
use case. It creates a series of subfields that are analyzed to index terms
that can be efficiently matched by a query that partially matches the entire
indexed text value. Both prefix completion (i.e matching terms starting at the
beginning of the input) and infix completion (i.e. matching terms at any
position within the input) are supported.</p>
</div>
<div class="paragraph">
<p>When adding a field of this type to a mapping</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001
{
  "mappings": {
    "properties": {
      "my_field": {
        "type": "search_as_you_type"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This creates the following fields</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>my_field</code>
</td>
<td class="hdlist2">
<p>Analyzed as configured in the mapping. If an analyzer is not configured,
the default analyzer for the index is used</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>my_field._2gram</code>
</td>
<td class="hdlist2">
<p>Wraps the analyzer of <code>my_field</code> with a shingle token filter of shingle
size 2</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>my_field._3gram</code>
</td>
<td class="hdlist2">
<p>Wraps the analyzer of <code>my_field</code> with a shingle token filter of shingle
size 3</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>my_field._index_prefix</code>
</td>
<td class="hdlist2">
<p>Wraps the analyzer of <code>my_field._3gram</code> with an edge ngram token filter</p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The size of shingles in subfields can be configured with the <code>max_shingle_size</code>
mapping parameter. The default is 3, and valid values for this parameter are
integer values 2 - 4 inclusive. Shingle subfields will be created for each
shingle size from 2 up to and including the <code>max_shingle_size</code>. The
<code>my_field._index_prefix</code> subfield will always use the analyzer from the shingle
subfield with the <code>max_shingle_size</code> when constructing its own analyzer.</p>
</div>
<div class="paragraph">
<p>Increasing the <code>max_shingle_size</code> will improve matches for queries with more
consecutive terms, at the cost of larger index size. The default
<code>max_shingle_size</code> should usually be sufficient.</p>
</div>
<div class="paragraph">
<p>The same input text is indexed into each of these fields automatically, with
their differing analysis chains, when an indexed document has a value for the
root field <code>my_field</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001/_doc/1?refresh
{
  "my_field": "quick brown fox jump lazy dog"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The most efficient way of querying to serve a search-as-you-type use case is
usually a <a href="full-text-queries.html#query-dsl-multi-match-query"><code>multi_match</code></a> query of type
<a href="full-text-queries.html#query-dsl-match-bool-prefix-query"><code>bool_prefix</code></a> that targets the root
<code>search_as_you_type</code> field and its shingle subfields. This can match the query
terms in any order, but will score documents higher if they contain the terms
in order in a shingle subfield.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET my-index-000001/_search
{
  "query": {
    "multi_match": {
      "query": "brown f",
      "type": "bool_prefix",
      "fields": [
        "my_field",
        "my_field._2gram",
        "my_field._3gram"
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "took" : 44,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1,
      "relation" : "eq"
    },
    "max_score" : 0.8630463,
    "hits" : [
      {
        "_index" : "my-index-000001",
        "_type" : "_doc",
        "_id" : "1",
        "_score" : 0.8630463,
        "_source" : {
          "my_field" : "quick brown fox jump lazy dog"
        }
      }
    ]
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To search for documents that strictly match the query terms in order, or to
search using other properties of phrase queries, use a
<a href="full-text-queries.html#query-dsl-match-query-phrase-prefix"><code>match_phrase_prefix</code> query</a> on the root
field. A <a href="full-text-queries.html#query-dsl-match-query-phrase"><code>match_phrase</code> query</a> can also be used
if the last term should be matched exactly, and not as a prefix. Using phrase
queries may be less efficient than using the <code>match_bool_prefix</code> query.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET my-index-000001/_search
{
  "query": {
    "match_phrase_prefix": {
      "my_field": "brown f"
    }
  }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="specific-params">Parameters specific to the <code>search_as_you_type</code> field</h4>
<div class="paragraph">
<p>The following parameters are accepted in a mapping for the <code>search_as_you_type</code>
field and are specific to this field type</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>max_shingle_size</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, integer)
Largest shingle size to create. Valid values are <code>2</code> (inclusive) to <code>4</code>
(inclusive). Defaults to <code>3</code>.</p>
</div>
<div class="paragraph">
<p>A subfield is created for each integer between <code>2</code> and this value. For example,
a value of <code>3</code> creates two subfields: <code>my_field._2gram</code> and <code>my_field._3gram</code></p>
</div>
<div class="paragraph">
<p>More subfields enables more specific queries but increases index size.</p>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="general-params">Parameters of the field type as a text field</h4>
<div class="paragraph">
<p>The following parameters are accepted in a mapping for the <code>search_as_you_type</code>
field due to its nature as a text-like field, and behave similarly to their
behavior when configuring a field of the <a href="mapping-types.html#text"><code>text</code></a> data type. Unless
otherwise noted, these options configure the root fields subfields in
the same way.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="mapping-params.html#analyzer"><code>analyzer</code></a></dt>
<dd>
<p>The <a href="analysis.html">analyzer</a> which should be used for
<code>text</code> fields, both at index-time and at
search-time (unless overridden by the
<a href="mapping-params.html#search-analyzer"><code>search_analyzer</code></a>). Defaults to the default index
analyzer, or the <a href="analysis-analyzers.html#analysis-standard-analyzer"><code>standard</code> analyzer</a>.</p>
</dd>
<dt class="hdlist1"><a href="mapping-params.html#mapping-index"><code>index</code></a></dt>
<dd>
<p>Should the field be searchable? Accepts <code>true</code> (default) or <code>false</code>.</p>
</dd>
<dt class="hdlist1"><a href="mapping-params.html#index-options"><code>index_options</code></a></dt>
<dd>
<p>What information should be stored in the index, for search and highlighting
purposes. Defaults to <code>positions</code>.</p>
</dd>
<dt class="hdlist1"><a href="mapping-params.html#norms"><code>norms</code></a></dt>
<dd>
<p>Whether field-length should be taken into account when scoring queries.
Accepts <code>true</code> or <code>false</code>. This option configures the root field
and shingle subfields, where its default is <code>true</code>. It does not configure
the prefix subfield, where it it <code>false</code>.</p>
</dd>
<dt class="hdlist1"><a href="mapping-params.html#mapping-store"><code>store</code></a></dt>
<dd>
<p>Whether the field value should be stored and retrievable separately from
the <a href="mapping-fields.html#mapping-source-field"><code>_source</code></a> field. Accepts <code>true</code> or <code>false</code>
(default). This option only configures the root field, and does not
configure any subfields.</p>
</dd>
<dt class="hdlist1"><a href="mapping-params.html#search-analyzer"><code>search_analyzer</code></a></dt>
<dd>
<p>The <a href="mapping-params.html#analyzer"><code>analyzer</code></a> that should be used at search time on
<a href="mapping-types.html#text"><code>text</code></a> fields. Defaults to the <code>analyzer</code> setting.</p>
</dd>
<dt class="hdlist1"><a href="mapping-params.html#search-quote-analyzer"><code>search_quote_analyzer</code></a></dt>
<dd>
<p>The <a href="mapping-params.html#analyzer"><code>analyzer</code></a> that should be used at search time when a
phrase is encountered. Defaults to the <code>search_analyzer</code> setting.</p>
</dd>
<dt class="hdlist1"><a href="mapping-params.html#similarity"><code>similarity</code></a></dt>
<dd>
<p>Which scoring algorithm or <em>similarity</em> should be used. Defaults
to <code>BM25</code>.</p>
</dd>
<dt class="hdlist1"><a href="mapping-params.html#term-vector"><code>term_vector</code></a></dt>
<dd>
<p>Whether term vectors should be stored for the field. Defaults to <code>no</code>. This option configures the root field and shingle
subfields, but not the prefix subfield.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="prefix-queries">Optimization of prefix queries</h4>
<div class="paragraph">
<p>When making a <a href="term-level-queries.html#query-dsl-prefix-query"><code>prefix</code></a> query to the root field or
any of its subfields, the query will be rewritten to a
<a href="term-level-queries.html#query-dsl-term-query"><code>term</code></a> query on the <code>._index_prefix</code> subfield. This
matches more efficiently than is typical of <code>prefix</code> queries on text fields,
as prefixes up to a certain length of each shingle are indexed directly as
terms in the <code>._index_prefix</code> subfield.</p>
</div>
<div class="paragraph">
<p>The analyzer of the <code>._index_prefix</code> subfield slightly modifies the
shingle-building behavior to also index prefixes of the terms at the end of the
field&#8217;s value that normally would not be produced as shingles. For example, if
the value <code>quick brown fox</code> is indexed into a <code>search_as_you_type</code> field with
<code>max_shingle_size</code> of 3, prefixes for <code>brown fox</code> and <code>fox</code> are also indexed
into the <code>._index_prefix</code> subfield even though they do not appear as terms in
the <code>._3gram</code> subfield. This allows for completion of all the terms in the
field&#8217;s input.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="text">Text field type</h3>
<titleabbrev>Text</titleabbrev>
<div class="paragraph">
<p>A field to index full-text values, such as the body of an email or the
description of a product. These fields are <code>analyzed</code>, that is they are passed through an
<a href="analysis.html">analyzer</a> to convert the string into a list of individual terms
before being indexed. The analysis process allows OpenSearch to search for
individual words <em>within</em>  each full text field.  Text fields are not
used for sorting and seldom used for aggregations (although the
<a href="search-aggregations-bucket.html#search-aggregations-bucket-significanttext-aggregation">significant text aggregation</a>
is a notable exception).</p>
</div>
<div class="paragraph">
<p>If you need to index structured content such as email addresses, hostnames, status
codes, or tags, it is likely that you should rather use a <a href="mapping-types.html#keyword"><code>keyword</code></a> field.</p>
</div>
<div class="paragraph">
<p>Below is an example of a mapping for a text field:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001
{
  "mappings": {
    "properties": {
      "full_name": {
        "type":  "text"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="text-multi-fields">Use a field as both text and keyword</h4>
<div class="paragraph">
<p>Sometimes it is useful to have both a full text (<code>text</code>) and a keyword
(<code>keyword</code>) version of the same field: one for full text search and the
other for aggregations and sorting. This can be achieved with
<a href="mapping-params.html#multi-fields">multi-fields</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="text-params">Parameters for text fields</h4>
<div class="paragraph">
<p>The following parameters are accepted by <code>text</code> fields:</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#analyzer"><code>analyzer</code></a>
</td>
<td class="hdlist2">
<p>The <a href="analysis.html">analyzer</a> which should be used for
the <code>text</code> field, both at index-time and at
search-time (unless overridden by the  <a href="mapping-params.html#search-analyzer"><code>search_analyzer</code></a>).
Defaults to the default index analyzer, or the
<a href="analysis-analyzers.html#analysis-standard-analyzer"><code>standard</code> analyzer</a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-boost"><code>boost</code></a>
</td>
<td class="hdlist2">
<p>Mapping field-level query time boosting. Accepts a floating point number, defaults
to <code>1.0</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#eager-global-ordinals"><code>eager_global_ordinals</code></a>
</td>
<td class="hdlist2">
<p>Should global ordinals be loaded eagerly on refresh? Accepts <code>true</code> or <code>false</code>
(default). Enabling this is a good idea on fields that are frequently used for
(significant) terms aggregations.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="getting-started-modify-data.html#fielddata"><code>fielddata</code></a>
</td>
<td class="hdlist2">
<p>Can the field use in-memory fielddata for sorting, aggregations,
or scripting? Accepts <code>true</code> or <code>false</code> (default).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-types.html#field-data-filtering"><code>fielddata_frequency_filter</code></a>
</td>
<td class="hdlist2">
<p>Expert settings which allow to decide which values to load in memory when <code>fielddata</code>
is enabled. By default all values are loaded.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#multi-fields"><code>fields</code></a>
</td>
<td class="hdlist2">
<p>Multi-fields allow the same string value to be indexed in multiple ways for
different purposes, such as one field for search and a multi-field for
sorting and aggregations, or the same string value analyzed by different
analyzers.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-index"><code>index</code></a>
</td>
<td class="hdlist2">
<p>Should the field be searchable? Accepts <code>true</code> (default) or <code>false</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#index-options"><code>index_options</code></a>
</td>
<td class="hdlist2">
<p>What information should be stored in the index, for search and highlighting purposes.
Defaults to <code>positions</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#index-prefixes"><code>index_prefixes</code></a>
</td>
<td class="hdlist2">
<p>If enabled, term prefixes of between 2 and 5 characters are indexed into a
separate field.  This allows prefix searches to run more efficiently, at
the expense of a larger index.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#index-phrases"><code>index_phrases</code></a>
</td>
<td class="hdlist2">
<p>If enabled, two-term word combinations ('shingles') are indexed into a separate
field.  This allows exact phrase queries (no slop) to run more efficiently, at the expense
of a larger index.  Note that this works best when stopwords are not removed,
as phrases containing stopwords will not use the subsidiary field and will fall
back to a standard phrase query.  Accepts <code>true</code> or <code>false</code> (default).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#norms"><code>norms</code></a>
</td>
<td class="hdlist2">
<p>Whether field-length should be taken into account when scoring queries.
Accepts <code>true</code> (default) or <code>false</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#position-increment-gap"><code>position_increment_gap</code></a>
</td>
<td class="hdlist2">
<p>The number of fake term position which should be inserted between each
element of an array of strings. Defaults to the <code>position_increment_gap</code>
configured on the analyzer which defaults to <code>100</code>. <code>100</code> was chosen because it
prevents phrase queries with reasonably large slops (less than 100) from
matching terms across field values.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-store"><code>store</code></a>
</td>
<td class="hdlist2">
<p>Whether the field value should be stored and retrievable separately from
the <a href="mapping-fields.html#mapping-source-field"><code>_source</code></a> field. Accepts <code>true</code> or <code>false</code>
(default).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#search-analyzer"><code>search_analyzer</code></a>
</td>
<td class="hdlist2">
<p>The <a href="mapping-params.html#analyzer"><code>analyzer</code></a> that should be used at search time on
the <code>text</code> field. Defaults to the <code>analyzer</code> setting.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#search-quote-analyzer"><code>search_quote_analyzer</code></a>
</td>
<td class="hdlist2">
<p>The <a href="mapping-params.html#analyzer"><code>analyzer</code></a> that should be used at search time when a
phrase is encountered. Defaults to the <code>search_analyzer</code> setting.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#similarity"><code>similarity</code></a>
</td>
<td class="hdlist2">
<p>Which scoring algorithm or <em>similarity</em> should be used. Defaults
to <code>BM25</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#term-vector"><code>term_vector</code></a>
</td>
<td class="hdlist2">
<p>Whether term vectors should be stored for the field. Defaults to <code>no</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-field-meta"><code>meta</code></a>
</td>
<td class="hdlist2">
<p>Metadata about the field.</p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="fielddata-mapping-param"><code>fielddata</code> mapping parameter</h4>
<div class="paragraph">
<p><code>text</code> fields are searchable by default, but by default are not available for
aggregations, sorting, or scripting. If you try to sort, aggregate, or access
values from a script on a <code>text</code> field, you will see this exception:</p>
</div>
<div class="paragraph">
<p>Fielddata is disabled on text fields by default.  Set <code>fielddata=true</code> on
<code>your_field_name</code> in order to load fielddata in memory by uninverting the
inverted index. Note that this can however use significant memory.</p>
</div>
<div class="paragraph">
<p>Field data is the only way to access the analyzed tokens from a full text field
in aggregations, sorting, or scripting. For example, a full text field like <code>New York</code>
would get analyzed as <code>new</code> and <code>york</code>. To aggregate on these tokens requires field data.</p>
</div>
</div>
<div class="sect3">
<h4 id="before-enabling-fielddata">Before enabling fielddata</h4>
<div class="paragraph">
<p>It usually doesn&#8217;t make sense to enable fielddata on text fields. Field data
is stored in the heap with the <a href="settings.html#modules-fielddata">field data cache</a> because it
is expensive to calculate. Calculating the field data can cause latency spikes, and
increasing heap usage is a cause of cluster performance issues.</p>
</div>
<div class="paragraph">
<p>Most users who want to do more with text fields use <a href="mapping-params.html#multi-fields">multi-field mappings</a>
by having both a <code>text</code> field for full text searches, and an
unanalyzed <a href="mapping-types.html#keyword"><code>keyword</code></a> field for aggregations, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001
{
  "mappings": {
    "properties": {
      "my_field": { <b class="conum">(1)</b>
        "type": "text",
        "fields": {
          "keyword": { <b class="conum">(2)</b>
            "type": "keyword"
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Use the <code>my_field</code> field for searches.</p>
</li>
<li>
<p>Use the <code>my_field.keyword</code> field for aggregations, sorting, or in scripts.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="enable-fielddata-text-fields">Enabling fielddata on <code>text</code> fields</h4>
<div class="paragraph">
<p>You can enable fielddata on an existing <code>text</code> field using the
<a href="indices.html#indices-put-mapping">PUT mapping API</a> as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001/_mapping
{
  "properties": {
    "my_field": { <b class="conum">(1)</b>
      "type":     "text",
      "fielddata": true
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The mapping that you specify for <code>my_field</code> should consist of the existing
mapping for that field, plus the <code>fielddata</code> parameter.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="field-data-filtering"><code>fielddata_frequency_filter</code> mapping parameter</h4>
<div class="paragraph">
<p>Fielddata filtering can be used to reduce the number of terms loaded into
memory, and thus reduce memory usage. Terms can be filtered by <em>frequency</em>:</p>
</div>
<div class="paragraph">
<p>The frequency filter allows you to only load terms whose document frequency falls
between a <code>min</code> and <code>max</code> value, which can be expressed an absolute
number (when the number is bigger than 1.0) or as a percentage
(eg <code>0.01</code> is <code>1%</code> and <code>1.0</code> is <code>100%</code>). Frequency is calculated
<strong>per segment</strong>. Percentages are based on the number of docs which have a
value for the field, as opposed to all docs in the segment.</p>
</div>
<div class="paragraph">
<p>Small segments can be excluded completely by specifying the minimum
number of docs that the segment should contain with <code>min_segment_size</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001
{
  "mappings": {
    "properties": {
      "tag": {
        "type": "text",
        "fielddata": true,
        "fielddata_frequency_filter": {
          "min": 0.001,
          "max": 0.1,
          "min_segment_size": 500
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="token-count">Token count field type</h3>
<titleabbrev>Token count</titleabbrev>
<div class="paragraph">
<p>A field of type <code>token_count</code> is really an <a href="mapping-types.html#number"><code>integer</code></a> field which
accepts string values, analyzes them, then indexes the number of tokens in the
string.</p>
</div>
<div class="paragraph">
<p>For instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001
{
  "mappings": {
    "properties": {
      "name": { <b class="conum">(1)</b>
        "type": "text",
        "fields": {
          "length": { <b class="conum">(2)</b>
            "type":     "token_count",
            "analyzer": "standard"
          }
        }
      }
    }
  }
}

PUT my-index-000001/_doc/1
{ "name": "John Smith" }

PUT my-index-000001/_doc/2
{ "name": "Rachel Alice Williams" }

GET my-index-000001/_search
{
  "query": {
    "term": {
      "name.length": 3 <b class="conum">(3)</b>
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>name</code> field is a <a href="mapping-types.html#text"><code>text</code></a> field which uses the default
<code>standard</code> analyzer.</p>
</li>
<li>
<p>The <code>name.length</code> field is a <code>token_count</code> <a href="mapping-params.html#multi-fields">multi-field</a> which will index the number of tokens in the <code>name</code> field.</p>
</li>
<li>
<p>This query matches only the document containing <code>Rachel Alice Williams</code>, as it contains three tokens.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="token-count-params">Parameters for <code>token_count</code> fields</h4>
<div class="paragraph">
<p>The following parameters are accepted by <code>token_count</code> fields:</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#analyzer"><code>analyzer</code></a>
</td>
<td class="hdlist2">
<p>The <a href="analysis.html">analyzer</a> which should be used to analyze the string
value. Required. For best performance, use an analyzer without token
filters.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>enable_position_increments</code>
</td>
<td class="hdlist2">
<p>Indicates if position increments should be counted.
Set to <code>false</code> if you don&#8217;t want to count tokens removed by analyzer filters (like <a href="analysis-tokenfilters.html#analysis-stop-tokenfilter"><code>stop</code></a>).
Defaults to <code>true</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-boost"><code>boost</code></a>
</td>
<td class="hdlist2">
<p>Mapping field-level query time boosting. Accepts a floating point number, defaults
to <code>1.0</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#doc-values"><code>doc_values</code></a>
</td>
<td class="hdlist2">
<p>Should the field be stored on disk in a column-stride fashion, so that it
can later be used for sorting, aggregations, or scripting? Accepts <code>true</code>
(default) or <code>false</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-index"><code>index</code></a>
</td>
<td class="hdlist2">
<p>Should the field be searchable? Accepts <code>true</code> (default) and <code>false</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#null-value"><code>null_value</code></a>
</td>
<td class="hdlist2">
<p>Accepts a numeric value of the same <code>type</code> as the field which is
substituted for any explicit <code>null</code> values.  Defaults to <code>null</code>, which
means the field is treated as missing.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<a href="mapping-params.html#mapping-store"><code>store</code></a>
</td>
<td class="hdlist2">
<p>Whether the field value should be stored and retrievable separately from
the <a href="mapping-fields.html#mapping-source-field"><code>_source</code></a> field. Accepts <code>true</code> or <code>false</code>
(default).</p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph nav-footer">
<p>Up:<a href="mapping.html">Mapping</a>| Home:<a href="index.html">OpenSearch Reference</a>| Next:<a href="mapping-fields.html">Metadata fields</a></p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-04-12 14:08:20 -0700
</div>
</div>
</body>
</html>