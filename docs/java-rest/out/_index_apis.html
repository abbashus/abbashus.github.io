<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<title>Java REST Client</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:50%;border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<style>.toc-current{font-weight: bold;} .toc-root{font-family: "Open Sans","DejaVu Sans",sans-serif;
                       font-size: 0.9em;} #content{display: flex; flex-direction: column; flex: 1 1 auto;}
             .nav-footer{text-align: center; margin-top: auto;}
             .nav-footer > p > a {white-space: nowrap;}</style>
</head>
<body id="_index_apis" class="book toc2 toc-left">
<div id="header">
<h1>Java REST Client</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<p><span class="toc-root"><a href="index.html">Java REST Client</a></span></p><ul class="sectlevel1">
<li><a href="java-rest-overview.html">Overview</a>
</li>
<li><a href="java-rest-low.html">Java Low Level REST Client</a>
</li>
<li><a href="java-rest-high.html">Java High Level REST Client</a>
<ul class="sectlevel1">
<li><a href="java-rest-high-getting-started.html">Getting started</a>
</li>
<li><a href="java-rest-high-supported-apis.html">Document APIs</a>
</li>
<li><a href="_search_apis.html">Search APIs</a>
</li>
<li><a href="_miscellaneous_apis.html">Miscellaneous APIs</a>
</li>
<li><a href="_index_apis.html"><span class="toc-current">Index APIs</span></a>
<ul class="sectlevel2">
<li><a href="_index_apis.html#java-rest-high-analyze">Analyze API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-create-index">Create Index API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-delete-index">Delete Index API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-indices-exists">Index Exists API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-open-index">Open Index API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-close-index">Close Index API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-shrink-index">Shrink Index API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-split-index">Split Index API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-clone-index">Clone Index API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-refresh">Refresh API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-flush">Flush API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-flush-synced">Flush Synced API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-clear-cache">Clear Cache API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-force-merge">Force Merge API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-rollover-index">Rollover Index API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-put-mapping">Put Mapping API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-get-mappings">Get Mappings API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-get-field-mappings">Get Field Mappings API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-update-aliases">Index Aliases API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-delete-alias">Delete Alias API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-exists-alias">Exists Alias API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-get-alias">Get Alias API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-indices-put-settings">Update Indices Settings API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-get-settings">Get Settings API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-put-template">Put Template API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-indices-validate-query">Validate Query API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-get-templates">Get Templates API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-templates-exist">Templates Exist API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-get-index">Get Index API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-delete-template">Delete Template API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-get-index-templates-v2">Get Composable Index Templates API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-put-index-template-v2">Put Composable Index Template API</a>
</li>
<li><a href="_index_apis.html#java-rest-high-delete-index-template-v2">Delete Composable Index Template API</a>
</li>
<li><a href="_index_apis.html#_optional_arguments_43">Optional arguments</a>
</li>
<li><a href="_index_apis.html#java-rest-high-simulate-index-template">Simulate Index Template API</a>
</li>
</ul>
</li>
<li><a href="_cluster_apis.html">Cluster APIs</a>
</li>
<li><a href="_ingest_apis.html">Ingest APIs</a>
</li>
<li><a href="_snapshot_apis.html">Snapshot APIs</a>
</li>
<li><a href="_tasks_apis.html">Tasks APIs</a>
</li>
<li><a href="_script_apis.html">Script APIs</a>
</li>
<li><a href="java-rest-high-java-builders.html">Using Java Builders</a>
</li>
<li><a href="java-rest-high-level-migration.html">Migration Guide</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_index_apis">Index APIs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Java High Level REST Client supports the following Index APIs:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Index Management</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="_index_apis.html#java-rest-high-analyze">Analyze API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-create-index">Create Index API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-delete-index">Delete Index API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-indices-exists">Index Exists API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-open-index">Open Index API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-close-index">Close Index API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-shrink-index">Shrink Index API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-split-index">Split Index API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-clone-index">Clone Index API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-refresh">Refresh API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-flush">Flush API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-flush-synced">Flush Synced API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-clear-cache">Clear Cache API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-force-merge">Force Merge API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-rollover-index">Rollover Index API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-indices-put-settings">Update Indices Settings API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-get-settings">Get Settings API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-indices-validate-query">Validate Query API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-get-index">Get Index API</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Mapping Management</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="_index_apis.html#java-rest-high-put-mapping">Put Mapping API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-get-mappings">Get Mappings API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-get-field-mappings">Get Field Mappings API</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Alias Management</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="_index_apis.html#java-rest-high-update-aliases">Index Aliases API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-exists-alias">Exists Alias API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-get-alias">Get Alias API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-delete-alias">Delete Alias API</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Template Management</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="_index_apis.html#java-rest-high-get-templates">Get Templates API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-templates-exist">Templates Exist API</a></p>
</li>
<li>
<p><a href="_index_apis.html#java-rest-high-put-template">Put Template API</a></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="java-rest-high-analyze">Analyze API</h3>
<div class="sect3">
<h4 id="java-rest-high-analyze-request">Analyze Request</h4>
<div class="paragraph">
<p>An <code>AnalyzeRequest</code> contains the text to analyze, and one of several options to
specify how the analysis should be performed.</p>
</div>
<div class="paragraph">
<p>The simplest version uses a built-in analyzer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            AnalyzeRequest request = AnalyzeRequest.withGlobalAnalyzer("english", // <b class="conum">(1)</b>
                "Some text to analyze", "Some more text to analyze");       // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A built-in analyzer</p>
</li>
<li>
<p>The text to include.  Multiple strings are treated as a multi-valued field</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You can configure a custom analyzer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            Map&lt;String, Object&gt; stopFilter = new HashMap&lt;&gt;();
            stopFilter.put("type", "stop");
            stopFilter.put("stopwords", new String[]{ "to" });  // <b class="conum">(1)</b>
            AnalyzeRequest request = AnalyzeRequest.buildCustomAnalyzer("standard")  // <b class="conum">(2)</b>
                .addCharFilter("html_strip")    // <b class="conum">(3)</b>
                .addTokenFilter("lowercase")    // <b class="conum">(4)</b>
                .addTokenFilter(stopFilter)     // <b class="conum">(5)</b>
                .build("&lt;b&gt;Some text to analyze&lt;/b&gt;");</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Configuration for a custom tokenfilter</p>
</li>
<li>
<p>Configure the tokenizer</p>
</li>
<li>
<p>Configure char filters</p>
</li>
<li>
<p>Add a built-in tokenfilter</p>
</li>
<li>
<p>Add the custom tokenfilter</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You can also build a custom normalizer, by including only charfilters and
tokenfilters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            AnalyzeRequest request = AnalyzeRequest.buildCustomNormalizer()
                .addTokenFilter("lowercase")
                .build("&lt;b&gt;BaR&lt;/b&gt;");</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can analyze text using an analyzer defined in an existing index:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            AnalyzeRequest request = AnalyzeRequest.withIndexAnalyzer(
                "my_index",         // <b class="conum">(1)</b>
                "my_analyzer",        // <b class="conum">(2)</b>
                "some text to analyze"
            );</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The index containing the mappings</p>
</li>
<li>
<p>The analyzer defined on this index to use</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Or you can use a normalizer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            AnalyzeRequest request = AnalyzeRequest.withNormalizer(
                "my_index",             // <b class="conum">(1)</b>
                "my_normalizer",        // <b class="conum">(2)</b>
                "some text to analyze"
            );</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The index containing the mappings</p>
</li>
<li>
<p>The normalizer defined on this index to use</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You can analyze text using the mappings for a particular field in an index:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            AnalyzeRequest request = AnalyzeRequest.withField("my_index", "my_field", "some text to analyze");</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_15">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can also optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.explain(true);                      // <b class="conum">(1)</b>
            request.attributes("keyword", "type");      // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Setting <code>explain</code> to true will add further details to the response</p>
</li>
<li>
<p>Setting <code>attributes</code> allows you to return only token attributes that you are
interested in</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-analyze-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>AnalyzeRequest</code> in the following manner, the client waits
for the <code>AnalyzeResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            AnalyzeResponse response = client.indices().analyze(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-analyze-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>AnalyzeRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous analyze method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.indices().analyzeAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>AnalyzeRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>analyze</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ActionListener&lt;AnalyzeResponse&gt; listener = new ActionListener&lt;AnalyzeResponse&gt;() {
                @Override
                public void onResponse(AnalyzeResponse analyzeTokens) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>AnalyzeRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-analyze-response">Analyze Response</h4>
<div class="paragraph">
<p>The returned <code>AnalyzeResponse</code> allows you to retrieve details of the analysis as
follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            List&lt;AnalyzeResponse.AnalyzeToken&gt; tokens = response.getTokens();   // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>AnalyzeToken</code> holds information about the individual tokens produced by analysis</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If <code>explain</code> was set to <code>true</code>, then information is instead returned from the <code>detail()</code>
method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            DetailAnalyzeResponse detail = response.detail();                   // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>DetailAnalyzeResponse</code> holds more detailed information about tokens produced by
the various substeps in the analysis chain.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-create-index">Create Index API</h3>
<div class="sect3">
<h4 id="java-rest-high-create-index-request">Create Index Request</h4>
<div class="paragraph">
<p>A <code>CreateIndexRequest</code> requires an <code>index</code> argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            CreateIndexRequest request = new CreateIndexRequest("twitter"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The index to create</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_index_settings">Index settings</h4>
<div class="paragraph">
<p>Each index created can have specific settings associated with it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.settings(Settings.builder() // <b class="conum">(1)</b>
                .put("index.number_of_shards", 3)
                .put("index.number_of_replicas", 2)
            );</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Settings for this index</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-create-index-request-mappings">Index mappings</h4>
<div class="paragraph">
<p>An index may be created with mappings for its document types</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">                request.mapping(// <b class="conum">(1)</b>
                        "{\n" +
                        "  \"properties\": {\n" +
                        "    \"message\": {\n" +
                        "      \"type\": \"text\"\n" +
                        "    }\n" +
                        "  }\n" +
                        "}", // <b class="conum">(2)</b>
                        XContentType.JSON);</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The type to define</p>
</li>
<li>
<p>The mapping for this type, provided as a JSON string</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The mapping source can be provided in different ways in addition to the
<code>String</code> example shown above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">                Map&lt;String, Object&gt; message = new HashMap&lt;&gt;();
                message.put("type", "text");
                Map&lt;String, Object&gt; properties = new HashMap&lt;&gt;();
                properties.put("message", message);
                Map&lt;String, Object&gt; mapping = new HashMap&lt;&gt;();
                mapping.put("properties", properties);
                request.mapping(mapping); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Mapping source provided as a <code>Map</code> which gets automatically converted
to JSON format</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">                XContentBuilder builder = XContentFactory.jsonBuilder();
                builder.startObject();
                {
                    builder.startObject("properties");
                    {
                        builder.startObject("message");
                        {
                            builder.field("type", "text");
                        }
                        builder.endObject();
                    }
                    builder.endObject();
                }
                builder.endObject();
                request.mapping(builder); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Mapping source provided as an <code>XContentBuilder</code> object, the OpenSearch
built-in helpers to generate JSON content</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_index_aliases">Index aliases</h4>
<div class="paragraph">
<p>Aliases can be set at index creation time</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.alias(new Alias("twitter_alias").filter(QueryBuilders.termQuery("user", "kimchy")));  // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The alias to define</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_providing_the_whole_source">Providing the whole source</h4>
<div class="paragraph">
<p>The whole source including all of its sections (mappings, settings and aliases)
can also be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.source("{\n" +
                    "    \"settings\" : {\n" +
                    "        \"number_of_shards\" : 1,\n" +
                    "        \"number_of_replicas\" : 0\n" +
                    "    },\n" +
                    "    \"mappings\" : {\n" +
                    "        \"properties\" : {\n" +
                    "            \"message\" : { \"type\" : \"text\" }\n" +
                    "        }\n" +
                    "    },\n" +
                    "    \"aliases\" : {\n" +
                    "        \"twitter_alias\" : {}\n" +
                    "    }\n" +
                    "}", XContentType.JSON); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The source provided as a JSON string. It can also be provided as a <code>Map</code>
or an <code>XContentBuilder</code>.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_16">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setTimeout(TimeValue.timeValueMinutes(2)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to wait for the all the nodes to acknowledge the index creation as a <code>TimeValue</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setMasterTimeout(TimeValue.timeValueMinutes(1)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to connect to the master node as a <code>TimeValue</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.waitForActiveShards(ActiveShardCount.from(2)); // <b class="conum">(1)</b>
            request.waitForActiveShards(ActiveShardCount.DEFAULT); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The number of active shard copies to wait for before the create index API returns a
response, as an <code>int</code></p>
</li>
<li>
<p>The number of active shard copies to wait for before the create index API returns a
response, as an <code>ActiveShardCount</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-create-index-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>CreateIndexRequest</code> in the following manner, the client waits
for the <code>CreateIndexResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            CreateIndexResponse createIndexResponse = client.indices().create(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-create-index-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>CreateIndexRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous create-index method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.indices().createAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>CreateIndexRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>create-index</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ActionListener&lt;CreateIndexResponse&gt; listener =
                    new ActionListener&lt;CreateIndexResponse&gt;() {

                @Override
                public void onResponse(CreateIndexResponse createIndexResponse) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>CreateIndexRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-create-index-response">Create Index Response</h4>
<div class="paragraph">
<p>The returned <code>CreateIndexResponse</code> allows to retrieve information about the executed
 operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            boolean acknowledged = createIndexResponse.isAcknowledged(); // <b class="conum">(1)</b>
            boolean shardsAcknowledged = createIndexResponse.isShardsAcknowledged(); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Indicates whether all of the nodes have acknowledged the request</p>
</li>
<li>
<p>Indicates whether the requisite number of shard copies were started for each shard in the index before timing out</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-delete-index">Delete Index API</h3>
<div class="sect3">
<h4 id="java-rest-high-delete-index-request">Delete Index Request</h4>
<div class="paragraph">
<p>A <code>DeleteIndexRequest</code> requires an <code>index</code> argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            DeleteIndexRequest request = new DeleteIndexRequest("posts"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Index</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_17">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.timeout(TimeValue.timeValueMinutes(2)); // <b class="conum">(1)</b>
            request.timeout("2m"); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to wait for the all the nodes to acknowledge the index deletion as a <code>TimeValue</code></p>
</li>
<li>
<p>Timeout to wait for the all the nodes to acknowledge the index deletion as a <code>String</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.masterNodeTimeout(TimeValue.timeValueMinutes(1)); // <b class="conum">(1)</b>
            request.masterNodeTimeout("1m"); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to connect to the master node as a <code>TimeValue</code></p>
</li>
<li>
<p>Timeout to connect to the master node as a <code>String</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.indicesOptions(IndicesOptions.lenientExpandOpen()); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Setting <code>IndicesOptions</code> controls how unavailable indices are resolved and
how wildcard expressions are expanded</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-delete-index-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>DeleteIndexRequest</code> in the following manner, the client waits
for the <code>DeleteIndexResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            AcknowledgedResponse deleteIndexResponse = client.indices().delete(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-delete-index-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>DeleteIndexRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous delete-index method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.indices().deleteAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>DeleteIndexRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>delete-index</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ActionListener&lt;AcknowledgedResponse&gt; listener =
                    new ActionListener&lt;AcknowledgedResponse&gt;() {
                @Override
                public void onResponse(AcknowledgedResponse deleteIndexResponse) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>DeleteIndexRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-delete-index-response">Delete Index Response</h4>
<div class="paragraph">
<p>The returned <code>DeleteIndexResponse</code> allows to retrieve information about the executed
 operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            boolean acknowledged = deleteIndexResponse.isAcknowledged(); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Indicates whether all of the nodes have acknowledged the request</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If the index was not found, an <code>OpenSearchException</code> will be thrown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            try {
                DeleteIndexRequest request = new DeleteIndexRequest("does_not_exist");
                client.indices().delete(request, RequestOptions.DEFAULT);
            } catch (OpenSearchException exception) {
                if (exception.status() == RestStatus.NOT_FOUND) {
                    // <b class="conum">(1)</b>
                }
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Do something if the index to be deleted was not found</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-indices-exists">Index Exists API</h3>
<div class="sect3">
<h4 id="java-rest-high-indices-exists-request">Index Exists Request</h4>
<div class="paragraph">
<p>The high-level REST client uses a <code>GetIndexRequest</code> for Index Exists API. The index name (or indices' names) are required.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            GetIndexRequest request = new GetIndexRequest("twitter"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Index</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-indices-exists-optional-args">Optional arguments</h4>
<div class="paragraph">
<p>Index exists API also accepts following optional arguments, through a <code>GetIndexRequest</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.local(false); // <b class="conum">(1)</b>
            request.humanReadable(true); // <b class="conum">(2)</b>
            request.includeDefaults(false); // <b class="conum">(3)</b>
            request.indicesOptions(indicesOptions); // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Whether to return local information or retrieve the state from master node</p>
</li>
<li>
<p>Return result in a format suitable for humans</p>
</li>
<li>
<p>Whether to return all default setting for each of the indices</p>
</li>
<li>
<p>Controls how unavailable indices are resolved and how wildcard expressions are expanded</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-indices-exists-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>GetIndexRequest</code> in the following manner, the client waits
for the <code>boolean</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            boolean exists = client.indices().exists(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-indices-exists-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>GetIndexRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous indices-exists method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.indices().existsAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>GetIndexRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>indices-exists</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ActionListener&lt;Boolean&gt; listener = new ActionListener&lt;Boolean&gt;() {
                @Override
                public void onResponse(Boolean exists) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>GetIndexRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-indices-exists-response">Response</h4>
<div class="paragraph">
<p>The response is a <code>boolean</code> value, indicating whether the index (or indices) exist.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-open-index">Open Index API</h3>
<div class="sect3">
<h4 id="java-rest-high-open-index-request">Open Index Request</h4>
<div class="paragraph">
<p>An <code>OpenIndexRequest</code> requires an <code>index</code> argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            OpenIndexRequest request = new OpenIndexRequest("index"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The index to open</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_18">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.timeout(TimeValue.timeValueMinutes(2)); // <b class="conum">(1)</b>
            request.timeout("2m"); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to wait for the all the nodes to acknowledge the index is opened
as a <code>TimeValue</code></p>
</li>
<li>
<p>Timeout to wait for the all the nodes to acknowledge the index is opened
as a <code>String</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.masterNodeTimeout(TimeValue.timeValueMinutes(1)); // <b class="conum">(1)</b>
            request.masterNodeTimeout("1m"); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to connect to the master node as a <code>TimeValue</code></p>
</li>
<li>
<p>Timeout to connect to the master node as a <code>String</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.waitForActiveShards(2); // <b class="conum">(1)</b>
            request.waitForActiveShards(ActiveShardCount.DEFAULT); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The number of active shard copies to wait for before the open index API
returns a response, as an <code>int</code></p>
</li>
<li>
<p>The number of active shard copies to wait for before  the open index API
returns a response, as an <code>ActiveShardCount</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.indicesOptions(IndicesOptions.strictExpandOpen()); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Setting <code>IndicesOptions</code> controls how unavailable indices are resolved and
how wildcard expressions are expanded</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-open-index-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>OpenIndexRequest</code> in the following manner, the client waits
for the <code>OpenIndexResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            OpenIndexResponse openIndexResponse = client.indices().open(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-open-index-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>OpenIndexRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous open-index method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.indices().openAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>OpenIndexRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>open-index</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ActionListener&lt;OpenIndexResponse&gt; listener =
                    new ActionListener&lt;OpenIndexResponse&gt;() {
                @Override
                public void onResponse(OpenIndexResponse openIndexResponse) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>OpenIndexRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-open-index-response">Open Index Response</h4>
<div class="paragraph">
<p>The returned <code>OpenIndexResponse</code> allows to retrieve information about the
executed operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            boolean acknowledged = openIndexResponse.isAcknowledged(); // <b class="conum">(1)</b>
            boolean shardsAcked = openIndexResponse.isShardsAcknowledged(); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Indicates whether all of the nodes have acknowledged the request</p>
</li>
<li>
<p>Indicates whether the requisite number of shard copies were started for
each shard in the index before timing out</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-close-index">Close Index API</h3>
<div class="sect3">
<h4 id="java-rest-high-close-index-request">Close Index Request</h4>
<div class="paragraph">
<p>A <code>CloseIndexRequest</code> requires an <code>index</code> argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            CloseIndexRequest request = new CloseIndexRequest("index"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The index to close</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_19">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setTimeout(TimeValue.timeValueMinutes(2)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to wait for the all the nodes to acknowledge the index is closed
as a <code>TimeValue</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setMasterTimeout(TimeValue.timeValueMinutes(1)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to connect to the master node as a <code>TimeValue</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.indicesOptions(IndicesOptions.lenientExpandOpen()); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Setting <code>IndicesOptions</code> controls how unavailable indices are resolved and
how wildcard expressions are expanded</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-close-index-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>CloseIndexRequest</code> in the following manner, the client waits
for the <code>CloseIndexResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            AcknowledgedResponse closeIndexResponse = client.indices().close(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-close-index-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>CloseIndexRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous close-index method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.indices().closeAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>CloseIndexRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>close-index</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ActionListener&lt;CloseIndexResponse&gt; listener = new ActionListener&lt;CloseIndexResponse&gt;() {
                @Override
                public void onResponse(CloseIndexResponse closeIndexResponse) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>CloseIndexRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-close-index-response">Close Index Response</h4>
<div class="paragraph">
<p>The returned <code>CloseIndexResponse</code> allows to retrieve information about the
executed operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            boolean acknowledged = closeIndexResponse.isAcknowledged(); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Indicates whether all of the nodes have acknowledged the request</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-shrink-index">Shrink Index API</h3>
<div class="sect3">
<h4 id="java-rest-high-shrink-index-request">Resize Request</h4>
<div class="paragraph">
<p>The Shrink API requires a <code>ResizeRequest</code> instance.
A <code>ResizeRequest</code> requires two string arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ResizeRequest request = new ResizeRequest("target_index","source_index"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The target index (first argument) to shrink the source index (second argument) into</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_20">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.timeout(TimeValue.timeValueMinutes(2)); // <b class="conum">(1)</b>
        request.timeout("2m"); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to wait for the all the nodes to acknowledge the index is opened
as a <code>TimeValue</code></p>
</li>
<li>
<p>Timeout to wait for the all the nodes to acknowledge the index is opened
as a <code>String</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.masterNodeTimeout(TimeValue.timeValueMinutes(1)); // <b class="conum">(1)</b>
        request.masterNodeTimeout("1m"); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to connect to the master node as a <code>TimeValue</code></p>
</li>
<li>
<p>Timeout to connect to the master node as a <code>String</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.setWaitForActiveShards(2); // <b class="conum">(1)</b>
        request.setWaitForActiveShards(ActiveShardCount.DEFAULT); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The number of active shard copies to wait for before the shrink index API
returns a response, as an <code>int</code></p>
</li>
<li>
<p>The number of active shard copies to wait for before the shrink index API
returns a response, as an <code>ActiveShardCount</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.getTargetIndexRequest().settings(Settings.builder()
                .put("index.number_of_shards", 2) // <b class="conum">(1)</b>
                .putNull("index.routing.allocation.require._name")); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The number of shards on the target of the shrink index request</p>
</li>
<li>
<p>Remove the allocation requirement copied from the source index</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.getTargetIndexRequest().alias(new Alias("target_alias")); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The aliases to associate the target index with</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-shrink-index-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>ResizeRequest</code> in the following manner, the client waits
for the <code>ResizeResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ResizeResponse resizeResponse = client.indices().shrink(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-shrink-index-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>ResizeRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous shrink-index method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        client.indices().shrinkAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>ResizeRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>shrink-index</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ActionListener&lt;ResizeResponse&gt; listener = new ActionListener&lt;ResizeResponse&gt;() {
            @Override
            public void onResponse(ResizeResponse resizeResponse) {
                // <b class="conum">(1)</b>
            }

            @Override
            public void onFailure(Exception e) {
                // <b class="conum">(2)</b>
            }
        };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>ResizeRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-shrink-index-response">Shrink Index Response</h4>
<div class="paragraph">
<p>The returned <code>ResizeResponse</code> allows to retrieve information about the
executed operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        boolean acknowledged = resizeResponse.isAcknowledged(); // <b class="conum">(1)</b>
        boolean shardsAcked = resizeResponse.isShardsAcknowledged(); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Indicates whether all of the nodes have acknowledged the request</p>
</li>
<li>
<p>Indicates whether the requisite number of shard copies were started for
each shard in the index before timing out</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-split-index">Split Index API</h3>
<div class="sect3">
<h4 id="java-rest-high-split-index-request">Resize Request</h4>
<div class="paragraph">
<p>The Split API requires a <code>ResizeRequest</code> instance.
A <code>ResizeRequest</code> requires two string arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ResizeRequest request = new ResizeRequest("target_index","source_index"); // <b class="conum">(1)</b>
        request.setResizeType(ResizeType.SPLIT); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The target index (first argument) to split the source index (second argument) into</p>
</li>
<li>
<p>The resize type needs to be set to <code>SPLIT</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_21">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.timeout(TimeValue.timeValueMinutes(2)); // <b class="conum">(1)</b>
        request.timeout("2m"); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to wait for the all the nodes to acknowledge the index is opened
as a <code>TimeValue</code></p>
</li>
<li>
<p>Timeout to wait for the all the nodes to acknowledge the index is opened
as a <code>String</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.masterNodeTimeout(TimeValue.timeValueMinutes(1)); // <b class="conum">(1)</b>
        request.masterNodeTimeout("1m"); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to connect to the master node as a <code>TimeValue</code></p>
</li>
<li>
<p>Timeout to connect to the master node as a <code>String</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.setWaitForActiveShards(2); // <b class="conum">(1)</b>
        request.setWaitForActiveShards(ActiveShardCount.DEFAULT); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The number of active shard copies to wait for before the split index API
returns a response, as an <code>int</code></p>
</li>
<li>
<p>The number of active shard copies to wait for before the split index API
returns a response, as an <code>ActiveShardCount</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.getTargetIndexRequest().settings(Settings.builder()
                .put("index.number_of_shards", 4)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The settings to apply to the target index, which include the number of
shards to create for it</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.getTargetIndexRequest().alias(new Alias("target_alias")); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The aliases to associate the target index with</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-split-index-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>ResizeRequest</code> in the following manner, the client waits
for the <code>ResizeResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ResizeResponse resizeResponse = client.indices().split(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-split-index-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>ResizeRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous split-index method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        client.indices().splitAsync(request, RequestOptions.DEFAULT,listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>ResizeRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>split-index</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ActionListener&lt;ResizeResponse&gt; listener = new ActionListener&lt;ResizeResponse&gt;() {
            @Override
            public void onResponse(ResizeResponse resizeResponse) {
                // <b class="conum">(1)</b>
            }

            @Override
            public void onFailure(Exception e) {
                // <b class="conum">(2)</b>
            }
        };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>ResizeRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-split-index-response">Split Index Response</h4>
<div class="paragraph">
<p>The returned <code>ResizeResponse</code> allows to retrieve information about the
executed operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        boolean acknowledged = resizeResponse.isAcknowledged(); // <b class="conum">(1)</b>
        boolean shardsAcked = resizeResponse.isShardsAcknowledged(); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Indicates whether all of the nodes have acknowledged the request</p>
</li>
<li>
<p>Indicates whether the requisite number of shard copies were started for
each shard in the index before timing out</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-clone-index">Clone Index API</h3>
<div class="sect3">
<h4 id="java-rest-high-clone-index-request">Resize Request</h4>
<div class="paragraph">
<p>The Clone Index API requires a <code>ResizeRequest</code> instance.
A <code>ResizeRequest</code> requires two string arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ResizeRequest request = new ResizeRequest("target_index","source_index"); // <b class="conum">(1)</b>
        request.setResizeType(ResizeType.CLONE); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The target index (first argument) to clone the source index (second argument) into</p>
</li>
<li>
<p>The resize type needs to be set to <code>CLONE</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_22">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.timeout(TimeValue.timeValueMinutes(2)); // <b class="conum">(1)</b>
        request.timeout("2m"); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to wait for the all the nodes to acknowledge the index is opened
as a <code>TimeValue</code></p>
</li>
<li>
<p>Timeout to wait for the all the nodes to acknowledge the index is opened
as a <code>String</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.masterNodeTimeout(TimeValue.timeValueMinutes(1)); // <b class="conum">(1)</b>
        request.masterNodeTimeout("1m"); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to connect to the master node as a <code>TimeValue</code></p>
</li>
<li>
<p>Timeout to connect to the master node as a <code>String</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.setWaitForActiveShards(2); // <b class="conum">(1)</b>
        request.setWaitForActiveShards(ActiveShardCount.DEFAULT); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The number of active shard copies to wait for before the clone index API
returns a response, as an <code>int</code></p>
</li>
<li>
<p>The number of active shard copies to wait for before the clone index API
returns a response, as an <code>ActiveShardCount</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.getTargetIndexRequest().settings(Settings.builder()
            .put("index.number_of_shards", 2)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The settings to apply to the target index, which optionally include the
number of shards to create for it</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.getTargetIndexRequest().alias(new Alias("target_alias")); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The aliases to associate the target index with</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-clone-index-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>ResizeRequest</code> in the following manner, the client waits
for the <code>ResizeResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ResizeResponse resizeResponse = client.indices().clone(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-clone-index-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>ResizeRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous clone-index method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        client.indices().cloneAsync(request, RequestOptions.DEFAULT,listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>ResizeRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>clone-index</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ActionListener&lt;ResizeResponse&gt; listener = new ActionListener&lt;ResizeResponse&gt;() {
            @Override
            public void onResponse(ResizeResponse resizeResponse) {
                // <b class="conum">(1)</b>
            }

            @Override
            public void onFailure(Exception e) {
                // <b class="conum">(2)</b>
            }
        };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>ResizeRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-clone-index-response">Clone Index Response</h4>
<div class="paragraph">
<p>The returned <code>ResizeResponse</code> allows to retrieve information about the
executed operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        boolean acknowledged = resizeResponse.isAcknowledged(); // <b class="conum">(1)</b>
        boolean shardsAcked = resizeResponse.isShardsAcknowledged(); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Indicates whether all of the nodes have acknowledged the request</p>
</li>
<li>
<p>Indicates whether the requisite number of shard copies were started for
each shard in the index before timing out</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-refresh">Refresh API</h3>
<div class="sect3">
<h4 id="java-rest-high-refresh-request">Refresh Request</h4>
<div class="paragraph">
<p>A <code>RefreshRequest</code> can be applied to one or more indices, or even on <code>_all</code> the indices:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            RefreshRequest request = new RefreshRequest("index1"); // <b class="conum">(1)</b>
            RefreshRequest requestMultiple = new RefreshRequest("index1", "index2"); // <b class="conum">(2)</b>
            RefreshRequest requestAll = new RefreshRequest(); // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Refresh one index</p>
</li>
<li>
<p>Refresh multiple indices</p>
</li>
<li>
<p>Refresh all the indices</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_23">Optional arguments</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.indicesOptions(IndicesOptions.lenientExpandOpen()); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Setting <code>IndicesOptions</code> controls how unavailable indices are resolved and
how wildcard expressions are expanded</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-refresh-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>RefreshRequest</code> in the following manner, the client waits
for the <code>RefreshResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            RefreshResponse refreshResponse = client.indices().refresh(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-refresh-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>RefreshRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous refresh method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.indices().refreshAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>RefreshRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>refresh</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ActionListener&lt;RefreshResponse&gt; listener = new ActionListener&lt;RefreshResponse&gt;() {
                @Override
                public void onResponse(RefreshResponse refreshResponse) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>RefreshRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-refresh-response">Refresh Response</h4>
<div class="paragraph">
<p>The returned <code>RefreshResponse</code> allows to retrieve information about the
executed operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            int totalShards = refreshResponse.getTotalShards(); // <b class="conum">(1)</b>
            int successfulShards = refreshResponse.getSuccessfulShards(); // <b class="conum">(2)</b>
            int failedShards = refreshResponse.getFailedShards(); // <b class="conum">(3)</b>
            DefaultShardOperationFailedException[] failures = refreshResponse.getShardFailures(); // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Total number of shards hit by the refresh request</p>
</li>
<li>
<p>Number of shards where the refresh has succeeded</p>
</li>
<li>
<p>Number of shards where the refresh has failed</p>
</li>
<li>
<p>A list of failures if the operation failed on one or more shards</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By default, if the indices were not found, an <code>OpenSearchException</code> will be thrown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            try {
                RefreshRequest request = new RefreshRequest("does_not_exist");
                client.indices().refresh(request, RequestOptions.DEFAULT);
            } catch (OpenSearchException exception) {
                if (exception.status() == RestStatus.NOT_FOUND) {
                    // <b class="conum">(1)</b>
                }
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Do something if the indices to be refreshed were not found</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-flush">Flush API</h3>
<div class="sect3">
<h4 id="java-rest-high-flush-request">Flush Request</h4>
<div class="paragraph">
<p>A <code>FlushRequest</code> can be applied to one or more indices, or even on <code>_all</code> the indices:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            FlushRequest request = new FlushRequest("index1"); // <b class="conum">(1)</b>
            FlushRequest requestMultiple = new FlushRequest("index1", "index2"); // <b class="conum">(2)</b>
            FlushRequest requestAll = new FlushRequest(); // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Flush one index</p>
</li>
<li>
<p>Flush multiple indices</p>
</li>
<li>
<p>Flush all the indices</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_24">Optional arguments</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.indicesOptions(IndicesOptions.lenientExpandOpen()); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Setting <code>IndicesOptions</code> controls how unavailable indices are resolved and
how wildcard expressions are expanded</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.waitIfOngoing(true); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set the <code>wait_if_ongoing</code> flag to <code>true</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.force(true); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set the <code>force</code> flag to <code>true</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-flush-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>FlushRequest</code> in the following manner, the client waits
for the <code>FlushResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            FlushResponse flushResponse = client.indices().flush(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-flush-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>FlushRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous flush method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.indices().flushAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>FlushRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>flush</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ActionListener&lt;FlushResponse&gt; listener = new ActionListener&lt;FlushResponse&gt;() {
                @Override
                public void onResponse(FlushResponse flushResponse) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>FlushRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-flush-response">Flush Response</h4>
<div class="paragraph">
<p>The returned <code>FlushResponse</code> allows to retrieve information about the
executed operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            int totalShards = flushResponse.getTotalShards(); // <b class="conum">(1)</b>
            int successfulShards = flushResponse.getSuccessfulShards(); // <b class="conum">(2)</b>
            int failedShards = flushResponse.getFailedShards(); // <b class="conum">(3)</b>
            DefaultShardOperationFailedException[] failures = flushResponse.getShardFailures(); // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Total number of shards hit by the flush request</p>
</li>
<li>
<p>Number of shards where the flush has succeeded</p>
</li>
<li>
<p>Number of shards where the flush has failed</p>
</li>
<li>
<p>A list of failures if the operation failed on one or more shards</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By default, if the indices were not found, an <code>OpenSearchException</code> will be thrown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            try {
                FlushRequest request = new FlushRequest("does_not_exist");
                client.indices().flush(request, RequestOptions.DEFAULT);
            } catch (OpenSearchException exception) {
                if (exception.status() == RestStatus.NOT_FOUND) {
                    // <b class="conum">(1)</b>
                }
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Do something if the indices to be flushed were not found</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-flush-synced">Flush Synced API</h3>
<div class="sect3">
<h4 id="java-rest-high-flush-synced-request">Flush Synced Request</h4>
<div class="paragraph">
<p>A <code>SyncedFlushRequest</code> can be applied to one or more indices, or even on <code>_all</code> the indices:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            SyncedFlushRequest request = new SyncedFlushRequest("index1"); // <b class="conum">(1)</b>
            SyncedFlushRequest requestMultiple = new SyncedFlushRequest("index1", "index2"); // <b class="conum">(2)</b>
            SyncedFlushRequest requestAll = new SyncedFlushRequest(); // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Flush synced one index</p>
</li>
<li>
<p>Flush synced multiple indices</p>
</li>
<li>
<p>Flush synced all the indices</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_25">Optional arguments</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.indicesOptions(IndicesOptions.lenientExpandOpen()); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Setting <code>IndicesOptions</code> controls how unavailable indices are resolved and
how wildcard expressions are expanded</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-flush-synced-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>SyncedFlushRequest</code> in the following manner, the client waits
for the <code>SyncedFlushResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            SyncedFlushResponse flushSyncedResponse = client.indices().flushSynced(request, expectWarnings(
                "Synced flush is deprecated and will be removed in 8.0. Use flush at _/flush or /{index}/_flush instead."
            ));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-flush-synced-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>SyncedFlushRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous flush-synced method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.indices().flushSyncedAsync(request, expectWarnings(
                "Synced flush is deprecated and will be removed in 8.0. Use flush at _/flush or /{index}/_flush instead."
            ), listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>SyncedFlushRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>flush-synced</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ActionListener&lt;SyncedFlushResponse&gt; listener = new ActionListener&lt;SyncedFlushResponse&gt;() {
                @Override
                public void onResponse(SyncedFlushResponse refreshResponse) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>SyncedFlushRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-flush-synced-response">Flush Synced Response</h4>
<div class="paragraph">
<p>The returned <code>SyncedFlushResponse</code> allows to retrieve information about the
executed operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            int totalShards = flushSyncedResponse.totalShards(); // <b class="conum">(1)</b>
            int successfulShards = flushSyncedResponse.successfulShards(); // <b class="conum">(2)</b>
            int failedShards = flushSyncedResponse.failedShards(); // <b class="conum">(3)</b>

            for (Map.Entry&lt;String, SyncedFlushResponse.IndexResult&gt; responsePerIndexEntry:
                flushSyncedResponse.getIndexResults().entrySet()) {
                String indexName = responsePerIndexEntry.getKey(); // <b class="conum">(4)</b>
                SyncedFlushResponse.IndexResult indexResult = responsePerIndexEntry.getValue();
                int totalShardsForIndex = indexResult.totalShards(); // <b class="conum">(5)</b>
                int successfulShardsForIndex = indexResult.successfulShards(); // <b class="conum">(6)</b>
                int failedShardsForIndex = indexResult.failedShards(); // <b class="conum">(7)</b>
                if (failedShardsForIndex &gt; 0) {
                    for (SyncedFlushResponse.ShardFailure failureEntry: indexResult.failures()) {
                        int shardId = failureEntry.getShardId(); // <b class="conum">(8)</b>
                        String failureReason = failureEntry.getFailureReason(); // <b class="conum">(9)</b>
                        Map&lt;String, Object&gt; routing = failureEntry.getRouting(); // <b class="conum">(10)</b>
                    }
                }
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Total number of shards hit by the flush request</p>
</li>
<li>
<p>Number of shards where the flush has succeeded</p>
</li>
<li>
<p>Number of shards where the flush has failed</p>
</li>
<li>
<p>Name of the index whose results we are about to calculate.</p>
</li>
<li>
<p>Total number of shards for index mentioned in 4.</p>
</li>
<li>
<p>Successful shards for index mentioned in 4.</p>
</li>
<li>
<p>Failed shards for index mentioned in 4.</p>
</li>
<li>
<p>One of the failed shard ids of the failed index mentioned in 4.</p>
</li>
<li>
<p>Reason for failure of copies of the shard mentioned in 8.</p>
</li>
<li>
<p>JSON represented by a Map&lt;String, Object&gt;. Contains shard related information like id, state, version etc.
for the failed shard copies. If the entire shard failed then this returns an empty map.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By default, if the indices were not found, an <code>OpenSearchException</code> will be thrown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            try {
                SyncedFlushRequest request = new SyncedFlushRequest("does_not_exist");
                client.indices().flushSynced(request, RequestOptions.DEFAULT);
            } catch (OpenSearchException exception) {
                if (exception.status() == RestStatus.NOT_FOUND) {
                    // <b class="conum">(1)</b>
                }
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Do something if the indices to be flushed were not found</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-clear-cache">Clear Cache API</h3>
<div class="sect3">
<h4 id="java-rest-high-clear-cache-request">Clear Cache Request</h4>
<div class="paragraph">
<p>A <code>ClearIndicesCacheRequest</code> can be applied to one or more indices, or even on
<code>_all</code> the indices:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ClearIndicesCacheRequest request = new ClearIndicesCacheRequest("index1"); // <b class="conum">(1)</b>
            ClearIndicesCacheRequest requestMultiple = new ClearIndicesCacheRequest("index1", "index2"); // <b class="conum">(2)</b>
            ClearIndicesCacheRequest requestAll = new ClearIndicesCacheRequest(); // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Clears the cache of one index</p>
</li>
<li>
<p>Clears the cache of multiple indices</p>
</li>
<li>
<p>Clears the cache of all the indices</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_26">Optional arguments</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.indicesOptions(IndicesOptions.lenientExpandOpen()); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Setting <code>IndicesOptions</code> controls how unavailable indices are resolved and
how wildcard expressions are expanded</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.queryCache(true); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set the <code>query</code> flag to <code>true</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.fieldDataCache(true); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set the <code>fielddata</code> flag to <code>true</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.requestCache(true); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set the <code>request</code> flag to <code>true</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.fields("field1", "field2", "field3"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set the <code>fields</code> parameter</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-clear-cache-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>ClearIndicesCacheRequest</code> in the following manner, the client waits
for the <code>ClearIndicesCacheResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ClearIndicesCacheResponse clearCacheResponse = client.indices().clearCache(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-clear-cache-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>ClearIndicesCacheRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous clear-cache method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.indices().clearCacheAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>ClearIndicesCacheRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>clear-cache</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ActionListener&lt;ClearIndicesCacheResponse&gt; listener = new ActionListener&lt;ClearIndicesCacheResponse&gt;() {
                @Override
                public void onResponse(ClearIndicesCacheResponse clearCacheResponse) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>ClearIndicesCacheRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-clear-cache-response">Clear Cache Response</h4>
<div class="paragraph">
<p>The returned <code>ClearIndicesCacheResponse</code> allows to retrieve information about the
executed operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            int totalShards = clearCacheResponse.getTotalShards(); // <b class="conum">(1)</b>
            int successfulShards = clearCacheResponse.getSuccessfulShards(); // <b class="conum">(2)</b>
            int failedShards = clearCacheResponse.getFailedShards(); // <b class="conum">(3)</b>
            DefaultShardOperationFailedException[] failures = clearCacheResponse.getShardFailures(); // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Total number of shards hit by the clear cache request</p>
</li>
<li>
<p>Number of shards where the clear cache has succeeded</p>
</li>
<li>
<p>Number of shards where the clear cache has failed</p>
</li>
<li>
<p>A list of failures if the operation failed on one or more shards</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By default, if the indices were not found, an <code>OpenSearchException</code> will be thrown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            try {
                ClearIndicesCacheRequest request = new ClearIndicesCacheRequest("does_not_exist");
                client.indices().clearCache(request, RequestOptions.DEFAULT);
            } catch (OpenSearchException exception) {
                if (exception.status() == RestStatus.NOT_FOUND) {
                    // <b class="conum">(1)</b>
                }
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Do something if the indices to be cleared were not found</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-force-merge">Force Merge API</h3>
<div class="sect3">
<h4 id="java-rest-high-force-merge-request">Force merge Request</h4>
<div class="paragraph">
<p>A <code>ForceMergeRequest</code> can be applied to one or more indices, or even on <code>_all</code> the indices:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ForceMergeRequest request = new ForceMergeRequest("index1"); // <b class="conum">(1)</b>
            ForceMergeRequest requestMultiple = new ForceMergeRequest("index1", "index2"); // <b class="conum">(2)</b>
            ForceMergeRequest requestAll = new ForceMergeRequest(); // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Force merge one index</p>
</li>
<li>
<p>Force merge multiple indices</p>
</li>
<li>
<p>Force merge all the indices</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_27">Optional arguments</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.indicesOptions(IndicesOptions.lenientExpandOpen()); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Setting <code>IndicesOptions</code> controls how unavailable indices are resolved and
how wildcard expressions are expanded</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.maxNumSegments(1); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set <code>max_num_segments</code> to control the number of segments to merge down to.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.onlyExpungeDeletes(true); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set the <code>only_expunge_deletes</code> flag to <code>true</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.flush(true); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set the <code>flush</code> flag to <code>true</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-force-merge-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>ForceMergeRequest</code> in the following manner, the client waits
for the <code>ForceMergeResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ForceMergeResponse forceMergeResponse = client.indices().forcemerge(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-force-merge-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>ForceMergeRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous force-merge method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.indices().forcemergeAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>ForceMergeRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>force-merge</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ActionListener&lt;ForceMergeResponse&gt; listener = new ActionListener&lt;ForceMergeResponse&gt;() {
                @Override
                public void onResponse(ForceMergeResponse forceMergeResponse) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>ForceMergeRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-force-merge-response">Force Merge Response</h4>
<div class="paragraph">
<p>The returned <code>ForceMergeResponse</code> allows to retrieve information about the
executed operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            int totalShards = forceMergeResponse.getTotalShards(); // <b class="conum">(1)</b>
            int successfulShards = forceMergeResponse.getSuccessfulShards(); // <b class="conum">(2)</b>
            int failedShards = forceMergeResponse.getFailedShards(); // <b class="conum">(3)</b>
            DefaultShardOperationFailedException[] failures = forceMergeResponse.getShardFailures(); // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Total number of shards hit by the force merge request</p>
</li>
<li>
<p>Number of shards where the force merge has succeeded</p>
</li>
<li>
<p>Number of shards where the force merge has failed</p>
</li>
<li>
<p>A list of failures if the operation failed on one or more shards</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By default, if the indices were not found, an <code>OpenSearchException</code> will be thrown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            try {
                ForceMergeRequest request = new ForceMergeRequest("does_not_exist");
                client.indices().forcemerge(request, RequestOptions.DEFAULT);
            } catch (OpenSearchException exception) {
                if (exception.status() == RestStatus.NOT_FOUND) {
                    // <b class="conum">(1)</b>
                }
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Do something if the indices to be force merged were not found</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-rollover-index">Rollover Index API</h3>
<div class="sect3">
<h4 id="java-rest-high-rollover-index-request">Rollover Request</h4>
<div class="paragraph">
<p>The Rollover Index API requires a <code>RolloverRequest</code> instance.
A <code>RolloverRequest</code> requires two string arguments at construction time, and
one or more conditions that determine when the index has to be rolled over:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        RolloverRequest request = new RolloverRequest("alias", "index-2"); // <b class="conum">(1)</b>
        request.addMaxIndexAgeCondition(new TimeValue(7, TimeUnit.DAYS)); // <b class="conum">(2)</b>
        request.addMaxIndexDocsCondition(1000); // <b class="conum">(3)</b>
        request.addMaxIndexSizeCondition(new ByteSizeValue(5, ByteSizeUnit.GB)); // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The alias (first argument) that points to the index to rollover, and
the name of the new index in case the rollover operation is performed.
The new index argument is optional, and can be set to null</p>
</li>
<li>
<p>Condition on the age of the index</p>
</li>
<li>
<p>Condition on the number of documents in the index</p>
</li>
<li>
<p>Condition on the size of the index</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_28">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.dryRun(true); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Whether the rollover should be performed (default) or only simulated</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.setTimeout(TimeValue.timeValueMinutes(2)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to wait for the all the nodes to acknowledge the index is opened
as a <code>TimeValue</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.setMasterTimeout(TimeValue.timeValueMinutes(1)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to connect to the master node as a <code>TimeValue</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.getCreateIndexRequest().waitForActiveShards(ActiveShardCount.from(2)); // <b class="conum">(1)</b>
        request.getCreateIndexRequest().waitForActiveShards(ActiveShardCount.DEFAULT); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Sets the number of active shard copies to wait for before the rollover
index API returns a response</p>
</li>
<li>
<p>Resets the number of active shard copies to wait for to the default value</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.getCreateIndexRequest().settings(Settings.builder()
                .put("index.number_of_shards", 4)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Add the settings to apply to the new index, which include the number of
shards to create for it</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        String mappings = "{\"properties\":{\"field-1\":{\"type\":\"keyword\"}}}";
        request.getCreateIndexRequest().mapping(mappings, XContentType.JSON); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Add the mappings to associate the new index with. See <a href="_index_apis.html#java-rest-high-create-index-request-mappings">Index mappings</a>
for examples on the different ways to provide mappings</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.getCreateIndexRequest().alias(new Alias("another_alias")); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Add the aliases to associate the new index with</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-rollover-index-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>RolloverRequest</code> in the following manner, the client waits
for the <code>RolloverResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        RolloverResponse rolloverResponse = client.indices().rollover(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-rollover-index-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>RolloverRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous rollover-index method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        client.indices().rolloverAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>RolloverRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>rollover-index</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ActionListener&lt;RolloverResponse&gt; listener = new ActionListener&lt;RolloverResponse&gt;() {
            @Override
            public void onResponse(RolloverResponse rolloverResponse) {
                // <b class="conum">(1)</b>
            }

            @Override
            public void onFailure(Exception e) {
                // <b class="conum">(2)</b>
            }
        };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>RolloverRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-rollover-index-response">Rollover Response</h4>
<div class="paragraph">
<p>The returned <code>RolloverResponse</code> allows to retrieve information about the
executed operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        boolean acknowledged = rolloverResponse.isAcknowledged(); // <b class="conum">(1)</b>
        boolean shardsAcked = rolloverResponse.isShardsAcknowledged(); // <b class="conum">(2)</b>
        String oldIndex = rolloverResponse.getOldIndex(); // <b class="conum">(3)</b>
        String newIndex = rolloverResponse.getNewIndex(); // <b class="conum">(4)</b>
        boolean isRolledOver = rolloverResponse.isRolledOver(); // <b class="conum">(5)</b>
        boolean isDryRun = rolloverResponse.isDryRun(); // <b class="conum">(6)</b>
        Map&lt;String, Boolean&gt; conditionStatus = rolloverResponse.getConditionStatus();// <b class="conum">(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Indicates whether all of the nodes have acknowledged the request</p>
</li>
<li>
<p>Indicates whether the requisite number of shard copies were started for
each shard in the index before timing out</p>
</li>
<li>
<p>The name of the old index, eventually rolled over</p>
</li>
<li>
<p>The name of the new index</p>
</li>
<li>
<p>Whether the index has been rolled over</p>
</li>
<li>
<p>Whether the operation was performed or it was a dry run</p>
</li>
<li>
<p>The different conditions and whether they were matched or not</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-put-mapping">Put Mapping API</h3>
<div class="sect3">
<h4 id="java-rest-high-put-mapping-request">Put Mapping Request</h4>
<div class="paragraph">
<p>A <code>PutMappingRequest</code> requires an <code>index</code> argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            PutMappingRequest request = new PutMappingRequest("twitter"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The index to add the mapping to</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_mapping_source">Mapping source</h4>
<div class="paragraph">
<p>A description of the fields to create on the mapping; if not defined, the mapping will default to empty.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">                request.source(
                    "{\n" +
                    "  \"properties\": {\n" +
                    "    \"message\": {\n" +
                    "      \"type\": \"text\"\n" +
                    "    }\n" +
                    "  }\n" +
                    "}", // <b class="conum">(1)</b>
                    XContentType.JSON);</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Mapping source provided as a <code>String</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_providing_the_mapping_source">Providing the mapping source</h4>
<div class="paragraph">
<p>The mapping source can be provided in different ways in addition to
the <code>String</code> example shown above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">                Map&lt;String, Object&gt; jsonMap = new HashMap&lt;&gt;();
                Map&lt;String, Object&gt; message = new HashMap&lt;&gt;();
                message.put("type", "text");
                Map&lt;String, Object&gt; properties = new HashMap&lt;&gt;();
                properties.put("message", message);
                jsonMap.put("properties", properties);
                request.source(jsonMap); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Mapping source provided as a <code>Map</code> which gets automatically converted
to JSON format</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">                XContentBuilder builder = XContentFactory.jsonBuilder();
                builder.startObject();
                {
                    builder.startObject("properties");
                    {
                        builder.startObject("message");
                        {
                            builder.field("type", "text");
                        }
                        builder.endObject();
                    }
                    builder.endObject();
                }
                builder.endObject();
                request.source(builder); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Mapping source provided as an <code>XContentBuilder</code> object, the OpenSearch
built-in helpers to generate JSON content</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_29">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setTimeout(TimeValue.timeValueMinutes(2)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to wait for the all the nodes to acknowledge the index creation as a <code>TimeValue</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setMasterTimeout(TimeValue.timeValueMinutes(1)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to connect to the master node as a <code>TimeValue</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-put-mapping-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>PutMappingRequest</code> in the following manner, the client waits
for the <code>PutMappingResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            AcknowledgedResponse putMappingResponse = client.indices().putMapping(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-put-mapping-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>PutMappingRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous put-mapping method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.indices().putMappingAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>PutMappingRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>put-mapping</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ActionListener&lt;AcknowledgedResponse&gt; listener =
                new ActionListener&lt;AcknowledgedResponse&gt;() {
                    @Override
                    public void onResponse(AcknowledgedResponse putMappingResponse) {
                        // <b class="conum">(1)</b>
                    }

                    @Override
                    public void onFailure(Exception e) {
                        // <b class="conum">(2)</b>
                    }
                };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>PutMappingRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-put-mapping-response">Put Mapping Response</h4>
<div class="paragraph">
<p>The returned <code>PutMappingResponse</code> allows to retrieve information about the executed
 operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            boolean acknowledged = putMappingResponse.isAcknowledged(); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Indicates whether all of the nodes have acknowledged the request</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-get-mappings">Get Mappings API</h3>
<div class="sect3">
<h4 id="java-rest-high-get-mappings-request">Get Mappings Request</h4>
<div class="paragraph">
<p>A <code>GetMappingsRequest</code> can have an optional list of indices:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            GetMappingsRequest request = new GetMappingsRequest(); // <b class="conum">(1)</b>
            request.indices("twitter"); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>An empty request that will return all indices</p>
</li>
<li>
<p>Setting the indices to fetch mapping for</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_30">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can also optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setMasterTimeout(TimeValue.timeValueMinutes(1)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to connect to the master node as a <code>TimeValue</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.indicesOptions(IndicesOptions.lenientExpandOpen()); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Options for expanding indices names</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-get-mappings-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>GetMappingsRequest</code> in the following manner, the client waits
for the <code>GetMappingsResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            GetMappingsResponse getMappingResponse = client.indices().getMapping(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-get-mappings-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>GetMappingsRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous get-mappings method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.indices().getMappingAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>GetMappingsRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>get-mappings</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ActionListener&lt;GetMappingsResponse&gt; listener =
                new ActionListener&lt;GetMappingsResponse&gt;() {
                    @Override
                    public void onResponse(GetMappingsResponse putMappingResponse) {
                        // <b class="conum">(1)</b>
                    }

                    @Override
                    public void onFailure(Exception e) {
                        // <b class="conum">(2)</b>
                    }
                };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>GetMappingsRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-get-mappings-response">Get Mappings Response</h4>
<div class="paragraph">
<p>The returned <code>GetMappingsResponse</code> allows to retrieve information about the
executed operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            Map&lt;String, MappingMetadata&gt; allMappings = getMappingResponse.mappings(); // <b class="conum">(1)</b>
            MappingMetadata indexMapping = allMappings.get("twitter"); // <b class="conum">(2)</b>
            Map&lt;String, Object&gt; mapping = indexMapping.sourceAsMap(); // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Returning all indices' mappings</p>
</li>
<li>
<p>Retrieving the mappings for a particular index</p>
</li>
<li>
<p>Getting the mappings as a Java Map</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-get-field-mappings">Get Field Mappings API</h3>
<div class="sect3">
<h4 id="java-rest-high-get-field-mappings-request">Get Field Mappings Request</h4>
<div class="paragraph">
<p>A <code>GetFieldMappingsRequest</code> can have an optional list of indices, optional list of types and the list of fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        GetFieldMappingsRequest request = new GetFieldMappingsRequest(); // <b class="conum">(1)</b>
        request.indices("twitter"); // <b class="conum">(2)</b>
        request.fields("message", "timestamp"); // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>An empty request</p>
</li>
<li>
<p>Setting the indices to fetch mapping for</p>
</li>
<li>
<p>The fields to be returned</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_31">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can also optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.indicesOptions(IndicesOptions.lenientExpandOpen()); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Setting <code>IndicesOptions</code> controls how unavailable indices are resolved and
how wildcard expressions are expanded</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.local(true); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Deprecated. This parameter is a no-op and field mappings are always retrieved locally
The <code>local</code> flag (defaults to <code>false</code>) controls whether the aliases need
to be looked up in the local cluster state or in the cluster state held by
the elected master node</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-get-field-mappings-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>GetFieldMappingsRequest</code> in the following manner, the client waits
for the <code>GetFieldMappingsResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            GetFieldMappingsResponse response =
                client.indices().getFieldMapping(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-get-field-mappings-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>GetFieldMappingsRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous get-field-mappings method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.indices().getFieldMappingAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>GetFieldMappingsRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>get-field-mappings</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ActionListener&lt;GetFieldMappingsResponse&gt; listener =
                new ActionListener&lt;GetFieldMappingsResponse&gt;() {
                    @Override
                    public void onResponse(GetFieldMappingsResponse putMappingResponse) {
                        // <b class="conum">(1)</b>
                    }

                    @Override
                    public void onFailure(Exception e) {
                        // <b class="conum">(2)</b>
                    }
                };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>GetFieldMappingsRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-get-field-mappings-response">Get Field Mappings Response</h4>
<div class="paragraph">
<p>The returned <code>GetFieldMappingsResponse</code> allows to retrieve information about the
executed operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            final Map&lt;String, Map&lt;String, GetFieldMappingsResponse.FieldMappingMetadata&gt;&gt; mappings =
                response.mappings();// <b class="conum">(1)</b>
            final Map&lt;String, GetFieldMappingsResponse.FieldMappingMetadata&gt; fieldMappings =
                mappings.get("twitter"); // <b class="conum">(2)</b>
            final GetFieldMappingsResponse.FieldMappingMetadata metadata =
                fieldMappings.get("message");// <b class="conum">(3)</b>

            final String fullName = metadata.fullName();// <b class="conum">(4)</b>
            final Map&lt;String, Object&gt; source = metadata.sourceAsMap(); // <b class="conum">(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Returning all requested indices fields' mappings</p>
</li>
<li>
<p>Retrieving the mappings for a particular index</p>
</li>
<li>
<p>Getting the mappings metadata for the <code>message</code> field</p>
</li>
<li>
<p>Getting the full name of the field</p>
</li>
<li>
<p>Getting the mapping source of the field</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-update-aliases">Index Aliases API</h3>
<div class="sect3">
<h4 id="java-rest-high-update-aliases-request">Indices Aliases Request</h4>
<div class="paragraph">
<p>The Index Aliases API allows aliasing an index with a name, with all APIs
automatically converting the alias name to the actual index name.</p>
</div>
<div class="paragraph">
<p>An <code>IndicesAliasesRequest</code> must have at least one <code>AliasActions</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            IndicesAliasesRequest request = new IndicesAliasesRequest(); // <b class="conum">(1)</b>
            AliasActions aliasAction =
                    new AliasActions(AliasActions.Type.ADD)
                    .index("index1")
                    .alias("alias1"); // <b class="conum">(2)</b>
            request.addAliasAction(aliasAction); // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Creates an <code>IndicesAliasesRequest</code></p>
</li>
<li>
<p>Creates an <code>AliasActions</code> that aliases index <code>test1</code> with <code>alias1</code></p>
</li>
<li>
<p>Adds the alias action to the request</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following action types are supported: <code>add</code> - alias an index, <code>remove</code> -
removes the alias associated with the index, and <code>remove_index</code> - deletes the
index.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            AliasActions addIndexAction =
                    new AliasActions(AliasActions.Type.ADD)
                    .index("index1")
                    .alias("alias1")
                    .filter("{\"term\":{\"year\":2016}}"); // <b class="conum">(1)</b>
            AliasActions addIndicesAction =
                    new AliasActions(AliasActions.Type.ADD)
                    .indices("index1", "index2")
                    .alias("alias2")
                    .routing("1"); // <b class="conum">(2)</b>
            AliasActions removeAction =
                    new AliasActions(AliasActions.Type.REMOVE)
                    .index("index3")
                    .alias("alias3"); // <b class="conum">(3)</b>
            AliasActions removeIndexAction =
                    new AliasActions(AliasActions.Type.REMOVE_INDEX)
                    .index("index4"); // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Creates an alias <code>alias1</code> with an optional filter on field <code>year</code></p>
</li>
<li>
<p>Creates an alias <code>alias2</code> associated with two indices and with an optional routing</p>
</li>
<li>
<p>Removes the associated alias <code>alias3</code></p>
</li>
<li>
<p><code>remove_index</code> is just like <a href="_index_apis.html#java-rest-high-delete-index">Delete Index API</a></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_32">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.timeout(TimeValue.timeValueMinutes(2)); // <b class="conum">(1)</b>
            request.timeout("2m"); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to wait for the all the nodes to acknowledge the operation as a <code>TimeValue</code></p>
</li>
<li>
<p>Timeout to wait for the all the nodes to acknowledge the operation as a <code>String</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.masterNodeTimeout(TimeValue.timeValueMinutes(1)); // <b class="conum">(1)</b>
            request.masterNodeTimeout("1m"); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to connect to the master node as a <code>TimeValue</code></p>
</li>
<li>
<p>Timeout to connect to the master node as a <code>String</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-update-aliases-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>IndicesAliasesRequest</code> in the following manner, the client waits
for the <code>IndicesAliasesResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            AcknowledgedResponse indicesAliasesResponse =
                    client.indices().updateAliases(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-update-aliases-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>IndicesAliasesRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous update-aliases method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.indices().updateAliasesAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>IndicesAliasesRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>update-aliases</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ActionListener&lt;AcknowledgedResponse&gt; listener =
                    new ActionListener&lt;AcknowledgedResponse&gt;() {
                @Override
                public void onResponse(AcknowledgedResponse indicesAliasesResponse) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>IndicesAliasesRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-update-aliases-response">Indices Aliases Response</h4>
<div class="paragraph">
<p>The returned <code>IndicesAliasesResponse</code> allows to retrieve information about the
executed operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            boolean acknowledged = indicesAliasesResponse.isAcknowledged(); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Indicates whether all of the nodes have acknowledged the request</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-delete-alias">Delete Alias API</h3>
<div class="sect3">
<h4 id="java-rest-high-delete-alias-request">Delete Alias Request</h4>
<div class="paragraph">
<p>An <code>DeleteAliasRequest</code> requires an <code>index</code> and an <code>alias</code> argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            DeleteAliasRequest request = new DeleteAliasRequest("index1", "alias1");</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_33">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setTimeout(TimeValue.timeValueMinutes(2)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to wait for the all the nodes to acknowledge the index is opened
as a <code>TimeValue</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setMasterTimeout(TimeValue.timeValueMinutes(1)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to connect to the master node as a <code>TimeValue</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-delete-alias-response">Delete Alias Response</h4>
<div class="paragraph">
<p>The returned <code>AcknowledgedResponse</code> indicates if the request to delete the alias
was received.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            boolean acknowledged = deleteAliasResponse.isAcknowledged(); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Whether or not the request to delete the alias was
acknowledged.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-delete-alias-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>DeleteAliasRequest</code> in the following manner, the client waits
for the <code>AcknowledgedResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            org.opensearch.client.core.AcknowledgedResponse deleteAliasResponse =
                client.indices().deleteAlias(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-delete-alias-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>DeleteAliasRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous delete-alias method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.indices().deleteAliasAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>DeleteAliasRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>delete-alias</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ActionListener&lt;org.opensearch.client.core.AcknowledgedResponse&gt; listener =
                new ActionListener&lt;org.opensearch.client.core.AcknowledgedResponse&gt;() {
                    @Override
                    public void onResponse(org.opensearch.client.core.AcknowledgedResponse deleteAliasResponse) {
                        // <b class="conum">(1)</b>
                    }

                    @Override
                    public void onFailure(Exception e) {
                        // <b class="conum">(2)</b>
                    }
                };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>DeleteAliasRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-exists-alias">Exists Alias API</h3>
<div class="sect3">
<h4 id="java-rest-high-exists-alias-request">Exists Alias Request</h4>
<div class="paragraph">
<p>The Exists Alias API uses <code>GetAliasesRequest</code> as its request object.
One or more aliases can be optionally provided either at construction
time or later on through the relevant setter method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            GetAliasesRequest request = new GetAliasesRequest();
            GetAliasesRequest requestWithAlias = new GetAliasesRequest("alias1");
            GetAliasesRequest requestWithAliases =
                    new GetAliasesRequest(new String[]{"alias1", "alias2"});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_34">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.aliases("alias"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>One or more aliases to look for</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.indices("index"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The index or indices that the alias is associated with</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.indicesOptions(IndicesOptions.lenientExpandOpen()); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Setting <code>IndicesOptions</code> controls how unavailable indices are resolved and
how wildcard expressions are expanded</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.local(true); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>local</code> flag (defaults to <code>false</code>) controls whether the aliases need
to be looked up in the local cluster state or in the cluster state held by
the elected master node</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-exists-alias-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>GetAliasesRequest</code> in the following manner, the client waits
for the <code>Boolean</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            boolean exists = client.indices().existsAlias(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-exists-alias-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>GetAliasesRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous exists-alias method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.indices().existsAliasAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>GetAliasesRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>exists-alias</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ActionListener&lt;Boolean&gt; listener = new ActionListener&lt;Boolean&gt;() {
                @Override
                public void onResponse(Boolean exists) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>GetAliasesRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-exists-alias-response">Exists Alias Response</h4>
<div class="paragraph">
<p>The Exists Alias API returns a <code>Boolean</code> that indicates whether the provided
alias (or aliases) was found or not.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-get-alias">Get Alias API</h3>
<div class="sect3">
<h4 id="java-rest-high-get-alias-request">Get Alias Request</h4>
<div class="paragraph">
<p>The Get Alias API uses <code>GetAliasesRequest</code> as its request object.
One or more aliases can be optionally provided either at construction
time or later on through the relevant setter method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            GetAliasesRequest request = new GetAliasesRequest();
            GetAliasesRequest requestWithAlias = new GetAliasesRequest("alias1");
            GetAliasesRequest requestWithAliases =
                    new GetAliasesRequest(new String[]{"alias1", "alias2"});</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_35">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.aliases("alias"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>One or more aliases to retrieve</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.indices("index"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The index or indices that the alias is associated with</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.indicesOptions(IndicesOptions.lenientExpandOpen()); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Setting <code>IndicesOptions</code> controls how unavailable indices are resolved and
how wildcard expressions are expanded when looking for aliases that belong to
specified indices.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.local(true); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>local</code> flag (defaults to <code>false</code>) controls whether the aliases need
to be looked up in the local cluster state or in the cluster state held by
the elected master node</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-get-alias-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>GetAliasesRequest</code> in the following manner, the client waits
for the <code>GetAliasesResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            GetAliasesResponse response = client.indices().getAlias(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-get-alias-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>GetAliasesRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous get-alias method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.indices().getAliasAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>GetAliasesRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>get-alias</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ActionListener&lt;GetAliasesResponse&gt; listener =
                    new ActionListener&lt;GetAliasesResponse&gt;() {
                        @Override
                        public void onResponse(GetAliasesResponse getAliasesResponse) {
                            // <b class="conum">(1)</b>
                        }

                        @Override
                        public void onFailure(Exception e) {
                            // <b class="conum">(2)</b>
                        }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>GetAliasesRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-get-alias-response">Get Alias Response</h4>
<div class="paragraph">
<p>The returned <code>GetAliasesResponse</code> allows to retrieve information about the
executed operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            Map&lt;String, Set&lt;AliasMetadata&gt;&gt; aliases = response.getAliases(); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Retrieves a map of indices and their aliases</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>GetAliasesResponse</code> class contains information about errors if they occurred.
This info could be in fields <code>error</code> or <code>exception</code> depends on a case.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            RestStatus status = response.status(); // <b class="conum">(1)</b>
            OpenSearchException exception = response.getException(); // <b class="conum">(2)</b>
            String error = response.getError(); // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Client sets status to <code>NOT_FOUND</code> if at least one item of specified
indices or aliases is not found. Otherwise it is <code>OK</code>.</p>
</li>
<li>
<p>If at least one item of specified indices isn&#8217;t exist client sets
<code>OpenSearchException</code> and returns empty result.</p>
</li>
<li>
<p>If at least one item of specified aliases ins&#8217;t exist client puts
error description in <code>error</code> field and returns partial result if any
of other patterns match.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If user specified indices or aliases as regular expressions
and nothing was found client returns <code>OK</code> status and no errors.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-indices-put-settings">Update Indices Settings API</h3>
<div class="paragraph">
<p>The Update Indices Settings API allows to change specific index level settings.</p>
</div>
<div class="sect3">
<h4 id="java-rest-high-indices-put-settings-request">Update Indices Settings Request</h4>
<div class="paragraph">
<p>An <code>UpdateSettingsRequest</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        UpdateSettingsRequest request = new UpdateSettingsRequest("index1"); // <b class="conum">(1)</b>
        UpdateSettingsRequest requestMultiple =
                new UpdateSettingsRequest("index1", "index2"); // <b class="conum">(2)</b>
        UpdateSettingsRequest requestAll = new UpdateSettingsRequest(); // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Update settings for one index</p>
</li>
<li>
<p>Update settings for multiple indices</p>
</li>
<li>
<p>Update settings for all indices</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_indices_settings">Indices Settings</h4>
<div class="paragraph">
<p>At least one setting to be updated must be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        String settingKey = "index.number_of_replicas";
        int settingValue = 0;
        Settings settings =
                Settings.builder()
                .put(settingKey, settingValue)
                .build(); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Sets the index settings to be applied</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_providing_the_settings">Providing the Settings</h4>
<div class="paragraph">
<p>The settings to be applied can be provided in different ways:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        String settingKey = "index.number_of_replicas";
        int settingValue = 0;
        Settings settings =
                Settings.builder()
                .put(settingKey, settingValue)
                .build(); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Creates a setting as <code>Settings</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            Settings.Builder settingsBuilder =
                    Settings.builder()
                    .put(settingKey, settingValue);
            request.settings(settingsBuilder); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Settings provided as <code>Settings.Builder</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.settings(
                    "{\"index.number_of_replicas\": \"2\"}"
                    , XContentType.JSON); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Settings provided as <code>String</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
            map.put(settingKey, settingValue);
            request.settings(map); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Settings provided as a <code>Map</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_36">Optional Arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.setPreserveExisting(false); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Whether to update existing settings. If set to <code>true</code> existing settings
on an index remain unchanged, the default is <code>false</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.timeout(TimeValue.timeValueMinutes(2)); // <b class="conum">(1)</b>
        request.timeout("2m"); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to wait for the all the nodes to acknowledge the new setting
as a <code>TimeValue</code></p>
</li>
<li>
<p>Timeout to wait for the all the nodes to acknowledge the new setting
as a <code>String</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.masterNodeTimeout(TimeValue.timeValueMinutes(1)); // <b class="conum">(1)</b>
        request.masterNodeTimeout("1m"); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to connect to the master node as a <code>TimeValue</code></p>
</li>
<li>
<p>Timeout to connect to the master node as a <code>String</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.indicesOptions(IndicesOptions.lenientExpandOpen()); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Setting <code>IndicesOptions</code> controls how unavailable indices are resolved and
how wildcard expressions are expanded</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-indices-put-settings-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>UpdateSettingsRequest</code> in the following manner, the client waits
for the <code>UpdateSettingsResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        AcknowledgedResponse updateSettingsResponse =
                client.indices().putSettings(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-indices-put-settings-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>UpdateSettingsRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous indices-put-settings method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        client.indices().putSettingsAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>UpdateSettingsRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>indices-put-settings</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ActionListener&lt;AcknowledgedResponse&gt; listener =
                new ActionListener&lt;AcknowledgedResponse&gt;() {

            @Override
            public void onResponse(AcknowledgedResponse updateSettingsResponse) {
                // <b class="conum">(1)</b>
            }

            @Override
            public void onFailure(Exception e) {
                // <b class="conum">(2)</b>
            }
        };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>UpdateSettingsRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-indices-put-settings-response">Update Indices Settings Response</h4>
<div class="paragraph">
<p>The returned <code>UpdateSettingsResponse</code> allows to retrieve information about the
executed operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        boolean acknowledged = updateSettingsResponse.isAcknowledged(); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Indicates whether all of the nodes have acknowledged the request</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-get-settings">Get Settings API</h3>
<div class="sect3">
<h4 id="java-rest-high-get-settings-request">Get Settings Request</h4>
<div class="paragraph">
<p>A <code>GetSettingsRequest</code> requires one or more <code>index</code> arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        GetSettingsRequest request = new GetSettingsRequest().indices("index"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The index whose settings we should retrieve</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_37">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.names("index.number_of_shards"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>One or more settings that be the only settings retrieved.  If unset, all settings will be retrieved</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.includeDefaults(true); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>If true, defaults will be returned for settings not explicitly set on the index</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.indicesOptions(IndicesOptions.lenientExpandOpen()); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Setting <code>IndicesOptions</code> controls how unavailable indices are resolved and
how wildcard expressions are expanded</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-get-settings-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>GetSettingsRequest</code> in the following manner, the client waits
for the <code>GetSettingsResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        GetSettingsResponse getSettingsResponse = client.indices().getSettings(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-get-settings-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>GetSettingsRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous get-settings method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        client.indices().getSettingsAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>GetSettingsRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>get-settings</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ActionListener&lt;GetSettingsResponse&gt; listener =
            new ActionListener&lt;GetSettingsResponse&gt;() {
                @Override
                public void onResponse(GetSettingsResponse GetSettingsResponse) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>GetSettingsRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-get-settings-response">Get Settings Response</h4>
<div class="paragraph">
<p>The returned <code>GetSettingsResponse</code> allows to retrieve information about the
executed operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        String numberOfShardsString = getSettingsResponse.getSetting("index", "index.number_of_shards"); // <b class="conum">(1)</b>
        Settings indexSettings = getSettingsResponse.getIndexToSettings().get("index"); // <b class="conum">(2)</b>
        Integer numberOfShards = indexSettings.getAsInt("index.number_of_shards", null); // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>We can retrieve the setting value for a particular index directly from the response as a string</p>
</li>
<li>
<p>We can also retrieve the Settings object for a particular index for further examination</p>
</li>
<li>
<p>The returned Settings object provides convenience methods for non String types</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If the <code>includeDefaults</code> flag was set to true in the <code>GetSettingsRequest</code> the
behavior of <code>GetSettingsResponse</code> will differ somewhat.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        String refreshInterval = getSettingsResponse.getSetting("index", "index.refresh_interval"); // <b class="conum">(1)</b>
        Settings indexDefaultSettings = getSettingsResponse.getIndexToDefaultSettings().get("index"); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Individual default setting values may be retrieved directly from the <code>GetSettingsResponse</code></p>
</li>
<li>
<p>We may retrieve a Settings object for an index that contains those settings with default values</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-put-template">Put Template API</h3>
<div class="sect3">
<h4 id="java-rest-high-put-template-request">Put Index Template Request</h4>
<div class="paragraph">
<p>A <code>PutIndexTemplateRequest</code> specifies the <code>name</code> of a template and <code>patterns</code>
which controls whether the template should be applied to the new index.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        PutIndexTemplateRequest request = new PutIndexTemplateRequest("my-template"); // <b class="conum">(1)</b>
        request.patterns(Arrays.asList("pattern-1", "log-*")); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The name of the template</p>
</li>
<li>
<p>The patterns of the template</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_settings">Settings</h4>
<div class="paragraph">
<p>The settings of the template will be applied to the new index whose name matches the
template&#8217;s patterns.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.settings(Settings.builder() // <b class="conum">(1)</b>
            .put("index.number_of_shards", 3)
            .put("index.number_of_replicas", 1)
        );</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Settings for this template</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-put-template-request-mappings">Mappings</h4>
<div class="paragraph">
<p>The mapping of the template will be applied to the new index whose name matches the
template&#8217;s patterns.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.mapping(// <b class="conum">(1)</b>
                "{\n" +
                    "  \"properties\": {\n" +
                    "    \"message\": {\n" +
                    "      \"type\": \"text\"\n" +
                    "    }\n" +
                    "  }\n" +
                    "}",
                XContentType.JSON);</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The mapping, provided as a JSON string</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The mapping source can be provided in different ways in addition to the
<code>String</code> example shown above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            Map&lt;String, Object&gt; jsonMap = new HashMap&lt;&gt;();
            {
                Map&lt;String, Object&gt; properties = new HashMap&lt;&gt;();
                {
                    Map&lt;String, Object&gt; message = new HashMap&lt;&gt;();
                    message.put("type", "text");
                    properties.put("message", message);
                }
                jsonMap.put("properties", properties);
            }
            request.mapping(jsonMap); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Mapping source provided as a <code>Map</code> which gets automatically converted
to JSON format</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            XContentBuilder builder = XContentFactory.jsonBuilder();
            builder.startObject();
            {
                builder.startObject("properties");
                {
                    builder.startObject("message");
                    {
                        builder.field("type", "text");
                    }
                    builder.endObject();
                }
                builder.endObject();
            }
            builder.endObject();
            request.mapping(builder); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Mapping source provided as an <code>XContentBuilder</code> object, the OpenSearch
built-in helpers to generate JSON content</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_aliases">Aliases</h4>
<div class="paragraph">
<p>The aliases of the template will define aliasing to the index whose name matches the
template&#8217;s patterns. A placeholder <code>{index}</code> can be used in an alias of a template.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.alias(new Alias("twitter_alias").filter(QueryBuilders.termQuery("user", "kimchy")));  // <b class="conum">(1)</b>
        request.alias(new Alias("{index}_alias").searchRouting("xyz"));  // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The alias to define</p>
</li>
<li>
<p>The alias to define with placeholder</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_order">Order</h4>
<div class="paragraph">
<p>In case multiple templates match an index, the orders of matching templates determine
the sequence that settings, mappings, and alias of each matching template is applied.
Templates with lower orders are applied first, and higher orders override them.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.order(20);  // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The order of the template</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_version">Version</h4>
<div class="paragraph">
<p>A template can optionally specify a version number which can be used to simplify template
management by external systems.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.version(4);  // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The version number of the template</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_providing_the_whole_source_2">Providing the whole source</h4>
<div class="paragraph">
<p>The whole source including all of its sections (mappings, settings and aliases)
can also be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.source("{\n" +
            "  \"index_patterns\": [\n" +
            "    \"log-*\",\n" +
            "    \"pattern-1\"\n" +
            "  ],\n" +
            "  \"order\": 1,\n" +
            "  \"settings\": {\n" +
            "    \"number_of_shards\": 1\n" +
            "  },\n" +
            "  \"mappings\": {\n" +
            "    \"properties\": {\n" +
            "      \"message\": {\n" +
            "        \"type\": \"text\"\n" +
            "      }\n" +
            "    }\n" +
            "  },\n" +
            "  \"aliases\": {\n" +
            "    \"alias-1\": {},\n" +
            "    \"{index}-alias\": {}\n" +
            "  }\n" +
            "}", XContentType.JSON); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The source provided as a JSON string. It can also be provided as a <code>Map</code>
or an <code>XContentBuilder</code>.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_38">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.create(true);  // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>To force to only create a new template; do not overwrite the existing template</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.masterNodeTimeout(TimeValue.timeValueMinutes(1)); // <b class="conum">(1)</b>
        request.masterNodeTimeout("1m"); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to connect to the master node as a <code>TimeValue</code></p>
</li>
<li>
<p>Timeout to connect to the master node as a <code>String</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-put-template-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>PutIndexTemplateRequest</code> in the following manner, the client waits
for the <code>PutIndexTemplateResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        AcknowledgedResponse putTemplateResponse = client.indices().putTemplate(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-put-template-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>PutIndexTemplateRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous put-template method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        client.indices().putTemplateAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>PutIndexTemplateRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>put-template</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ActionListener&lt;AcknowledgedResponse&gt; listener =
            new ActionListener&lt;AcknowledgedResponse&gt;() {
                @Override
                public void onResponse(AcknowledgedResponse putTemplateResponse) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>PutIndexTemplateRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-put-template-response">Put Index Template Response</h4>
<div class="paragraph">
<p>The returned <code>PutIndexTemplateResponse</code> allows to retrieve information about the
executed operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        boolean acknowledged = putTemplateResponse.isAcknowledged(); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Indicates whether all of the nodes have acknowledged the request</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-indices-validate-query">Validate Query API</h3>
<div class="sect3">
<h4 id="java-rest-high-indices-validate-query-request">Validate Query Request</h4>
<div class="paragraph">
<p>A <code>ValidateQueryRequest</code> requires one or more <code>indices</code> on which the query is validated. If no index
is provided the request is executed on all indices.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ValidateQueryRequest request = new ValidateQueryRequest(index); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The index on which to run the request.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In addition it also needs the query that needs to be validated. The query can be built using the <code>QueryBuilders</code> utility class.
The following code snippet builds a sample boolean query.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        QueryBuilder builder = QueryBuilders
            .boolQuery() // <b class="conum">(1)</b>
            .must(QueryBuilders.queryStringQuery("*:*"))
            .filter(QueryBuilders.termQuery("user", "kimchy"));
        request.query(builder); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Build the desired query.</p>
</li>
<li>
<p>Set it to the request.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_39">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.explain(true); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The explain parameter can be set to true to get more detailed information about why a query failed</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By default, the request is executed on a single shard only, which is randomly selected. The detailed explanation of
the query may depend on which shard is being hit, and therefore may vary from one request to another. So, in case of
query rewrite the <code>allShards</code> parameter should be used to get response from all available shards.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.allShards(true); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set the allShards parameter.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When the query is valid, the explanation defaults to the string representation of that query. With rewrite set to true,
the explanation is more detailed showing the actual Lucene query that will be executed</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.rewrite(true); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set the rewrite parameter.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-indices-validate-query-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>ValidateQueryRequest</code> in the following manner, the client waits
for the <code>ValidateQueryResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ValidateQueryResponse response = client.indices().validateQuery(request, RequestOptions.DEFAULT); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-indices-validate-query-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>ValidateQueryRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous indices-validate-query method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        client.indices().validateQueryAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>ValidateQueryRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>indices-validate-query</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ActionListener&lt;ValidateQueryResponse&gt; listener =
            new ActionListener&lt;ValidateQueryResponse&gt;() {
                @Override
                public void onResponse(ValidateQueryResponse validateQueryResponse) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>ValidateQueryRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-indices-validate-query-response">Validate Query Response</h4>
<div class="paragraph">
<p>The returned <code>ValidateQueryResponse</code> allows to retrieve information about the executed
 operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        boolean isValid = response.isValid(); // <b class="conum">(1)</b>
        int totalShards = response.getTotalShards(); // <b class="conum">(2)</b>
        int successfulShards = response.getSuccessfulShards(); // <b class="conum">(3)</b>
        int failedShards = response.getFailedShards(); // <b class="conum">(4)</b>
        if (failedShards &gt; 0) {
            for(DefaultShardOperationFailedException failure: response.getShardFailures()) { // <b class="conum">(5)</b>
                String failedIndex = failure.index(); // <b class="conum">(6)</b>
                int shardId = failure.shardId(); // <b class="conum">(7)</b>
                String reason = failure.reason(); // <b class="conum">(8)</b>
            }
        }
        for(QueryExplanation explanation: response.getQueryExplanation()) { // <b class="conum">(9)</b>
            String explanationIndex = explanation.getIndex(); // <b class="conum">(10)</b>
            int shardId = explanation.getShard(); // <b class="conum">(11)</b>
            String explanationString = explanation.getExplanation(); // <b class="conum">(12)</b>
        }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Check if the query is valid or not.</p>
</li>
<li>
<p>Get total number of shards.</p>
</li>
<li>
<p>Get number of shards that were successful.</p>
</li>
<li>
<p>Get number of shards that failed.</p>
</li>
<li>
<p>Get the shard failures as <code>DefaultShardOperationFailedException</code>.</p>
</li>
<li>
<p>Get the index of a failed shard.</p>
</li>
<li>
<p>Get the shard id of a failed shard.</p>
</li>
<li>
<p>Get the reason for shard failure.</p>
</li>
<li>
<p>Get the detailed explanation for the shards (if explain was set to <code>true</code>).</p>
</li>
<li>
<p>Get the index to which a particular explanation belongs.</p>
</li>
<li>
<p>Get the shard id to which a particular explanation belongs.</p>
</li>
<li>
<p>Get the actual explanation string.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-get-templates">Get Templates API</h3>
<div class="paragraph">
<p>The Get Templates API allows to retrieve a list of index templates by name.</p>
</div>
<div class="sect3">
<h4 id="java-rest-high-get-templates-request">Get Index Templates Request</h4>
<div class="paragraph">
<p>A <code>GetIndexTemplatesRequest</code> specifies one or several names of the index templates to get.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        GetIndexTemplatesRequest request = new GetIndexTemplatesRequest("my-template"); // <b class="conum">(1)</b>
        request = new GetIndexTemplatesRequest("template-1", "template-2"); // <b class="conum">(2)</b>
        request = new GetIndexTemplatesRequest("my-*"); // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A single index template name</p>
</li>
<li>
<p>Multiple index template names</p>
</li>
<li>
<p>An index template name using wildcard</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.setMasterNodeTimeout(TimeValue.timeValueMinutes(1)); // &lt;1&gt;
        request.setMasterNodeTimeout("1m"); // &lt;2&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to connect to the master node as a <code>TimeValue</code></p>
</li>
<li>
<p>Timeout to connect to the master node as a <code>String</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-get-templates-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>GetIndexTemplatesRequest</code> in the following manner, the client waits
for the <code>GetIndexTemplatesResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        GetIndexTemplatesResponse getTemplatesResponse = client.indices().getIndexTemplate(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-get-templates-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>GetIndexTemplatesRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous get-templates method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        client.indices().getIndexTemplateAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>GetIndexTemplatesRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>get-templates</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ActionListener&lt;GetIndexTemplatesResponse&gt; listener =
            new ActionListener&lt;GetIndexTemplatesResponse&gt;() {
                @Override
                public void onResponse(GetIndexTemplatesResponse response) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>GetIndexTemplatesRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-get-templates-response">Get Templates Response</h4>
<div class="paragraph">
<p>The returned <code>GetIndexTemplatesResponse</code> consists a list of matching index templates.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        List&lt;IndexTemplateMetadata&gt; templates = getTemplatesResponse.getIndexTemplates(); // &lt;1&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A list of matching index templates</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-templates-exist">Templates Exist API</h3>
<div class="sect3">
<h4 id="java-rest-high-templates-exist-request">Templates Exist Request</h4>
<div class="paragraph">
<p>The Templates Exist API uses <code>IndexTemplatesExistRequest</code> as its request object. One or more
index template names can be provided at construction.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            IndexTemplatesExistRequest request;
            request = new IndexTemplatesExistRequest("my-template"); // <b class="conum">(1)</b>
            request = new IndexTemplatesExistRequest("template-1", "template-2"); // <b class="conum">(2)</b>
            request = new IndexTemplatesExistRequest("my-*"); // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A single index template name</p>
</li>
<li>
<p>Multiple index template names</p>
</li>
<li>
<p>An index template name using wildcard</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_40">Optional arguments</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setLocal(true); // <b class="conum">(1)</b>
            request.setMasterNodeTimeout(TimeValue.timeValueMinutes(1)); // <b class="conum">(2)</b>
            request.setMasterNodeTimeout("1m"); // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>If <code>true</code>, reads templates from the node&#8217;s local cluster state. Otherwise
reads from the cluster state of the elected master node</p>
</li>
<li>
<p>Timeout to connect to the master node as a <code>TimeValue</code></p>
</li>
<li>
<p>Timeout to connect to the master node as a <code>String</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-templates-exist-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>IndexTemplatesExistRequest</code> in the following manner, the client waits
for the <code>Boolean</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            boolean exists = client.indices().existsTemplate(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-templates-exist-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>IndexTemplatesExistRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous templates-exist method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.indices().existsTemplateAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>IndexTemplatesExistRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>templates-exist</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ActionListener&lt;Boolean&gt; listener = new ActionListener&lt;Boolean&gt;() {
                @Override
                public void onResponse(Boolean aBoolean) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>IndexTemplatesExistRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-templates-exist-response">Response</h4>
<div class="paragraph">
<p>The response is a <code>Boolean</code> value, <code>true</code> if any of the request&#8217;s template
names match existing templates and <code>false</code> otherwise</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-get-index">Get Index API</h3>
<div class="sect3">
<h4 id="java-rest-high-get-index-request">Get Index Request</h4>
<div class="paragraph">
<p>A <code>GetIndexRequest</code> requires one or more <code>index</code> arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        GetIndexRequest request = new GetIndexRequest("index"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The index whose information we want to retrieve</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_41">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.includeDefaults(true); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>If true, defaults will be returned for settings not explicitly set on the index</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.indicesOptions(IndicesOptions.lenientExpandOpen()); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Setting <code>IndicesOptions</code> controls how unavailable indices are resolved and
how wildcard expressions are expanded</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-get-index-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>GetIndexRequest</code> in the following manner, the client waits
for the <code>GetIndexResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        GetIndexResponse getIndexResponse = client.indices().get(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-get-index-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>GetIndexRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous get-index method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        client.indices().getAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>GetIndexRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>get-index</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ActionListener&lt;GetIndexResponse&gt; listener =
            new ActionListener&lt;GetIndexResponse&gt;() {
                @Override
                public void onResponse(GetIndexResponse getIndexResponse) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>GetIndexRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-get-index-response">Get Index Response</h4>
<div class="paragraph">
<p>The returned <code>GetIndexResponse</code> allows to retrieve information about the
executed operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        MappingMetadata indexMappings = getIndexResponse.getMappings().get("index"); // <b class="conum">(1)</b>
        Map&lt;String, Object&gt; indexTypeMappings = indexMappings.getSourceAsMap(); // <b class="conum">(2)</b>
        List&lt;AliasMetadata&gt; indexAliases = getIndexResponse.getAliases().get("index"); // <b class="conum">(3)</b>
        String numberOfShardsString = getIndexResponse.getSetting("index", "index.number_of_shards"); // <b class="conum">(4)</b>
        Settings indexSettings = getIndexResponse.getSettings().get("index"); // <b class="conum">(5)</b>
        Integer numberOfShards = indexSettings.getAsInt("index.number_of_shards", null); // <b class="conum">(6)</b>
        TimeValue time = getIndexResponse.getDefaultSettings().get("index")
            .getAsTime("index.refresh_interval", null); // <b class="conum">(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Retrieve a Map of different types to <code>MappingMetadata</code> for <code>index</code>.</p>
</li>
<li>
<p>Retrieve a Map for the properties for document type <code>doc</code>.</p>
</li>
<li>
<p>Get the list of aliases for <code>index</code>.</p>
</li>
<li>
<p>Get the value for the setting string <code>index.number_of_shards</code> for <code>index</code>. If the setting was not explicitly
specified but was part of the default settings (and includeDefault was <code>true</code>) then the default setting would be
retrieved.</p>
</li>
<li>
<p>Retrieve all settings for <code>index</code>.</p>
</li>
<li>
<p>The <code>Settings</code> objects gives more flexibility. Here it is used to extract the setting <code>index.number_of_shards</code> as an
integer.</p>
</li>
<li>
<p>Get the default setting <code>index.refresh_interval</code> (if <code>includeDefault</code> was set to <code>true</code>). If <code>includeDefault</code> was set
to <code>false</code>, <code>getIndexResponse.defaultSettings()</code> will return an empty map.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-delete-template">Delete Template API</h3>
<div class="sect3">
<h4 id="java-rest-high-delete-template-request">Request</h4>
<div class="paragraph">
<p>The Delete Template API allows you to delete an index template.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        DeleteIndexTemplateRequest request = new DeleteIndexTemplateRequest();
        request.name("my-template"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The name of an index template to delete.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-delete-template-response">Response</h4>
<div class="paragraph">
<p>The returned <code>AcknowledgedResponse</code> indicates if the delete template request was received.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        boolean acknowledged = deleteTemplateAcknowledge.isAcknowledged(); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Whether or not the delete template request was acknowledged.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-delete-template-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>DeleteIndexTemplateRequest</code> in the following manner, the client waits
for the <code>AcknowledgedResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        AcknowledgedResponse deleteTemplateAcknowledge = client.indices().deleteTemplate(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-delete-template-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>DeleteIndexTemplateRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous delete-template method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        client.indices().deleteTemplateAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>DeleteIndexTemplateRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>delete-template</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ActionListener&lt;AcknowledgedResponse&gt; listener =
            new ActionListener&lt;AcknowledgedResponse&gt;() {
                @Override
                public void onResponse(AcknowledgedResponse response) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>DeleteIndexTemplateRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-get-index-templates-v2">Get Composable Index Templates API</h3>
<div class="paragraph">
<p>The Get Index Templates API allows to retrieve information about one or more index templates.</p>
</div>
<div class="sect3">
<h4 id="java-rest-high-get-index-templates-v2-request">Get Composable Index Templates Request</h4>
<div class="paragraph">
<p>A <code>GetIndexTemplateV2Request</code> specifies one, or a wildcard expression of index template names
to get. To return all index templates, omit the name altogether or use a value of <code>*</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        GetComposableIndexTemplateRequest request = new GetComposableIndexTemplateRequest("my-template"); // <b class="conum">(1)</b>
        request = new GetComposableIndexTemplateRequest("my-*"); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A single index template name</p>
</li>
<li>
<p>An index template name using wildcard</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        request.setMasterNodeTimeout(TimeValue.timeValueMinutes(1)); // <b class="conum">(1)</b>
        request.setMasterNodeTimeout("1m"); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to connect to the master node as a <code>TimeValue</code></p>
</li>
<li>
<p>Timeout to connect to the master node as a <code>String</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-get-index-templates-v2-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>GetIndexTemplateV2Request</code> in the following manner, the client waits
for the <code>GetIndexTemplatesV2Response</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        GetComposableIndexTemplatesResponse getTemplatesResponse = client.indices().getIndexTemplate(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-get-index-templates-v2-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>GetIndexTemplateV2Request</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous get-index-templates-v2 method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        client.indices().getIndexTemplateAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>GetIndexTemplateV2Request</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>get-index-templates-v2</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ActionListener&lt;GetComposableIndexTemplatesResponse&gt; listener =
            new ActionListener&lt;GetComposableIndexTemplatesResponse&gt;() {
                @Override
                public void onResponse(GetComposableIndexTemplatesResponse response) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>GetIndexTemplateV2Request</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-get-index-templates-v2-response">Get Templates Response</h4>
<div class="paragraph">
<p>The returned <code>GetIndexTemplatesV2Response</code> consists a map of index template names and their corresponding configurations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        Map&lt;String, ComposableIndexTemplate&gt; templates = getTemplatesResponse.getIndexTemplates(); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A map of matching index templates names and the corresponding configurations</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-put-index-template-v2">Put Composable Index Template API</h3>
<div class="sect3">
<h4 id="java-rest-high-put-index-template-v2-request">Put Composable Index Template Request</h4>
<div class="paragraph">
<p>A <code>PutIndexTemplateV2Request</code> specifies the <code>name</code> of a template and the index template configuration
which consists of the <code>patterns</code> that control whether the template should be applied
to the new index, and the optional mappings, settings and aliases configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            PutComposableIndexTemplateRequest request = new PutComposableIndexTemplateRequest()
                .name("my-template"); // <b class="conum">(1)</b>
            ComposableIndexTemplate composableIndexTemplate =
                new ComposableIndexTemplate(Arrays.asList("pattern-1", "log-*"), null, null, null, null, null); // <b class="conum">(2)</b>
            request.indexTemplate(composableIndexTemplate);
            assertTrue(client.indices().putIndexTemplate(request, RequestOptions.DEFAULT).isAcknowledged());</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The name of the template</p>
</li>
<li>
<p>The index template configuration that specifies the index name patterns this template will match</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_settings_2">Settings</h4>
<div class="paragraph">
<p>The settings of the template will be applied to the new index whose name matches the
template&#8217;s patterns.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            PutComposableIndexTemplateRequest request = new PutComposableIndexTemplateRequest()
                .name("my-template");
            Settings settings = Settings.builder() // <b class="conum">(1)</b>
                .put("index.number_of_shards", 3)
                .put("index.number_of_replicas", 1)
                .build();
            Template template = new Template(settings, null, null); // <b class="conum">(2)</b>
            ComposableIndexTemplate composableIndexTemplate = new ComposableIndexTemplate(Arrays.asList("pattern-1", "log-*"),
                template, null, null, null, null); // <b class="conum">(3)</b>
            request.indexTemplate(composableIndexTemplate);

            assertTrue(client.indices().putIndexTemplate(request, RequestOptions.DEFAULT).isAcknowledged());</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Settings for this template</p>
</li>
<li>
<p>Configure the settings on the template building block</p>
</li>
<li>
<p>Create the IndexTemplateV2 object that configures the index template to apply the defined template to indices matching the patterns</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_mappings">Mappings</h4>
<div class="paragraph">
<p>The mapping of the template will be applied to the new index whose name matches the
template&#8217;s patterns.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            String mappingJson = "{\n" +
                "  \"properties\": {\n" +
                "    \"message\": {\n" +
                "      \"type\": \"text\"\n" +
                "    }\n" +
                "  }\n" +
                "}"; // <b class="conum">(1)</b>
            PutComposableIndexTemplateRequest request = new PutComposableIndexTemplateRequest()
                .name("my-template");
            Template template = new Template(null, new CompressedXContent(mappingJson), null); // <b class="conum">(2)</b>
            ComposableIndexTemplate composableIndexTemplate = new ComposableIndexTemplate(Arrays.asList("pattern-1", "log-*"),
                template, null, null, null, null); // <b class="conum">(3)</b>
            request.indexTemplate(composableIndexTemplate);

            assertTrue(client.indices().putIndexTemplate(request, RequestOptions.DEFAULT).isAcknowledged());</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The mapping, provided as a JSON string</p>
</li>
<li>
<p>Configure the mapping on the template building block</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_aliases_2">Aliases</h4>
<div class="paragraph">
<p>The aliases of the template will define aliasing to the index whose name matches the
template&#8217;s patterns. A placeholder <code>{index}</code> can be used in an alias of a template.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            PutComposableIndexTemplateRequest request = new PutComposableIndexTemplateRequest()
                .name("my-template");
            AliasMetadata twitterAlias = AliasMetadata.builder("twitter_alias").build(); // <b class="conum">(1)</b>
            AliasMetadata placeholderAlias = AliasMetadata.builder("{index}_alias").searchRouting("xyz").build(); // <b class="conum">(2)</b>
            Map&lt;String, AliasMetadata&gt; aliases = new HashMap&lt;&gt;();
            aliases.put("twitter_alias", twitterAlias);
            aliases.put("{index}_alias", placeholderAlias);
            Template template = new Template(null, null, aliases); // <b class="conum">(3)</b>
            ComposableIndexTemplate composableIndexTemplate = new ComposableIndexTemplate(Arrays.asList("pattern-1", "log-*"),
                template, null, null, null, null); // <b class="conum">(4)</b>
            request.indexTemplate(composableIndexTemplate);

            assertTrue(client.indices().putIndexTemplate(request, RequestOptions.DEFAULT).isAcknowledged());</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The alias to define</p>
</li>
<li>
<p>The alias to define with placeholder</p>
</li>
<li>
<p>Configure the aliases on the template building block</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_component_templates">Component templates</h4>
<div class="paragraph">
<p>Component templates can be used as building blocks for specifying mappings, settings or aliases
configurations, but they don&#8217;t apply to indices themselves. To be applied to an index, the
component templates must be specified in the <code>componentTemplates</code> list of the <code>IndexTemplateV2</code>
index template definition object. The order in which they are specified in the list is the order
in which the component templates are applied.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            PutComposableIndexTemplateRequest request = new PutComposableIndexTemplateRequest()
                .name("my-template");
            ComposableIndexTemplate composableIndexTemplate =
                    new ComposableIndexTemplate(Arrays.asList("pattern-1", "log-*"), null,
                            Collections.singletonList("ct1"), null, null, null); // <b class="conum">(1)</b>
            request.indexTemplate(composableIndexTemplate);

            assertTrue(client.indices().putIndexTemplate(request, RequestOptions.DEFAULT).isAcknowledged());</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The component template used by this index template</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_priority">Priority</h4>
<div class="paragraph">
<p>In case multiple templates match an index, the priority of matching templates determines
the index template which will be applied.
Index templates with higher priority "win" over index templates with lower priority.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            PutComposableIndexTemplateRequest request = new PutComposableIndexTemplateRequest()
                .name("my-template");
            ComposableIndexTemplate composableIndexTemplate = new ComposableIndexTemplate(Arrays.asList("pattern-1", "log-*"),
                null, null, 20L, null, null); // <b class="conum">(1)</b>
            request.indexTemplate(composableIndexTemplate);

            assertTrue(client.indices().putIndexTemplate(request, RequestOptions.DEFAULT).isAcknowledged());</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The priority of the template</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_version_2">Version</h4>
<div class="paragraph">
<p>A template can optionally specify a version number which can be used to simplify template
management by external systems.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            PutComposableIndexTemplateRequest request = new PutComposableIndexTemplateRequest()
                .name("my-template");
            ComposableIndexTemplate composableIndexTemplate = new ComposableIndexTemplate(Arrays.asList("pattern-1", "log-*"),
                null, null, null, 3L, null); // <b class="conum">(1)</b>
            request.indexTemplate(composableIndexTemplate);

            assertTrue(client.indices().putIndexTemplate(request, RequestOptions.DEFAULT).isAcknowledged());</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The version number of the template</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_42">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.create(true);  // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>To force to only create a new template; do not overwrite the existing template</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setMasterTimeout(TimeValue.timeValueMinutes(1)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to connect to the master node as a <code>TimeValue</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-put-index-template-v2-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>PutIndexTemplateV2Request</code> in the following manner, the client waits
for the <code>AcknowledgedResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            AcknowledgedResponse putTemplateResponse = client.indices().putIndexTemplate(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-put-index-template-v2-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>PutIndexTemplateV2Request</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous put-index-template-v2 method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.indices().putIndexTemplateAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>PutIndexTemplateV2Request</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>put-index-template-v2</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ActionListener&lt;AcknowledgedResponse&gt; listener =
                new ActionListener&lt;AcknowledgedResponse&gt;() {
                    @Override
                    public void onResponse(AcknowledgedResponse putIndexTemplateResponse) {
                        // <b class="conum">(1)</b>
                    }

                    @Override
                    public void onFailure(Exception e) {
                        // <b class="conum">(2)</b>
                    }
                };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>PutIndexTemplateV2Request</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-put-index-template-v2-response">Put Composable Index Template Response</h4>
<div class="paragraph">
<p>The returned <code>AcknowledgedResponse</code> allows to retrieve information about the
executed operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            boolean acknowledged = putTemplateResponse.isAcknowledged(); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Indicates whether all of the nodes have acknowledged the request</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-delete-index-template-v2">Delete Composable Index Template API</h3>
<div class="sect3">
<h4 id="java-rest-high-delete-index-template-v2-request">Request</h4>
<div class="paragraph">
<p>The Delete Composable Index Template API allows you to delete an index template.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        DeleteComposableIndexTemplateRequest deleteRequest = new DeleteComposableIndexTemplateRequest("my-template"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The name of an index template to delete.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_optional_arguments_43">Optional arguments</h3>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        deleteRequest.setMasterTimeout(TimeValue.timeValueMinutes(1)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to connect to the master node as a <code>TimeValue</code></p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="java-rest-high-delete-index-template-v2-response">Response</h4>
<div class="paragraph">
<p>The returned <code>AcknowledgedResponse</code> indicates if the delete template request was received.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        boolean acknowledged = deleteTemplateAcknowledge.isAcknowledged(); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Whether or not the delete template request was acknowledged.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-delete-index-template-v2-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>DeleteIndexTemplateV2Request</code> in the following manner, the client waits
for the <code>AcknowledgedResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        AcknowledgedResponse deleteTemplateAcknowledge = client.indices().deleteIndexTemplate(deleteRequest, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-delete-index-template-v2-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>DeleteIndexTemplateV2Request</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous delete-index-template-v2 method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        client.indices().deleteIndexTemplateAsync(deleteRequest, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>DeleteIndexTemplateV2Request</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>delete-index-template-v2</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ActionListener&lt;AcknowledgedResponse&gt; listener =
            new ActionListener&lt;AcknowledgedResponse&gt;() {
                @Override
                public void onResponse(AcknowledgedResponse response) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>DeleteIndexTemplateV2Request</code> fails.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-simulate-index-template">Simulate Index Template API</h3>
<div class="sect3">
<h4 id="java-rest-high-simulate-index-template-request">Simulate Index Template Request</h4>
<div class="paragraph">
<p>A <code>SimulateIndexTemplateRequest</code> specifies the <code>indexName</code> to simulate matching against the
templates in the system.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        SimulateIndexTemplateRequest simulateRequest = new SimulateIndexTemplateRequest("log-000001"); // <b class="conum">(1)</b>
        PutComposableIndexTemplateRequest newIndexTemplateRequest = new PutComposableIndexTemplateRequest()
            .name("used-for-simulation");
        Settings settings = Settings.builder().put("index.number_of_shards", 6).build();
        Template template = new Template(settings, null, null); // <b class="conum">(2)</b>
        ComposableIndexTemplate composableIndexTemplate = new ComposableIndexTemplate(Arrays.asList("log-*"),
            template, null, 90L, null, null);
        newIndexTemplateRequest.indexTemplate(composableIndexTemplate);

        simulateRequest.indexTemplateV2Request(newIndexTemplateRequest); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The name of the index</p>
</li>
<li>
<p>Optionally, defines a new template</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-simulate-index-template-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>SimulateIndexTemplateRequest</code> in the following manner, the client waits
for the <code>SimulateIndexTemplateResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ActionListener&lt;SimulateIndexTemplateResponse&gt; listener =
            new ActionListener&lt;SimulateIndexTemplateResponse&gt;() {
                @Override
                public void onResponse(SimulateIndexTemplateResponse response) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-simulate-index-template-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>SimulateIndexTemplateRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous simulate-index-template method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        client.indices().simulateIndexTemplateAsync(simulateRequest, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>SimulateIndexTemplateRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>simulate-index-template</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        ActionListener&lt;SimulateIndexTemplateResponse&gt; listener =
            new ActionListener&lt;SimulateIndexTemplateResponse&gt;() {
                @Override
                public void onResponse(SimulateIndexTemplateResponse response) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>SimulateIndexTemplateRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-simulate-index-template-response">Simulate Index Template Response</h4>
<div class="paragraph">
<p>The returned <code>SimulateIndexTemplateResponse</code> includes a resolved <code>Template</code> object containing
the resolved settings, mappings and aliases of the index template that matched
and would be applied to the index with the provided name (if any). It will
also return a <code>Map</code> of index templates (both legacy and composable) names and their
corresponding index patterns:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        SimulateIndexTemplateResponse simulateIndexTemplateResponse = client.indices().simulateIndexTemplate(simulateRequest,
            RequestOptions.DEFAULT);
        assertThat(simulateIndexTemplateResponse.resolvedTemplate().settings().get("index.number_of_shards"), is("6")); // <b class="conum">(1)</b>
        assertThat(simulateIndexTemplateResponse.overlappingTemplates().get("my-template"),
            containsInAnyOrder("pattern-1", "log-*")); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Resolved template configuration that would be applied when creating the index with the provided name</p>
</li>
<li>
<p>Overlapping index templates and their corresponding index patterns</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph nav-footer">
<p>← Previous: <a href="_miscellaneous_apis.html">Miscellaneous APIs</a> | ↑ Up: <a href="java-rest-high.html">Java High Level REST Client</a> | ⌂ Home: <a href="index.html">Java REST Client</a> | Next: <a href="_cluster_apis.html">Cluster APIs</a> →</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-04-05 12:06:59 -0700
</div>
</div>
</body>
</html>