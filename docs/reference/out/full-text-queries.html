<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<title>OpenSearch Reference</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:50%;border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<style>.toc-current{font-weight: bold;} .toc-root{font-family: "Open Sans","DejaVu Sans",sans-serif;
                       font-size: 0.9em;} #content{display: flex; flex-direction: column; flex: 1 1 auto;}
             .nav-footer{text-align: center; margin-top: auto;}
             .nav-footer > p > a {white-space: nowrap;}</style>
</head>
<body id="full-text-queries" class="book toc2 toc-left">
<div id="header">
<h1>OpenSearch Reference</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<p><span class="toc-root"><a href="index.html">OpenSearch Reference</a></span></p><ul class="sectlevel1">
<li><a href="opensearch-intro.html">What is OpenSearch?</a>
</li>
<li><a href="getting-started.html">Getting started with OpenSearch</a>
</li>
<li><a href="setup.html">Set up OpenSearch</a>
</li>
<li><a href="setup-upgrade.html">Upgrade OpenSearch</a>
</li>
<li><a href="index-modules.html">Index modules</a>
</li>
<li><a href="mapping.html">Mapping</a>
</li>
<li><a href="analysis.html">Text analysis</a>
</li>
<li><a href="index-templates.html">Index templates</a>
</li>
<li><a href="ingest.html">Ingest node</a>
</li>
<li><a href="search-your-data.html">Search your data</a>
</li>
<li><a href="query-dsl.html">Query DSL</a>
<ul class="sectlevel1">
<li><a href="query-filter-context.html">Query and filter context</a>
</li>
<li><a href="compound-queries.html">Compound queries</a>
</li>
<li><a href="full-text-queries.html"><span class="toc-current">Full text queries</span></a>
<ul class="sectlevel2">
<li><a href="full-text-queries.html#query-dsl-intervals-query">Intervals query</a>
</li>
<li><a href="full-text-queries.html#query-dsl-match-query">Match query</a>
</li>
<li><a href="full-text-queries.html#query-dsl-match-bool-prefix-query">Match boolean prefix query</a>
</li>
<li><a href="full-text-queries.html#query-dsl-match-query-phrase">Match phrase query</a>
</li>
<li><a href="full-text-queries.html#query-dsl-match-query-phrase-prefix">Match phrase prefix query</a>
</li>
<li><a href="full-text-queries.html#query-dsl-multi-match-query">Multi-match query</a>
</li>
<li><a href="full-text-queries.html#query-dsl-common-terms-query">Common Terms Query</a>
</li>
<li><a href="full-text-queries.html#query-dsl-query-string-query">Query string query</a>
</li>
<li><a href="full-text-queries.html#query-dsl-simple-query-string-query">Simple query string query</a>
</li>
</ul>
</li>
<li><a href="geo-queries.html">Geo queries</a>
</li>
<li><a href="joining-queries.html">Joining queries</a>
</li>
<li><a href="query-dsl-match-all-query.html">Match all query</a>
</li>
<li><a href="span-queries.html">Span queries</a>
</li>
<li><a href="specialized-queries.html">Specialized queries</a>
</li>
<li><a href="term-level-queries.html">Term-level queries</a>
</li>
<li><a href="query-dsl-minimum-should-match.html"><code>minimum_should_match</code> parameter</a>
</li>
<li><a href="query-dsl-multi-term-rewrite.html"><code>rewrite</code> parameter</a>
</li>
<li><a href="regexp-syntax.html">Regular expression syntax</a>
</li>
</ul>
</li>
<li><a href="search-aggregations.html">Aggregations</a>
</li>
<li><a href="modules-scripting.html">Scripting</a>
</li>
<li><a href="high-availability.html">Set up a cluster for high availability</a>
</li>
<li><a href="snapshot-restore.html">Snapshot and restore</a>
</li>
<li><a href="commands.html">Command line tools</a>
</li>
<li><a href="how-to.html">How To</a>
</li>
<li><a href="glossary.html">Glossary of terms</a>
</li>
<li><a href="rest-apis.html">REST APIs</a>
</li>
<li><a href="breaking-changes.html">Migration guide</a>
</li>
<li><a href="opensearch-release-notes.html">Release notes</a>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="full-text-queries">Full text queries</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The full text queries enable you to search <a href="analysis.html">analyzed text fields</a> such as the
body of an email. The query string is processed using the same analyzer that was applied to
the field during indexing.</p>
</div>
<div class="paragraph">
<p>The queries in this group are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><a href="full-text-queries.html#query-dsl-intervals-query"><code>intervals</code> query</a></dt>
<dd>
<p>A full text query that allows fine-grained control of the ordering and
proximity of matching terms.</p>
</dd>
<dt class="hdlist1"><a href="full-text-queries.html#query-dsl-match-query"><code>match</code> query</a></dt>
<dd>
<p>The standard query for performing full text queries, including fuzzy matching
and phrase or proximity queries.</p>
</dd>
<dt class="hdlist1"><a href="full-text-queries.html#query-dsl-match-bool-prefix-query"><code>match_bool_prefix</code> query</a></dt>
<dd>
<p>Creates a <code>bool</code> query that matches each term as a <code>term</code> query, except for
the last term, which is matched as a <code>prefix</code> query</p>
</dd>
<dt class="hdlist1"><a href="full-text-queries.html#query-dsl-match-query-phrase"><code>match_phrase</code> query</a></dt>
<dd>
<p>Like the <code>match</code> query but used for matching exact phrases or word proximity matches.</p>
</dd>
<dt class="hdlist1"><a href="full-text-queries.html#query-dsl-match-query-phrase-prefix"><code>match_phrase_prefix</code> query</a></dt>
<dd>
<p>Like the <code>match_phrase</code> query, but does a wildcard search on the final word.</p>
</dd>
<dt class="hdlist1"><a href="full-text-queries.html#query-dsl-multi-match-query"><code>multi_match</code> query</a></dt>
<dd>
<p>The multi-field version of the <code>match</code> query.</p>
</dd>
<dt class="hdlist1"><a href="full-text-queries.html#query-dsl-common-terms-query"><code>common</code> terms query</a></dt>
<dd>
<p>A more specialized query which gives more preference to uncommon words.</p>
</dd>
<dt class="hdlist1"><a href="full-text-queries.html#query-dsl-query-string-query"><code>query_string</code> query</a></dt>
<dd>
<p>Supports the compact Lucene <a href="full-text-queries.html#query-string-syntax">query string syntax</a>,
allowing you to specify AND|OR|NOT conditions and multi-field search
within a single query string. For expert users only.</p>
</dd>
<dt class="hdlist1"><a href="full-text-queries.html#query-dsl-simple-query-string-query"><code>simple_query_string</code> query</a></dt>
<dd>
<p>A simpler, more robust version of the <code>query_string</code> syntax suitable
for exposing directly to users.</p>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="query-dsl-intervals-query">Intervals query</h3>
<titleabbrev>Intervals</titleabbrev>
<div class="paragraph">
<p>Returns documents based on the order and proximity of matching terms.</p>
</div>
<div class="paragraph">
<p>The <code>intervals</code> query uses <strong>matching rules</strong>, constructed from a small set of
definitions. These rules are then applied to terms from a specified <code>field</code>.</p>
</div>
<div class="paragraph">
<p>The definitions produce sequences of minimal intervals that span terms in a
body of text. These intervals can be further combined and filtered by
parent sources.</p>
</div>
<div class="sect3">
<h4 id="intervals-query-ex-request">Example request</h4>
<div class="paragraph">
<p>The following <code>intervals</code> search returns documents containing <code>my
favorite food</code> immediately followed by <code>hot water</code> or <code>cold porridge</code> in the
<code>my_text</code> field.</p>
</div>
<div class="paragraph">
<p>This search would match a <code>my_text</code> value of <code>my favorite food is cold
porridge</code> but not <code>when it&#8217;s cold my favorite food is porridge</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _search
{
  "query": {
    "intervals" : {
      "my_text" : {
        "all_of" : {
          "ordered" : true,
          "intervals" : [
            {
              "match" : {
                "query" : "my favorite food",
                "max_gaps" : 0,
                "ordered" : true
              }
            },
            {
              "any_of" : {
                "intervals" : [
                  { "match" : { "query" : "hot water" } },
                  { "match" : { "query" : "cold porridge" } }
                ]
              }
            }
          ]
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="intervals-top-level-params">Top-level parameters for <code>intervals</code></h4>
<div id="intervals-rules" class="dlist">
<dl>
<dt class="hdlist1"><code>&lt;field&gt;</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Required, rule object) Field you wish to search.</p>
</div>
<div class="paragraph">
<p>The value of this parameter is a rule object used to match documents
based on matching terms, order, and proximity.</p>
</div>
<div class="paragraph">
<p>Valid rules include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="full-text-queries.html#intervals-match"><code>match</code></a></p>
</li>
<li>
<p><a href="full-text-queries.html#intervals-prefix"><code>prefix</code></a></p>
</li>
<li>
<p><a href="full-text-queries.html#intervals-wildcard"><code>wildcard</code></a></p>
</li>
<li>
<p><a href="full-text-queries.html#intervals-fuzzy"><code>fuzzy</code></a></p>
</li>
<li>
<p><a href="full-text-queries.html#intervals-all_of"><code>all_of</code></a></p>
</li>
<li>
<p><a href="full-text-queries.html#intervals-any_of"><code>any_of</code></a></p>
</li>
</ul>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="intervals-match"><code>match</code> rule parameters</h4>
<div class="paragraph">
<p>The <code>match</code> rule matches analyzed text.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>query</code></dt>
<dd>
<p>(Required, string) Text you wish to find in the provided <code>&lt;field&gt;</code>.</p>
</dd>
<dt class="hdlist1"><code>max_gaps</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, integer) Maximum number of positions between the matching terms.
Terms further apart than this are not considered matches. Defaults to
<code>-1</code>.</p>
</div>
<div class="paragraph">
<p>If unspecified or set to <code>-1</code>, there is no width restriction on the match. If
set to <code>0</code>, the terms must appear next to each other.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>ordered</code></dt>
<dd>
<p>(Optional, Boolean)
If <code>true</code>, matching terms must appear in their specified order. Defaults to
<code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>analyzer</code></dt>
<dd>
<p>(Optional, string) <a href="analysis.html">analyzer</a> used to analyze terms in the <code>query</code>.
Defaults to the top-level `&lt;field&gt;&#8217;s analyzer.</p>
</dd>
<dt class="hdlist1"><code>filter</code></dt>
<dd>
<p>(Optional, <a href="full-text-queries.html#interval_filter">interval filter</a> rule object) An optional interval
filter.</p>
</dd>
<dt class="hdlist1"><code>use_field</code></dt>
<dd>
<p>(Optional, string) If specified, then match intervals from this
field rather than the top-level <code>&lt;field&gt;</code>. Terms are analyzed using the
search analyzer from this field. This allows you to search across multiple
fields as if they were all the same field; for example, you could index the same
text into stemmed and unstemmed fields, and search for stemmed tokens near
unstemmed ones.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="intervals-prefix"><code>prefix</code> rule parameters</h4>
<div class="paragraph">
<p>The <code>prefix</code> rule matches terms that start with a specified set of characters.
This prefix can expand to match at most 128 terms. If the prefix matches more
than 128 terms, OpenSearch returns an error. You can use the
<a href="mapping-params.html#index-prefixes"><code>index-prefixes</code></a> option in the field mapping to avoid this
limit.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>prefix</code></dt>
<dd>
<p>(Required, string) Beginning characters of terms you wish to find in the
top-level <code>&lt;field&gt;</code>.</p>
</dd>
<dt class="hdlist1"><code>analyzer</code></dt>
<dd>
<p>(Optional, string) <a href="analysis.html">analyzer</a> used to normalize the <code>prefix</code>.
Defaults to the top-level `&lt;field&gt;&#8217;s analyzer.</p>
</dd>
<dt class="hdlist1"><code>use_field</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string) If specified, then match intervals from this field rather
than the top-level <code>&lt;field&gt;</code>.</p>
</div>
<div class="paragraph">
<p>The <code>prefix</code> is normalized using the search analyzer from this field, unless a
separate <code>analyzer</code> is specified.</p>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="intervals-wildcard"><code>wildcard</code> rule parameters</h4>
<div class="paragraph">
<p>The <code>wildcard</code> rule matches terms using a wildcard pattern. This pattern can
expand to match at most 128 terms. If the pattern matches more than 128 terms,
OpenSearch returns an error.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>pattern</code></dt>
<dd>
<p>(Required, string) Wildcard pattern used to find matching terms.</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>This parameter supports two wildcard operators:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>?</code>, which matches any single character</p>
</li>
<li>
<p><code>*</code>, which can match zero or more characters, including an empty one</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
Avoid beginning patterns with <code>*</code> or <code>?</code>. This can increase
the iterations needed to find matching terms and slow search performance.
</td>
</tr>
</table>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>analyzer</code></dt>
<dd>
<p>(Optional, string) <a href="analysis.html">analyzer</a> used to normalize the <code>pattern</code>.
Defaults to the top-level `&lt;field&gt;&#8217;s analyzer.</p>
</dd>
<dt class="hdlist1"><code>use_field</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string) If specified, match intervals from this field rather than the
top-level <code>&lt;field&gt;</code>.</p>
</div>
<div class="paragraph">
<p>The <code>pattern</code> is normalized using the search analyzer from this field, unless
<code>analyzer</code> is specified separately.</p>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="intervals-fuzzy"><code>fuzzy</code> rule parameters</h4>
<div class="paragraph">
<p>The <code>fuzzy</code> rule matches terms that are similar to the provided term, within an
edit distance defined by <a href="api-conventions.html#fuzziness">Fuzziness</a>.  If the fuzzy expansion matches more than
128 terms, OpenSearch returns an error.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>term</code></dt>
<dd>
<p>(Required, string) The term to match</p>
</dd>
<dt class="hdlist1"><code>prefix_length</code></dt>
<dd>
<p>(Optional, string) Number of beginning characters left unchanged when creating
expansions. Defaults to <code>0</code>.</p>
</dd>
<dt class="hdlist1"><code>transpositions</code></dt>
<dd>
<p>(Optional, Boolean) Indicates whether edits include transpositions of two
adjacent characters (ab → ba). Defaults to <code>true</code>.</p>
</dd>
<dt class="hdlist1"><code>fuzziness</code></dt>
<dd>
<p>(Optional, string) Maximum edit distance allowed for matching. See <a href="api-conventions.html#fuzziness">Fuzziness</a>
for valid values and more information.  Defaults to <code>auto</code>.</p>
</dd>
<dt class="hdlist1"><code>analyzer</code></dt>
<dd>
<p>(Optional, string) <a href="analysis.html">analyzer</a> used to normalize the <code>term</code>.
Defaults to the top-level <code>&lt;field&gt;</code> 's analyzer.</p>
</dd>
<dt class="hdlist1"><code>use_field</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string) If specified, match intervals from this field rather than the
top-level <code>&lt;field&gt;</code>.</p>
</div>
<div class="paragraph">
<p>The <code>term</code> is normalized using the search analyzer from this field, unless
<code>analyzer</code> is specified separately.</p>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="intervals-all_of"><code>all_of</code> rule parameters</h4>
<div class="paragraph">
<p>The <code>all_of</code> rule returns matches that span a combination of other rules.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>intervals</code></dt>
<dd>
<p>(Required, array of rule objects) An array of rules to combine. All rules must
produce a match in a document for the overall source to match.</p>
</dd>
<dt class="hdlist1"><code>max_gaps</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, integer) Maximum number of positions between the matching terms.
Intervals produced by the rules further apart than this are not considered
matches. Defaults to <code>-1</code>.</p>
</div>
<div class="paragraph">
<p>If unspecified or set to <code>-1</code>, there is no width restriction on the match. If
set to <code>0</code>, the terms must appear next to each other.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>ordered</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, intervals produced by the rules should appear in
the order in which they are specified. Defaults to <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>filter</code></dt>
<dd>
<p>(Optional, <a href="full-text-queries.html#interval_filter">interval filter</a> rule object) Rule used to filter
returned intervals.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="intervals-any_of"><code>any_of</code> rule parameters</h4>
<div class="paragraph">
<p>The <code>any_of</code> rule returns intervals produced by any of its sub-rules.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>intervals</code></dt>
<dd>
<p>(Required, array of rule objects) An array of rules to match.</p>
</dd>
<dt class="hdlist1"><code>filter</code></dt>
<dd>
<p>(Optional, <a href="full-text-queries.html#interval_filter">interval filter</a> rule object) Rule used to filter
returned intervals.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="interval_filter"><code>filter</code> rule parameters</h4>
<div class="paragraph">
<p>The <code>filter</code> rule returns intervals based on a query. See
<a href="full-text-queries.html#interval-filter-rule-ex">Filter example</a> for an example.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>after</code></dt>
<dd>
<p>(Optional, query object) Query used to return intervals that follow an interval
from the <code>filter</code> rule.</p>
</dd>
<dt class="hdlist1"><code>before</code></dt>
<dd>
<p>(Optional, query object) Query used to return intervals that occur before an
interval from the <code>filter</code> rule.</p>
</dd>
<dt class="hdlist1"><code>contained_by</code></dt>
<dd>
<p>(Optional, query object) Query used to return intervals contained by an interval
from the <code>filter</code> rule.</p>
</dd>
<dt class="hdlist1"><code>containing</code></dt>
<dd>
<p>(Optional, query object) Query used to return intervals that contain an interval
from the <code>filter</code> rule.</p>
</dd>
<dt class="hdlist1"><code>not_contained_by</code></dt>
<dd>
<p>(Optional, query object) Query used to return intervals that are <strong>not</strong>
contained by an interval from the <code>filter</code> rule.</p>
</dd>
<dt class="hdlist1"><code>not_containing</code></dt>
<dd>
<p>(Optional, query object) Query used to return intervals that do <strong>not</strong> contain
an interval from the <code>filter</code> rule.</p>
</dd>
<dt class="hdlist1"><code>not_overlapping</code></dt>
<dd>
<p>(Optional, query object) Query used to return intervals that do <strong>not</strong> overlap
with an interval from the <code>filter</code> rule.</p>
</dd>
<dt class="hdlist1"><code>overlapping</code></dt>
<dd>
<p>(Optional, query object) Query used to return intervals that overlap with an
interval from the <code>filter</code> rule.</p>
</dd>
<dt class="hdlist1"><code>script</code></dt>
<dd>
<p>(Optional, <a href="modules-scripting-using.html">script object</a>) Script used to return
matching documents. This script must return a boolean value, <code>true</code> or <code>false</code>.
See <a href="full-text-queries.html#interval-script-filter">Script filters</a> for an example.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="intervals-query-note">Notes</h4>
<div class="sect4">
<h5 id="interval-filter-rule-ex">Filter example</h5>
<div class="paragraph">
<p>The following search includes a <code>filter</code> rule. It returns documents that have
the words <code>hot</code> and <code>porridge</code> within 10 positions of each other, without the
word <code>salty</code> in between:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _search
{
  "query": {
    "intervals" : {
      "my_text" : {
        "match" : {
          "query" : "hot porridge",
          "max_gaps" : 10,
          "filter" : {
            "not_containing" : {
              "match" : {
                "query" : "salty"
              }
            }
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="interval-script-filter">Script filters</h5>
<div class="paragraph">
<p>You can use a script to filter intervals based on their start position, end
position, and internal gap count. The following <code>filter</code> script uses the
<code>interval</code> variable with the <code>start</code>, <code>end</code>, and <code>gaps</code> methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _search
{
  "query": {
    "intervals" : {
      "my_text" : {
        "match" : {
          "query" : "hot porridge",
          "filter" : {
            "script" : {
              "source" : "interval.start &gt; 10 &amp;&amp; interval.end &lt; 20 &amp;&amp; interval.gaps == 0"
            }
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="interval-minimization">Minimization</h5>
<div class="paragraph">
<p>The intervals query always minimizes intervals, to ensure that queries can
run in linear time. This can sometimes cause surprising results, particularly
when using <code>max_gaps</code> restrictions or filters. For example, take the
following query, searching for <code>salty</code> contained within the phrase <code>hot
porridge</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _search
{
  "query": {
    "intervals" : {
      "my_text" : {
        "match" : {
          "query" : "salty",
          "filter" : {
            "contained_by" : {
              "match" : {
                "query" : "hot porridge"
              }
            }
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This query does <strong>not</strong> match a document containing the phrase <code>hot porridge is
salty porridge</code>, because the intervals returned by the match query for <code>hot
porridge</code> only cover the initial two terms in this document, and these do not
overlap the intervals covering <code>salty</code>.</p>
</div>
<div class="paragraph">
<p>Another restriction to be aware of is the case of <code>any_of</code> rules that contain
sub-rules which overlap. In particular, if one of the rules is a strict
prefix of the other, then the longer rule can never match, which can
cause surprises when used in combination with <code>max_gaps</code>. Consider the
following query, searching for <code>the</code> immediately followed by <code>big</code> or <code>big bad</code>,
immediately followed by <code>wolf</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _search
{
  "query": {
    "intervals" : {
      "my_text" : {
        "all_of" : {
          "intervals" : [
            { "match" : { "query" : "the" } },
            { "any_of" : {
                "intervals" : [
                    { "match" : { "query" : "big" } },
                    { "match" : { "query" : "big bad" } }
                ] } },
            { "match" : { "query" : "wolf" } }
          ],
          "max_gaps" : 0,
          "ordered" : true
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Counter-intuitively, this query does <strong>not</strong> match the document <code>the big bad
wolf</code>, because the <code>any_of</code> rule in the middle only produces intervals
for <code>big</code> - intervals for <code>big bad</code> being longer than those for <code>big</code>, while
starting at the same position, and so being minimized away. In these cases,
it&#8217;s better to rewrite the query so that all of the options are explicitly
laid out at the top level:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _search
{
  "query": {
    "intervals" : {
      "my_text" : {
        "any_of" : {
          "intervals" : [
            { "match" : {
                "query" : "the big bad wolf",
                "ordered" : true,
                "max_gaps" : 0 } },
            { "match" : {
                "query" : "the big wolf",
                "ordered" : true,
                "max_gaps" : 0 } }
           ]
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="query-dsl-match-query">Match query</h3>
<titleabbrev>Match</titleabbrev>
<div class="paragraph">
<p>Returns documents that match a provided text, number, date or boolean value. The
provided text is analyzed before matching.</p>
</div>
<div class="paragraph">
<p>The <code>match</code> query is the standard query for performing a full-text search,
including options for fuzzy matching.</p>
</div>
<div class="sect3">
<h4 id="match-query-ex-request">Example request</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "match": {
      "message": {
        "query": "this is a test"
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="match-top-level-params">Top-level parameters for <code>match</code></h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>&lt;field&gt;</code></dt>
<dd>
<p>(Required, object) Field you wish to search.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="match-field-params">Parameters for <code>&lt;field&gt;</code></h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>query</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Required) Text, number, boolean value or date you wish to find in the provided
<code>&lt;field&gt;</code>.</p>
</div>
<div class="paragraph">
<p>The <code>match</code> query <a href="analysis.html">analyzes</a> any provided text before performing a
search. This means the <code>match</code> query can search <a href="mapping-types.html#text"><code>text</code></a> fields for
analyzed tokens rather than an exact term.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>analyzer</code></dt>
<dd>
<p>(Optional, string) <a href="analysis.html">Analyzer</a> used to convert the text in the <code>query</code>
value into tokens. Defaults to the <a href="configure-text-analysis.html#specify-index-time-analyzer">index-time
analyzer</a> mapped for the <code>&lt;field&gt;</code>. If no analyzer is mapped, the index&#8217;s
default analyzer is used.</p>
</dd>
<dt class="hdlist1"><code>auto_generate_synonyms_phrase_query</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, Boolean) If <code>true</code>, <a href="full-text-queries.html#query-dsl-match-query-phrase">match phrase</a>
queries are automatically created for multi-term synonyms. Defaults to <code>true</code>.</p>
</div>
<div class="paragraph">
<p>See <a href="full-text-queries.html#query-dsl-match-query-synonyms">Use synonyms with match query</a> for an
example.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>fuzziness</code></dt>
<dd>
<p>(Optional, string) Maximum edit distance allowed for matching. See <a href="api-conventions.html#fuzziness">Fuzziness</a>
for valid values and more information. See <a href="full-text-queries.html#query-dsl-match-query-fuzziness">Fuzziness in the match query</a>
for an example.</p>
</dd>
<dt class="hdlist1"><code>max_expansions</code></dt>
<dd>
<p>(Optional, integer) Maximum number of terms to which the query will
expand. Defaults to <code>50</code>.</p>
</dd>
<dt class="hdlist1"><code>prefix_length</code></dt>
<dd>
<p>(Optional, integer) Number of beginning characters left unchanged for fuzzy
matching. Defaults to <code>0</code>.</p>
</dd>
<dt class="hdlist1"><code>fuzzy_transpositions</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, edits for fuzzy matching include
transpositions of two adjacent characters (ab → ba). Defaults to <code>true</code>.</p>
</dd>
<dt class="hdlist1"><code>fuzzy_rewrite</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string) Method used to rewrite the query. See the
<a href="query-dsl-multi-term-rewrite.html"><code>rewrite</code> parameter</a> for valid values and more
information.</p>
</div>
<div class="paragraph">
<p>If the <code>fuzziness</code> parameter is not <code>0</code>, the <code>match</code> query uses a <code>fuzzy_rewrite</code>
method of <code>top_terms_blended_freqs_${max_expansions}</code> by default.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>lenient</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, format-based errors, such as providing a text
<code>query</code> value for a <a href="mapping-types.html#number">numeric</a> field, are ignored. Defaults to <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>operator</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string) Boolean logic used to interpret text in the <code>query</code> value.
Valid values are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>OR</code> (Default)</dt>
<dd>
<p>For example, a <code>query</code> value of <code>capital of Hungary</code> is interpreted as <code>capital
OR of OR Hungary</code>.</p>
</dd>
<dt class="hdlist1"><code>AND</code></dt>
<dd>
<p>For example, a <code>query</code> value of <code>capital of Hungary</code> is interpreted as <code>capital
AND of AND Hungary</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>minimum_should_match</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string) Minimum number of clauses that must match for a document to
be returned. See the <a href="query-dsl-minimum-should-match.html"><code>minimum_should_match</code>
parameter</a> for valid values and more information.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>zero_terms_query</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string) Indicates whether no documents are returned if the <code>analyzer</code>
removes all tokens, such as when using a <code>stop</code> filter. Valid values are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>none</code> (Default)</dt>
<dd>
<p>No documents are returned if the <code>analyzer</code> removes all tokens.</p>
</dd>
<dt class="hdlist1"><code>all</code></dt>
<dd>
<p>Returns all documents, similar to a <a href="query-dsl-match-all-query.html"><code>match_all</code></a>
query.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>See <a href="full-text-queries.html#query-dsl-match-query-zero">Zero terms query</a> for an example.</p>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="match-query-notes">Notes</h4>
<div class="sect4">
<h5 id="query-dsl-match-query-short-ex">Short request example</h5>
<div class="paragraph">
<p>You can simplify the match query syntax by combining the <code>&lt;field&gt;</code> and <code>query</code>
parameters. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "match": {
      "message": "this is a test"
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="query-dsl-match-query-boolean">How the match query works</h5>
<div class="paragraph">
<p>The <code>match</code> query is of type <code>boolean</code>. It means that the text
provided is analyzed and the analysis process constructs a boolean query
from the provided text. The <code>operator</code> parameter can be set to <code>or</code> or <code>and</code>
to control the boolean clauses (defaults to <code>or</code>). The minimum number of
optional <code>should</code> clauses to match can be set using the
<a href="query-dsl-minimum-should-match.html"><code>minimum_should_match</code></a>
parameter.</p>
</div>
<div class="paragraph">
<p>Here is an example with the <code>operator</code> parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "match": {
      "message": {
        "query": "this is a test",
        "operator": "and"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>analyzer</code> can be set to control which analyzer will perform the
analysis process on the text. It defaults to the field explicit mapping
definition, or the default search analyzer.</p>
</div>
<div class="paragraph">
<p>The <code>lenient</code> parameter can be set to <code>true</code> to ignore exceptions caused by
data-type mismatches,  such as trying to query a numeric field with a text
query string. Defaults to <code>false</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="query-dsl-match-query-fuzziness">Fuzziness in the match query</h5>
<div class="paragraph">
<p><code>fuzziness</code> allows <em>fuzzy matching</em> based on the type of field being queried.
See <a href="api-conventions.html#fuzziness">Fuzziness</a> for allowed settings.</p>
</div>
<div class="paragraph">
<p>The <code>prefix_length</code> and
<code>max_expansions</code> can be set in this case to control the fuzzy process.
If the fuzzy option is set the query will use <code>top_terms_blended_freqs_${max_expansions}</code>
as its <a href="query-dsl-multi-term-rewrite.html">rewrite
method</a> the <code>fuzzy_rewrite</code> parameter allows to control how the query will get
rewritten.</p>
</div>
<div class="paragraph">
<p>Fuzzy transpositions (<code>ab</code> &#8594; <code>ba</code>) are allowed by default but can be disabled
by setting <code>fuzzy_transpositions</code> to <code>false</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Fuzzy matching is not applied to terms with synonyms or in cases where the
analysis process produces multiple tokens at the same position. Under the hood
these terms are expanded to a special synonym query that blends term frequencies,
which does not support fuzzy expansion.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "match": {
      "message": {
        "query": "this is a testt",
        "fuzziness": "AUTO"
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="query-dsl-match-query-zero">Zero terms query</h5>
<div class="paragraph">
<p>If the analyzer used removes all tokens in a query like a <code>stop</code> filter
does, the default behavior is to match no documents at all. In order to
change that the <code>zero_terms_query</code> option can be used, which accepts
<code>none</code> (default) and <code>all</code> which corresponds to a <code>match_all</code> query.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "match": {
      "message": {
        "query": "to be or not to be",
        "operator": "and",
        "zero_terms_query": "all"
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="query-dsl-match-query-cutoff">Cutoff frequency</h5>
<div class="paragraph">
<p>Deprecated. This option can be omitted as the <a href="full-text-queries.html#query-dsl-match-query">Match query</a> can skip blocks of documents efficiently, without any configuration, provided that the total number of hits is not tracked.</p>
</div>
<div class="paragraph">
<p>The match query supports a <code>cutoff_frequency</code> that allows
specifying an absolute or relative document frequency where high
frequency terms are moved into an optional subquery and are only scored
if one of the low frequency (below the cutoff) terms in the case of an
<code>or</code> operator or all of the low frequency terms in the case of an <code>and</code>
operator match.</p>
</div>
<div class="paragraph">
<p>This query allows handling <code>stopwords</code> dynamically at runtime, is domain
independent and doesn&#8217;t require a stopword file. It prevents scoring /
iterating high frequency terms and only takes the terms into account if a
more significant / lower frequency term matches a document. Yet, if all
of the query terms are above the given <code>cutoff_frequency</code> the query is
automatically transformed into a pure conjunction (<code>and</code>) query to
ensure fast execution.</p>
</div>
<div class="paragraph">
<p>The <code>cutoff_frequency</code> can either be relative to the total number of
documents if in the range from 0 (inclusive) to 1 (exclusive) or absolute if greater or equal to
<code>1.0</code>.</p>
</div>
<div class="paragraph">
<p>Here is an example showing a query composed of stopwords exclusively:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "match": {
      "message": {
        "query": "to be or not to be",
        "cutoff_frequency": 0.001
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
The <code>cutoff_frequency</code> option operates on a per-shard-level. This means
that when trying it out on test indexes with low document numbers you
should follow the advice in <a href="https://www.opensearch.org/guide/en/opensearch/guide/2.x/relevance-is-broken.html">Relevance is broken</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="query-dsl-match-query-synonyms">Synonyms</h5>
<div class="paragraph">
<p>The <code>match</code> query supports multi-terms synonym expansion with the <a href="analysis-tokenfilters.html#analysis-synonym-graph-tokenfilter">synonym_graph</a> token filter. When this filter is used, the parser creates a phrase query for each multi-terms synonyms.
For example, the following synonym: <code>"ny, new york"</code> would produce:</p>
</div>
<div class="paragraph">
<p><code>(ny OR ("new york"))</code></p>
</div>
<div class="paragraph">
<p>It is also possible to match multi terms synonyms with conjunctions instead:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
   "query": {
       "match" : {
           "message": {
               "query" : "ny city",
               "auto_generate_synonyms_phrase_query" : false
           }
       }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example above creates a boolean query:</p>
</div>
<div class="paragraph">
<p><code>(ny OR (new AND york)) city</code></p>
</div>
<div class="paragraph">
<p>that matches documents with the term <code>ny</code> or the conjunction <code>new AND york</code>.
By default the parameter <code>auto_generate_synonyms_phrase_query</code> is set to <code>true</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="query-dsl-match-bool-prefix-query">Match boolean prefix query</h3>
<titleabbrev>Match boolean prefix</titleabbrev>
<div class="paragraph">
<p>A <code>match_bool_prefix</code> query analyzes its input and constructs a
<a href="compound-queries.html#query-dsl-bool-query"><code>bool</code> query</a> from the terms. Each term except the last
is used in a <code>term</code> query. The last term is used in a <code>prefix</code> query. A
<code>match_bool_prefix</code> query such as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "match_bool_prefix" : {
      "message" : "quick brown f"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>where analysis produces the terms <code>quick</code>, <code>brown</code>, and <code>f</code> is similar to the
following <code>bool</code> query</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "bool" : {
      "should": [
        { "term": { "message": "quick" }},
        { "term": { "message": "brown" }},
        { "prefix": { "message": "f"}}
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An important difference between the <code>match_bool_prefix</code> query and
<a href="full-text-queries.html#query-dsl-match-query-phrase-prefix"><code>match_phrase_prefix</code></a> is that the
<code>match_phrase_prefix</code> query matches its terms as a phrase, but the
<code>match_bool_prefix</code> query can match its terms in any position. The example
<code>match_bool_prefix</code> query above could match a field containing
<code>quick brown fox</code>, but it could also match <code>brown fox quick</code>. It could also
match a field containing the term <code>quick</code>, the term <code>brown</code> and a term
starting with <code>f</code>, appearing in any position.</p>
</div>
<div class="sect3">
<h4 id="_parameters">Parameters</h4>
<div class="paragraph">
<p>By default, <code>match_bool_prefix</code> queries' input text will be analyzed using the
analyzer from the queried field&#8217;s mapping. A different search analyzer can be
configured with the <code>analyzer</code> parameter</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "match_bool_prefix": {
      "message": {
        "query": "quick brown f",
        "analyzer": "keyword"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>match_bool_prefix</code> queries support the
<a href="query-dsl-minimum-should-match.html"><code>minimum_should_match</code></a> and <code>operator</code>
parameters as described for the
<a href="full-text-queries.html#query-dsl-match-query-boolean"><code>match</code> query</a>, applying the setting to the
constructed <code>bool</code> query. The number of clauses in the constructed <code>bool</code>
query will in most cases be the number of terms produced by analysis of the
query text.</p>
</div>
<div class="paragraph">
<p>The <a href="full-text-queries.html#query-dsl-match-query-fuzziness"><code>fuzziness</code></a>, <code>prefix_length</code>,
<code>max_expansions</code>, <code>fuzzy_transpositions</code>, and <code>fuzzy_rewrite</code> parameters can
be applied to the <code>term</code> subqueries constructed for all terms but the final
term. They do not have any effect on the prefix query constructed for the
final term.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="query-dsl-match-query-phrase">Match phrase query</h3>
<titleabbrev>Match phrase</titleabbrev>
<div class="paragraph">
<p>The <code>match_phrase</code> query analyzes the text and creates a <code>phrase</code> query
out of the analyzed text. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "match_phrase": {
      "message": "this is a test"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A phrase query matches terms up to a configurable <code>slop</code>
(which defaults to 0) in any order. Transposed terms have a slop of 2.</p>
</div>
<div class="paragraph">
<p>The <code>analyzer</code> can be set to control which analyzer will perform the
analysis process on the text. It defaults to the field explicit mapping
definition, or the default search analyzer, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "match_phrase": {
      "message": {
        "query": "this is a test",
        "analyzer": "my_analyzer"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This query also accepts <code>zero_terms_query</code>, as explained in <a href="full-text-queries.html#query-dsl-match-query"><code>match</code> query</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="query-dsl-match-query-phrase-prefix">Match phrase prefix query</h3>
<titleabbrev>Match phrase prefix</titleabbrev>
<div class="paragraph">
<p>Returns documents that contain the words of a provided text, in the <strong>same
order</strong> as provided. The last term of the provided text is treated as a
<a href="term-level-queries.html#query-dsl-prefix-query">prefix</a>, matching any words that begin with that term.</p>
</div>
<div class="sect3">
<h4 id="match-phrase-prefix-query-ex-request">Example request</h4>
<div class="paragraph">
<p>The following search returns documents that contain phrases beginning with
<code>quick brown f</code> in the <code>message</code> field.</p>
</div>
<div class="paragraph">
<p>This search would match a <code>message</code> value of <code>quick brown fox</code> or <code>two quick
brown ferrets</code> but not <code>the fox is quick and brown</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "match_phrase_prefix": {
      "message": {
        "query": "quick brown f"
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="match-phrase-prefix-top-level-params">Top-level parameters for <code>match_phrase_prefix</code></h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>&lt;field&gt;</code></dt>
<dd>
<p>(Required, object) Field you wish to search.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="match-phrase-prefix-field-params">Parameters for <code>&lt;field&gt;</code></h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>query</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Required, string) Text you wish to find in the provided <code>&lt;field&gt;</code>.</p>
</div>
<div class="paragraph">
<p>The <code>match_phrase_prefix</code> query <a href="analysis.html">analyzes</a> any provided text into
tokens before performing a search. The last term of this text is treated as a
<a href="term-level-queries.html#query-dsl-prefix-query">prefix</a>, matching any words that begin with that term.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>analyzer</code></dt>
<dd>
<p>(Optional, string) <a href="analysis.html">Analyzer</a> used to convert text in the <code>query</code>
value into tokens. Defaults to the <a href="configure-text-analysis.html#specify-index-time-analyzer">index-time
analyzer</a> mapped for the <code>&lt;field&gt;</code>. If no analyzer is mapped, the index&#8217;s
default analyzer is used.</p>
</dd>
<dt class="hdlist1"><code>max_expansions</code></dt>
<dd>
<p>(Optional, integer) Maximum number of terms to which the last provided term of
the <code>query</code> value will expand. Defaults to <code>50</code>.</p>
</dd>
<dt class="hdlist1"><code>slop</code></dt>
<dd>
<p>(Optional, integer) Maximum number of positions allowed between matching tokens.
Defaults to <code>0</code>. Transposed terms have a slop of <code>2</code>.</p>
</dd>
<dt class="hdlist1"><code>zero_terms_query</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string) Indicates whether no documents are returned if the <code>analyzer</code>
removes all tokens, such as when using a <code>stop</code> filter. Valid values are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>none</code> (Default)</dt>
<dd>
<p>No documents are returned if the <code>analyzer</code> removes all tokens.</p>
</dd>
<dt class="hdlist1"><code>all</code></dt>
<dd>
<p>Returns all documents, similar to a <a href="query-dsl-match-all-query.html"><code>match_all</code></a>
query.</p>
</dd>
</dl>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="match-phrase-prefix-query-notes">Notes</h4>
<div class="sect4">
<h5 id="match-phrase-prefix-autocomplete">Using the match phrase prefix query for search autocompletion</h5>
<div class="paragraph">
<p>While easy to set up, using the <code>match_phrase_prefix</code> query for search
autocompletion can sometimes produce confusing results.</p>
</div>
<div class="paragraph">
<p>For example, consider the query string <code>quick brown f</code>. This query works by
creating a phrase query out of <code>quick</code> and <code>brown</code> (i.e. the term <code>quick</code> must
exist and must be followed by the term <code>brown</code>). Then it looks at the sorted
term dictionary to find the first 50 terms that begin with <code>f</code>, and adds these
terms to the phrase query.</p>
</div>
<div class="paragraph">
<p>The problem is that the first 50 terms may not include the term <code>fox</code> so the
phrase <code>quick brown fox</code> will not be found. This usually isn&#8217;t a problem as
the user will continue to type more letters until the word they are looking
for appears.</p>
</div>
<div class="paragraph">
<p>For better solutions for <em>search-as-you-type</em> see the
<a href="search.html#completion-suggester">completion suggester</a> and
the <a href="mapping-types.html#search-as-you-type"><code>search_as_you_type</code> field type</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="query-dsl-multi-match-query">Multi-match query</h3>
<titleabbrev>Multi-match</titleabbrev>
<div class="paragraph">
<p>The <code>multi_match</code> query builds on the <a href="full-text-queries.html#query-dsl-match-query"><code>match</code> query</a>
to allow multi-field queries:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "multi_match" : {
      "query":    "this is a test", <b class="conum">(1)</b>
      "fields": [ "subject", "message" ] <b class="conum">(2)</b>
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The query string.</p>
</li>
<li>
<p>The fields to be queried.</p>
</li>
</ol>
</div>
<h4 id="field-boost" class="discrete"><code>fields</code> and per-field boosting</h4>
<div class="paragraph">
<p>Fields can be specified with wildcards, eg:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "multi_match" : {
      "query":    "Will Smith",
      "fields": [ "title", "*_name" ] <b class="conum">(1)</b>
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Query the <code>title</code>, <code>first_name</code> and <code>last_name</code> fields.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Individual fields can be boosted with the caret (<code>^</code>) notation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "multi_match" : {
      "query" : "this is a test",
      "fields" : [ "subject^3", "message" ] <b class="conum">(1)</b>
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The query multiplies the <code>subject</code> field&#8217;s score by three but leaves the
<code>message</code> field&#8217;s score unchanged.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If no <code>fields</code> are provided, the <code>multi_match</code> query defaults to the <code>index.query.default_field</code>
index settings, which in turn defaults to <code><strong></code>. <code></strong></code> extracts all fields in the mapping that
are eligible to term queries and filters the metadata fields. All extracted fields are then
combined to build a query.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
There is a limit on the number of fields that can be queried
at once. It is defined by the <code>indices.query.bool.max_clause_count</code> <a href="settings.html#search-settings">Search settings</a>
which defaults to 1024.
</td>
</tr>
</table>
</div>
<h4 id="multi-match-types" class="discrete">Types of <code>multi_match</code> query:</h4>
<div class="paragraph">
<p>The way the <code>multi_match</code> query is executed internally depends on the <code>type</code>
parameter, which can be set to:</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>best_fields</code>
</td>
<td class="hdlist2">
<p>(<strong>default</strong>) Finds documents which match any field, but
uses the  <code>_score</code> from the best field.  See <a href="full-text-queries.html#type-best-fields"><code>best_fields</code></a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>most_fields</code>
</td>
<td class="hdlist2">
<p>Finds documents which match any field and combines
the <code>_score</code> from each field.  See <a href="full-text-queries.html#type-most-fields"><code>most_fields</code></a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>cross_fields</code>
</td>
<td class="hdlist2">
<p>Treats fields with the same <code>analyzer</code> as though they
were one big field. Looks for each word in <strong>any</strong>
field. See <a href="full-text-queries.html#type-cross-fields"><code>cross_fields</code></a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>phrase</code>
</td>
<td class="hdlist2">
<p>Runs a <code>match_phrase</code> query on each field and uses the <code>_score</code>
from the best field.  See <a href="full-text-queries.html#type-phrase"><code>phrase</code> and <code>phrase_prefix</code></a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>phrase_prefix</code>
</td>
<td class="hdlist2">
<p>Runs a <code>match_phrase_prefix</code> query on each field and uses
the <code>_score</code> from the best field.  See <a href="full-text-queries.html#type-phrase"><code>phrase</code> and <code>phrase_prefix</code></a>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>bool_prefix</code>
</td>
<td class="hdlist2">
<p>Creates a <code>match_bool_prefix</code> query on each field and
combines the <code>_score</code> from each field. See
<a href="full-text-queries.html#type-bool-prefix"><code>bool_prefix</code></a>.</p>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="type-best-fields"><code>best_fields</code></h4>
<div class="paragraph">
<p>The <code>best_fields</code> type is most useful when you are searching for multiple
words best found in the same field. For instance <code>brown fox'' in a single
field is more meaningful than </code>brown'' in one field and ``fox'' in the other.</p>
</div>
<div class="paragraph">
<p>The <code>best_fields</code> type generates a <a href="full-text-queries.html#query-dsl-match-query"><code>match</code> query</a> for
each field and wraps them in a <a href="compound-queries.html#query-dsl-dis-max-query"><code>dis_max</code></a> query, to
find the single best matching field.  For instance, this query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "multi_match" : {
      "query":      "brown fox",
      "type":       "best_fields",
      "fields":     [ "subject", "message" ],
      "tie_breaker": 0.3
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>would be executed as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "dis_max": {
      "queries": [
        { "match": { "subject": "brown fox" }},
        { "match": { "message": "brown fox" }}
      ],
      "tie_breaker": 0.3
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Normally the <code>best_fields</code> type uses the score of the <strong>single</strong> best matching
field, but if <code>tie_breaker</code> is specified, then it calculates the score as
follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the score from the best matching field</p>
</li>
<li>
<p>plus <code>tie_breaker * _score</code> for all other matching fields</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Also, accepts <code>analyzer</code>, <code>boost</code>, <code>operator</code>, <code>minimum_should_match</code>,
<code>fuzziness</code>, <code>lenient</code>, <code>prefix_length</code>, <code>max_expansions</code>, <code>fuzzy_rewrite</code>, <code>zero_terms_query</code>,
 <code>cutoff_frequency</code>, <code>auto_generate_synonyms_phrase_query</code> and <code>fuzzy_transpositions</code>,
  as explained in <a href="full-text-queries.html#query-dsl-match-query">match query</a>.</p>
</div>
<div id="operator-min" class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="title"><code>operator</code> and <code>minimum_should_match</code></div>
<div class="paragraph">
<p>The <code>best_fields</code> and <code>most_fields</code> types are <em>field-centric</em>&#8201;&#8212;&#8201;they generate
a <code>match</code> query <strong>per field</strong>.  This means that the <code>operator</code> and
<code>minimum_should_match</code> parameters are applied to each field individually,
which is probably not what you want.</p>
</div>
<div class="paragraph">
<p>Take this query for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "multi_match" : {
      "query":      "Will Smith",
      "type":       "best_fields",
      "fields":     [ "first_name", "last_name" ],
      "operator":   "and" <b class="conum">(1)</b>
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>All terms must be present.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This query is executed as:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  (+first_name:will +first_name:smith)
| (+last_name:will  +last_name:smith)</pre>
</div>
</div>
<div class="paragraph">
<p>In other words, <strong>all terms</strong> must be present <strong>in a single field</strong> for a document
to match.</p>
</div>
<div class="paragraph">
<p>See <a href="full-text-queries.html#type-cross-fields"><code>cross_fields</code></a> for a better solution.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="type-most-fields"><code>most_fields</code></h4>
<div class="paragraph">
<p>The <code>most_fields</code> type is most useful when querying multiple fields that
contain the same text analyzed in different ways.  For instance, the main
field may contain synonyms, stemming and terms without diacritics. A second
field may contain the original terms, and a third field might contain
shingles. By combining scores from all three fields we can match as many
documents as possible with the main field, but use the second and third fields
to push the most similar results to the top of the list.</p>
</div>
<div class="paragraph">
<p>This query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "multi_match" : {
      "query":      "quick brown fox",
      "type":       "most_fields",
      "fields":     [ "title", "title.original", "title.shingles" ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>would be executed as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "bool": {
      "should": [
        { "match": { "title":          "quick brown fox" }},
        { "match": { "title.original": "quick brown fox" }},
        { "match": { "title.shingles": "quick brown fox" }}
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The score from each <code>match</code> clause is added together, then divided by the
number of <code>match</code> clauses.</p>
</div>
<div class="paragraph">
<p>Also, accepts <code>analyzer</code>, <code>boost</code>, <code>operator</code>, <code>minimum_should_match</code>,
<code>fuzziness</code>, <code>lenient</code>, <code>prefix_length</code>, <code>max_expansions</code>, <code>fuzzy_rewrite</code>, <code>zero_terms_query</code>
and <code>cutoff_frequency</code>, as explained in <a href="full-text-queries.html#query-dsl-match-query">match query</a>, but
<strong>see <a href="full-text-queries.html#operator-min"><code>operator</code> and <code>minimum_should_match</code></a></strong>.</p>
</div>
</div>
<div class="sect3">
<h4 id="type-phrase"><code>phrase</code> and <code>phrase_prefix</code></h4>
<div class="paragraph">
<p>The <code>phrase</code> and <code>phrase_prefix</code> types behave just like <a href="full-text-queries.html#type-best-fields"><code>best_fields</code></a>,
but they use a <code>match_phrase</code> or <code>match_phrase_prefix</code> query instead of a
<code>match</code> query.</p>
</div>
<div class="paragraph">
<p>This query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "multi_match" : {
      "query":      "quick brown f",
      "type":       "phrase_prefix",
      "fields":     [ "subject", "message" ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>would be executed as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "dis_max": {
      "queries": [
        { "match_phrase_prefix": { "subject": "quick brown f" }},
        { "match_phrase_prefix": { "message": "quick brown f" }}
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, accepts <code>analyzer</code>, <a href="mapping-params.html#mapping-boost"><code>boost</code></a>, <code>lenient</code> and <code>zero_terms_query</code> as explained
in <a href="full-text-queries.html#query-dsl-match-query">Match query</a>, as well as <code>slop</code> which is explained in <a href="full-text-queries.html#query-dsl-match-query-phrase">Match phrase query</a>.
Type <code>phrase_prefix</code> additionally accepts <code>max_expansions</code>.</p>
</div>
<div id="phrase-fuzziness" class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="title"><code>phrase</code>, <code>phrase_prefix</code> and <code>fuzziness</code></div>
<div class="paragraph">
<p>The <code>fuzziness</code> parameter cannot be used with the <code>phrase</code> or <code>phrase_prefix</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="type-cross-fields"><code>cross_fields</code></h4>
<div class="paragraph">
<p>The <code>cross_fields</code> type is particularly useful with structured documents where
multiple fields <strong>should</strong> match.  For instance, when querying the <code>first_name</code>
and <code>last_name</code> fields for <code>Will Smith'', the best match is likely to have
</code>Will'' in one field and ``Smith'' in the other.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>This sounds like a job for <a href="full-text-queries.html#type-most-fields"><code>most_fields</code></a> but there are two problems
with that approach. The first problem is that <code>operator</code> and
<code>minimum_should_match</code> are applied per-field, instead of per-term (see
<a href="full-text-queries.html#operator-min">explanation above</a>).</p>
</div>
<div class="paragraph">
<p>The second problem is to do with relevance: the different term frequencies in
the <code>first_name</code> and <code>last_name</code> fields   can produce unexpected results.</p>
</div>
<div class="paragraph">
<p>For instance, imagine we have two people: <code>Will Smith'' and </code>Smith Jones''.
<code>Smith'' as a last name is very common (and so is of low importance) but
</code>Smith'' as a first name is very uncommon (and so is of great importance).</p>
</div>
<div class="paragraph">
<p>If we do a search for <code>Will Smith'', the </code>Smith Jones'' document will
probably appear above the better matching <code>`Will Smith'' because the score of
`first_name:smith</code> has trumped the combined scores of <code>first_name:will</code> plus
<code>last_name:smith</code>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>One way of dealing with these types of queries is simply to index the
<code>first_name</code> and <code>last_name</code> fields into a single <code>full_name</code> field.  Of
course, this can only be done at index time.</p>
</div>
<div class="paragraph">
<p>The <code>cross_field</code> type tries to solve these problems at query time by taking a
<em>term-centric</em> approach.  It first analyzes the query string into individual
terms, then looks for each term in any of the fields, as though they were one
big field.</p>
</div>
<div class="paragraph">
<p>A query like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "multi_match" : {
      "query":      "Will Smith",
      "type":       "cross_fields",
      "fields":     [ "first_name", "last_name" ],
      "operator":   "and"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>is executed as:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+(first_name:will  last_name:will)
+(first_name:smith last_name:smith)</pre>
</div>
</div>
<div class="paragraph">
<p>In other words, <strong>all terms</strong> must be present <strong>in at least one field</strong> for a
document to match.  (Compare this to
<a href="full-text-queries.html#operator-min">the logic used for <code>best_fields</code> and <code>most_fields</code></a>.)</p>
</div>
<div class="paragraph">
<p>That solves one of the two problems. The problem of differing term frequencies
is solved by <em>blending</em> the term frequencies for all fields in order to even
out the differences.</p>
</div>
<div class="paragraph">
<p>In practice, <code>first_name:smith</code> will be treated as though it has the same
frequencies as <code>last_name:smith</code>, plus one. This will make matches on
<code>first_name</code> and <code>last_name</code> have comparable scores, with a tiny advantage
for <code>last_name</code> since it is the most likely field that contains <code>smith</code>.</p>
</div>
<div class="paragraph">
<p>Note that <code>cross_fields</code> is usually only useful on short string fields
that all have a <code>boost</code> of <code>1</code>. Otherwise boosts, term freqs and length
normalization contribute to the score in such a way that the blending of term
statistics is not meaningful anymore.</p>
</div>
<div class="paragraph">
<p>If you run the above query through the <a href="search.html#search-validate">Validate API</a>, it returns this
explanation:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>+blended("will",  fields: [first_name, last_name])
+blended("smith", fields: [first_name, last_name])</pre>
</div>
</div>
<div class="paragraph">
<p>Also, accepts <code>analyzer</code>, <code>boost</code>, <code>operator</code>, <code>minimum_should_match</code>,
<code>lenient</code>, <code>zero_terms_query</code> and <code>cutoff_frequency</code>, as explained in
<a href="full-text-queries.html#query-dsl-match-query">match query</a>.</p>
</div>
<div class="sect4">
<h5 id="cross-field-analysis"><code>cross_field</code> and analysis</h5>
<div class="paragraph">
<p>The <code>cross_field</code> type can only work in term-centric mode on fields that have
the same analyzer. Fields with the same analyzer are grouped together as in
the example above.  If there are multiple groups, they are combined with a
<code>bool</code> query.</p>
</div>
<div class="paragraph">
<p>For instance, if we have a <code>first</code> and <code>last</code> field which have
the same analyzer, plus a <code>first.edge</code> and <code>last.edge</code> which
both use an <code>edge_ngram</code> analyzer, this query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "multi_match" : {
      "query":      "Jon",
      "type":       "cross_fields",
      "fields":     [
        "first", "first.edge",
        "last",  "last.edge"
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>would be executed as:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    blended("jon", fields: [first, last])
| (
    blended("j",   fields: [first.edge, last.edge])
    blended("jo",  fields: [first.edge, last.edge])
    blended("jon", fields: [first.edge, last.edge])
)</pre>
</div>
</div>
<div class="paragraph">
<p>In other words, <code>first</code> and <code>last</code> would be grouped together and
treated as a single field, and <code>first.edge</code> and <code>last.edge</code> would be
grouped together and treated as a single field.</p>
</div>
<div class="paragraph">
<p>Having multiple groups is fine, but when combined with <code>operator</code> or
<code>minimum_should_match</code>, it can suffer from the <a href="full-text-queries.html#operator-min">same problem</a>
as <code>most_fields</code> or <code>best_fields</code>.</p>
</div>
<div class="paragraph">
<p>You can easily rewrite this query yourself as two separate <code>cross_fields</code>
queries combined with a <code>bool</code> query, and apply the <code>minimum_should_match</code>
parameter to just one of them:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "bool": {
      "should": [
        {
          "multi_match" : {
            "query":      "Will Smith",
            "type":       "cross_fields",
            "fields":     [ "first", "last" ],
            "minimum_should_match": "50%" <b class="conum">(1)</b>
          }
        },
        {
          "multi_match" : {
            "query":      "Will Smith",
            "type":       "cross_fields",
            "fields":     [ "*.edge" ]
          }
        }
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Either <code>will</code> or <code>smith</code> must be present in either of the <code>first</code>
or <code>last</code> fields</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You can force all fields into the same group by specifying the <code>analyzer</code>
parameter in the query.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
   "multi_match" : {
      "query":      "Jon",
      "type":       "cross_fields",
      "analyzer":   "standard", <b class="conum">(1)</b>
      "fields":     [ "first", "last", "*.edge" ]
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Use the <code>standard</code> analyzer for all fields.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>which will be executed as:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>blended("will",  fields: [first, first.edge, last.edge, last])
blended("smith", fields: [first, first.edge, last.edge, last])</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="tie-breaker"><code>tie_breaker</code></h5>
<div class="paragraph">
<p>By default, each per-term <code>blended</code> query will use the best score returned by
any field in a group, then these scores are added together to give the final
score. The <code>tie_breaker</code> parameter can change the default behaviour of the
per-term <code>blended</code> queries. It accepts:</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>0.0</code>
</td>
<td class="hdlist2">
<p>Take the single best score out of (eg) <code>first_name:will</code>
and <code>last_name:will</code> (<strong>default</strong> for all <code>multi_match</code>
query types except <code>bool_prefix</code> and <code>most_fields</code>)</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>1.0</code>
</td>
<td class="hdlist2">
<p>Add together the scores for (eg) <code>first_name:will</code> and
<code>last_name:will</code> (<strong>default</strong> for the <code>bool_prefix</code> and
<code>most_fields</code> <code>multi_match</code> query types)</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>0.0 &lt; n &lt; 1.0</code>
</td>
<td class="hdlist2">
<p>Take the single best score plus tie_breaker multiplied
by each of the scores from other matching fields.</p>
</td>
</tr>
</table>
</div>
<div id="crossfields-fuzziness" class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="title"><code>cross_fields</code> and <code>fuzziness</code></div>
<div class="paragraph">
<p>The <code>fuzziness</code> parameter cannot be used with the <code>cross_fields</code> type.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="type-bool-prefix"><code>bool_prefix</code></h4>
<div class="paragraph">
<p>The <code>bool_prefix</code> type&#8217;s scoring behaves like <a href="full-text-queries.html#type-most-fields"><code>most_fields</code></a>, but using a
<a href="full-text-queries.html#query-dsl-match-bool-prefix-query"><code>match_bool_prefix</code> query</a> instead of a
<code>match</code> query.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "multi_match" : {
      "query":      "quick brown f",
      "type":       "bool_prefix",
      "fields":     [ "subject", "message" ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>analyzer</code>, <code>boost</code>, <code>operator</code>, <code>minimum_should_match</code>, <code>lenient</code>,
<code>zero_terms_query</code>, and <code>auto_generate_synonyms_phrase_query</code> parameters as
explained in <a href="full-text-queries.html#query-dsl-match-query">match query</a> are supported. The
<code>fuzziness</code>, <code>prefix_length</code>, <code>max_expansions</code>, <code>fuzzy_rewrite</code>, and
<code>fuzzy_transpositions</code> parameters are supported for the terms that are used to
construct term queries, but do not have an effect on the prefix query
constructed from the final term.</p>
</div>
<div class="paragraph">
<p>The <code>slop</code> and <code>cutoff_frequency</code> parameters are not supported by this query
type.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="query-dsl-common-terms-query">Common Terms Query</h3>
<div class="paragraph">
<p>This query is deprecated. Use <a href="full-text-queries.html#query-dsl-match-query">Match query</a> instead, which skips blocks of documents efficiently, without any configuration, provided that the total number of hits is not tracked.</p>
</div>
<div class="paragraph">
<p>The <code>common</code> terms query is a modern alternative to stopwords which
improves the precision and recall of search results (by taking stopwords
into account), without sacrificing performance.</p>
</div>
<h4 id="_the_problem" class="discrete">The problem</h4>
<div class="paragraph">
<p>Every term in a query has a cost. A search for <code>"The brown fox"</code>
requires three term queries, one for each of <code>"the"</code>, <code>"brown"</code> and
<code>"fox"</code>, all of which are executed against all documents in the index.
The query for <code>"the"</code> is likely to match many documents and thus has a
much smaller impact on relevance than the other two terms.</p>
</div>
<div class="paragraph">
<p>Previously, the solution to this problem was to ignore terms with high
frequency. By treating <code>"the"</code> as a <em>stopword</em>, we reduce the index size
and reduce the number of term queries that need to be executed.</p>
</div>
<div class="paragraph">
<p>The problem with this approach is that, while stopwords have a small
impact on relevance, they are still important. If we remove stopwords,
we lose precision, (eg we are unable to distinguish between <code>"happy"</code>
and <code>"not happy"</code>) and we lose recall (eg text like <code>"The The"</code> or
<code>"To be or not to be"</code> would simply not exist in the index).</p>
</div>
<h4 id="_the_solution" class="discrete">The solution</h4>
<div class="paragraph">
<p>The <code>common</code> terms query divides the query terms into two groups: more
important (ie <em>low frequency</em> terms) and less important (ie <em>high
frequency</em> terms which would previously have been stopwords).</p>
</div>
<div class="paragraph">
<p>First it searches for documents which match the more important terms.
These are the terms which appear in fewer documents and have a greater
impact on relevance.</p>
</div>
<div class="paragraph">
<p>Then, it executes a second query for the less important terms&#8201;&#8212;&#8201;terms
which appear frequently and have a low impact on relevance. But instead
of calculating the relevance score for <strong>all</strong> matching documents, it only
calculates the <code>_score</code> for documents already matched by the first
query. In this way the high frequency terms can improve the relevance
calculation without paying the cost of poor performance.</p>
</div>
<div class="paragraph">
<p>If a query consists only of high frequency terms, then a single query is
executed as an <code>AND</code> (conjunction) query, in other words all terms are
required. Even though each individual term will match many documents,
the combination of terms narrows down the resultset to only the most
relevant. The single query can also be executed as an <code>OR</code> with a
specific
<a href="query-dsl-minimum-should-match.html"><code>minimum_should_match</code></a>,
in this case a high enough value should probably be used.</p>
</div>
<div class="paragraph">
<p>Terms are allocated to the high or low frequency groups based on the
<code>cutoff_frequency</code>, which can be specified as an absolute frequency
(<code>&gt;=1</code>) or as a relative frequency (<code>0.0 .. 1.0</code>). (Remember that document
frequencies are computed on a per shard level as explained in the blog post
<a href="https://www.opensearch.org/guide/en/opensearch/guide/2.x/relevance-is-broken.html">Relevance is broken</a>.)</p>
</div>
<div class="paragraph">
<p>Perhaps the most interesting property of this query is that it adapts to
domain specific stopwords automatically. For example, on a video hosting
site, common terms like <code>"clip"</code> or <code>"video"</code> will automatically behave
as stopwords without the need to maintain a manual list.</p>
</div>
<h4 id="_examples" class="discrete">Examples</h4>
<div class="paragraph">
<p>In this example, words that have a document frequency greater than 0.1%
(eg <code>"this"</code> and <code>"is"</code>) will be treated as <em>common terms</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "common": {
      "body": {
        "query": "this is bonsai cool",
        "cutoff_frequency": 0.001
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The number of terms which should match can be controlled with the
<a href="query-dsl-minimum-should-match.html"><code>minimum_should_match</code></a>
(<code>high_freq</code>, <code>low_freq</code>), <code>low_freq_operator</code> (default <code>"or"</code>) and
<code>high_freq_operator</code> (default <code>"or"</code>) parameters.</p>
</div>
<div class="paragraph">
<p>For low frequency terms, set the <code>low_freq_operator</code> to <code>"and"</code> to make
all terms required:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "common": {
      "body": {
        "query": "nelly the elephant as a cartoon",
        "cutoff_frequency": 0.001,
        "low_freq_operator": "and"
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>which is roughly equivalent to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "bool": {
      "must": [
      { "term": { "body": "nelly"}},
      { "term": { "body": "elephant"}},
      { "term": { "body": "cartoon"}}
      ],
      "should": [
      { "term": { "body": "the"}},
      { "term": { "body": "as"}},
      { "term": { "body": "a"}}
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively use
<a href="query-dsl-minimum-should-match.html"><code>minimum_should_match</code></a>
to specify a minimum number or percentage of low frequency terms which
must be present, for instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "common": {
      "body": {
        "query": "nelly the elephant as a cartoon",
        "cutoff_frequency": 0.001,
        "minimum_should_match": 2
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>which is roughly equivalent to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "bool": {
      "must": {
        "bool": {
          "should": [
            { "term": { "body": "nelly"}},
            { "term": { "body": "elephant"}},
            { "term": { "body": "cartoon"}}
          ],
          "minimum_should_match": 2
        }
      },
      "should": [
        { "term": { "body": "the"}},
        { "term": { "body": "as"}},
        { "term": { "body": "a"}}
      ]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A different
<a href="query-dsl-minimum-should-match.html"><code>minimum_should_match</code></a>
can be applied for low and high frequency terms with the additional
<code>low_freq</code> and <code>high_freq</code> parameters. Here is an example when providing
additional parameters (note the change in structure):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "common": {
      "body": {
        "query": "nelly the elephant not as a cartoon",
        "cutoff_frequency": 0.001,
        "minimum_should_match": {
          "low_freq": 2,
          "high_freq": 3
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>which is roughly equivalent to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "bool": {
      "must": {
        "bool": {
          "should": [
            { "term": { "body": "nelly"}},
            { "term": { "body": "elephant"}},
            { "term": { "body": "cartoon"}}
          ],
          "minimum_should_match": 2
        }
      },
      "should": {
        "bool": {
          "should": [
            { "term": { "body": "the"}},
            { "term": { "body": "not"}},
            { "term": { "body": "as"}},
            { "term": { "body": "a"}}
          ],
          "minimum_should_match": 3
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case it means the high frequency terms have only an impact on
relevance when there are at least three of them. But the most
interesting use of the
<a href="query-dsl-minimum-should-match.html"><code>minimum_should_match</code></a>
for high frequency terms is when there are only high frequency terms:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "common": {
      "body": {
        "query": "how not to be",
        "cutoff_frequency": 0.001,
        "minimum_should_match": {
          "low_freq": 2,
          "high_freq": 3
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>which is roughly equivalent to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "bool": {
      "should": [
        { "term": { "body": "how"}},
        { "term": { "body": "not"}},
        { "term": { "body": "to"}},
        { "term": { "body": "be"}}
      ],
      "minimum_should_match": "3&lt;50%"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The high frequency generated query is then slightly less restrictive
than with an <code>AND</code>.</p>
</div>
<div class="paragraph">
<p>The <code>common</code> terms query also supports <code>boost</code> and <code>analyzer</code> as
parameters.</p>
</div>
</div>
<div class="sect2">
<h3 id="query-dsl-query-string-query">Query string query</h3>
<titleabbrev>Query string</titleabbrev>
<div class="paragraph">
<p>Returns documents based on a provided query string, using a parser with a strict
syntax.</p>
</div>
<div class="paragraph">
<p>This query uses a <a href="full-text-queries.html#query-string-syntax">syntax</a> to parse and split the provided
query string based on operators, such as <code>AND</code> or <code>NOT</code>. The query
then <a href="analysis.html">analyzes</a> each split text independently before returning
matching documents.</p>
</div>
<div class="paragraph">
<p>You can use the <code>query_string</code> query to create a complex search that includes
wildcard characters, searches across multiple fields, and more. While versatile,
the query is strict and returns an error if the query string includes any
invalid syntax.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Because it returns an error for any invalid syntax, we don&#8217;t recommend using
the <code>query_string</code> query for search boxes.</p>
</div>
<div class="paragraph">
<p>If you don&#8217;t need to support a query syntax, consider using the
<a href="full-text-queries.html#query-dsl-match-query"><code>match</code></a> query. If you need the features of a query
syntax, use the <a href="full-text-queries.html#query-dsl-simple-query-string-query"><code>simple_query_string</code></a>
query, which is less strict.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="query-string-query-ex-request">Example request</h4>
<div class="paragraph">
<p>When running the following search, the <code>query_string</code> query splits <code>(new york
city) OR (big apple)</code> into two parts: <code>new york city</code> and <code>big apple</code>. The
<code>content</code> field&#8217;s analyzer then independently converts each part into tokens
before returning matching documents. Because the query syntax does not use
whitespace as an operator, <code>new york city</code> is passed as-is to the analyzer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "query_string": {
      "query": "(new york city) OR (big apple)",
      "default_field": "content"
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="query-string-top-level-params">Top-level parameters for <code>query_string</code></h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>query</code></dt>
<dd>
<p>(Required, string) Query string you wish to parse and use for search. See
<a href="full-text-queries.html#query-string-syntax">Query string syntax</a>.</p>
</dd>
<dt class="hdlist1"><code>default_field</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string) Default field you wish to search if no field is provided in
the query string.</p>
</div>
<div class="paragraph">
<p>Defaults to the <code>index.query.default_field</code> index setting, which has a default
value of <code><strong></code>. The <code></strong></code> value extracts all fields that are eligible for term
queries and filters the metadata fields. All extracted fields are then
combined to build a query if no <code>prefix</code> is specified.</p>
</div>
<div class="paragraph">
<p>Searching across all eligible fields does not include <a href="mapping-types.html#nested">nested
documents</a>. Use a <a href="joining-queries.html#query-dsl-nested-query"><code>nested</code> query</a> to search those
documents.</p>
</div>
<div id="WARNING" class="exampleblock">
<div class="content">
<div class="paragraph">
<p>For mappings with a large number of fields, searching across all eligible fields
could be expensive.</p>
</div>
<div class="paragraph">
<p>There is a limit on the number of fields that can be queried at once.
It is defined by the <code>indices.query.bool.max_clause_count</code>
<a href="settings.html#search-settings">search setting</a>, which defaults to 1024.</p>
</div>
</div>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>allow_leading_wildcard</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, the wildcard characters <code>*</code> and <code>?</code> are allowed
as the first character of the query string. Defaults to <code>true</code>.</p>
</dd>
<dt class="hdlist1"><code>analyze_wildcard</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, the query attempts to analyze wildcard terms in
the query string. Defaults to <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>analyzer</code></dt>
<dd>
<p>(Optional, string) <a href="analysis.html">Analyzer</a> used to convert text in the
query string into tokens. Defaults to the
<a href="configure-text-analysis.html#specify-index-time-analyzer">index-time analyzer</a> mapped for the
<code>default_field</code>. If no analyzer is mapped, the index&#8217;s default analyzer is used.</p>
</dd>
<dt class="hdlist1"><code>auto_generate_synonyms_phrase_query</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, <a href="full-text-queries.html#query-dsl-match-query-phrase">match phrase</a>
queries are automatically created for multi-term synonyms. Defaults to <code>true</code>.
See <a href="full-text-queries.html#query-string-synonyms">Synonyms and the <code>query_string</code> query</a> for an example.</p>
</dd>
<dt class="hdlist1"><code>boost</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, float) Floating point number used to decrease or increase the
<a href="query-filter-context.html#relevance-scores">relevance scores</a> of the query. Defaults to <code>1.0</code>.</p>
</div>
<div class="paragraph">
<p>Boost values are relative to the default value of <code>1.0</code>. A boost value between
<code>0</code> and <code>1.0</code> decreases the relevance score. A value greater than <code>1.0</code>
increases the relevance score.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>default_operator</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string) Default boolean logic used to interpret text in the query
string if no operators are specified. Valid values are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>OR</code> (Default)</dt>
<dd>
<p>For example, a query string of <code>capital of Hungary</code> is interpreted as <code>capital
OR of OR Hungary</code>.</p>
</dd>
<dt class="hdlist1"><code>AND</code></dt>
<dd>
<p>For example, a query string of <code>capital of Hungary</code> is interpreted as <code>capital
AND of AND Hungary</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>enable_position_increments</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, enable position increments in queries constructed
from a <code>query_string</code> search. Defaults to <code>true</code>.</p>
</dd>
<dt class="hdlist1"><code>fields</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, array of strings) Array of fields you wish to search.</p>
</div>
<div class="paragraph">
<p>You can use this parameter query to search across multiple fields. See
<a href="full-text-queries.html#query-string-multi-field">Search multiple fields</a>.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>fuzziness</code></dt>
<dd>
<p>(Optional, string) Maximum edit distance allowed for matching. See <a href="api-conventions.html#fuzziness">Fuzziness</a>
for valid values and more information.</p>
</dd>
<dt class="hdlist1"><code>fuzzy_max_expansions</code></dt>
<dd>
<p>(Optional, integer) Maximum number of terms to which the query expands for fuzzy
matching. Defaults to <code>50</code>.</p>
</dd>
<dt class="hdlist1"><code>fuzzy_prefix_length</code></dt>
<dd>
<p>(Optional, integer) Number of beginning characters left unchanged for fuzzy
matching. Defaults to <code>0</code>.</p>
</dd>
<dt class="hdlist1"><code>fuzzy_transpositions</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, edits for fuzzy matching include
transpositions of two adjacent characters (ab → ba). Defaults to <code>true</code>.</p>
</dd>
<dt class="hdlist1"><code>lenient</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, format-based errors, such as providing a text
value for a <a href="mapping-types.html#number">numeric</a> field, are ignored. Defaults to <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>max_determinized_states</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, integer) Maximum number of
<a href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton">automaton states</a>
required for the query. Default is <code>10000</code>.</p>
</div>
<div class="paragraph">
<p>OpenSearch uses <a href="https://lucene.apache.org/core/">Apache Lucene</a> internally to parse
regular expressions. Lucene converts each regular expression to a finite
automaton containing a number of determinized states.</p>
</div>
<div class="paragraph">
<p>You can use this parameter to prevent that conversion from unintentionally
consuming too many resources. You may need to increase this limit to run complex
regular expressions.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>minimum_should_match</code></dt>
<dd>
<p>(Optional, string) Minimum number of clauses that must match for a document to
be returned. See the <a href="query-dsl-minimum-should-match.html"><code>minimum_should_match</code>
parameter</a> for valid values and more information. See
<a href="full-text-queries.html#query-string-min-should-match">How <code>minimum_should_match</code> works</a> for an example.</p>
</dd>
<dt class="hdlist1"><code>quote_analyzer</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string) <a href="analysis.html">Analyzer</a> used to convert quoted text in the
query string into tokens. Defaults to the
<a href="mapping-params.html#search-quote-analyzer"><code>search_quote_analyzer</code></a> mapped for the
<code>default_field</code>.</p>
</div>
<div class="paragraph">
<p>For quoted text, this parameter overrides the analyzer specified in the
<code>analyzer</code> parameter.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>phrase_slop</code></dt>
<dd>
<p>(Optional, integer) Maximum number of positions allowed between matching tokens
for phrases. Defaults to <code>0</code>. If <code>0</code>, exact phrase matches are required.
Transposed terms have a slop of <code>2</code>.</p>
</dd>
<dt class="hdlist1"><code>quote_field_suffix</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string) Suffix appended to quoted text in the query string.</p>
</div>
<div class="paragraph">
<p>You can use this suffix to use a different analysis method for exact matches.
See <a href="recipes.html#mixing-exact-search-with-stemming">Mixing exact search with stemming</a>.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>rewrite</code></dt>
<dd>
<p>(Optional, string) Method used to rewrite the query. For valid values and more
information, see the <a href="query-dsl-multi-term-rewrite.html"><code>rewrite</code> parameter</a>.</p>
</dd>
<dt class="hdlist1"><code>time_zone</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string)
<a href="https://en.wikipedia.org/wiki/List_of_UTC_time_offsets">Coordinated Universal
Time (UTC) offset</a> or
<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">IANA time zone</a>
used to convert <code>date</code> values in the query string to UTC.</p>
</div>
<div class="paragraph">
<p>Valid values are ISO 8601 UTC offsets, such as <code>+01:00</code> or -<code>08:00</code>, and IANA
time zone IDs, such as <code>America/Los_Angeles</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>time_zone</code> parameter does <strong>not</strong> affect the <a href="api-conventions.html#date-math">date math</a> value
of <code>now</code>. <code>now</code> is always the current system time in UTC. However, the
<code>time_zone</code> parameter does convert dates calculated using <code>now</code> and
<a href="api-conventions.html#date-math">date math rounding</a>. For example, the <code>time_zone</code> parameter will
convert a value of <code>now/d</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="query-string-query-notes">Notes</h4>
<div class="sect4">
<h5 id="query-string-syntax">Query string syntax</h5>
<div class="paragraph">
<p>The query string <code>`mini-language'' is used by the
<a href="full-text-queries.html#query-dsl-query-string-query">Query string query</a> and by the
`q</code> query string parameter in the <a href="search.html#search-search"><code>search</code> API</a>.</p>
</div>
<div class="paragraph">
<p>The query string is parsed into a series of <em>terms</em> and <em>operators</em>. A
term can be a single word&#8201;&#8212;&#8201;<code>quick</code> or <code>brown</code>&#8201;&#8212;&#8201;or a phrase, surrounded by
double quotes&#8201;&#8212;&#8201;<code>"quick brown"</code>&#8201;&#8212;&#8201;which searches for all the words in the
phrase, in the same order.</p>
</div>
<div class="paragraph">
<p>Operators allow you to customize the search&#8201;&#8212;&#8201;the available options are
explained below.</p>
</div>
<div class="sect5">
<h6 id="_field_names">Field names</h6>
<div class="paragraph">
<p>You can specify fields to search in the query syntax:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>where the <code>status</code> field contains <code>active</code></p>
<div class="literalblock">
<div class="content">
<pre>status:active</pre>
</div>
</div>
</li>
<li>
<p>where the <code>title</code> field contains <code>quick</code> or <code>brown</code></p>
<div class="literalblock">
<div class="content">
<pre>title:(quick OR brown)</pre>
</div>
</div>
</li>
<li>
<p>where the <code>author</code> field contains the exact phrase <code>"john smith"</code></p>
<div class="literalblock">
<div class="content">
<pre>author:"John Smith"</pre>
</div>
</div>
</li>
<li>
<p>where the <code>first name</code> field contains <code>Alice</code> (note how we need to escape
the space with a backslash)</p>
<div class="literalblock">
<div class="content">
<pre>first\ name:Alice</pre>
</div>
</div>
</li>
<li>
<p>where any of the fields <code>book.title</code>, <code>book.content</code> or <code>book.date</code> contains
<code>quick</code> or <code>brown</code> (note how we need to escape the <code>*</code> with a backslash):</p>
<div class="literalblock">
<div class="content">
<pre>book.\*:(quick OR brown)</pre>
</div>
</div>
</li>
<li>
<p>where the field <code>title</code> has any non-null value:</p>
<div class="literalblock">
<div class="content">
<pre>_exists_:title</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="query-string-wildcard">Wildcards</h6>
<div class="paragraph">
<p>Wildcard searches can be run on individual terms, using <code>?</code> to replace
a single character, and <code>*</code> to replace zero or more characters:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>qu?ck bro*</pre>
</div>
</div>
<div class="paragraph">
<p>Be aware that wildcard queries can use an enormous amount of memory and
perform very badly&#8201;&#8212;&#8201;just think how many terms need to be queried to
match the query string <code>"a* b* c*"</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Pure wildcards <code>*</code> are rewritten to <a href="term-level-queries.html#query-dsl-exists-query"><code>exists</code></a> queries for efficiency.
As a consequence, the wildcard <code>"field:*"</code> would match documents with an empty value
 like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "field": ""
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>... and would <strong>not</strong> match if the field is missing or set with an explicit null
value like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  "field": null
}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Allowing a wildcard at the beginning of a word (eg <code>"*ing"</code>) is particularly
heavy, because all terms in the index need to be examined, just in case
they match.  Leading wildcards can be disabled by setting
<code>allow_leading_wildcard</code> to <code>false</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Only parts of the analysis chain that operate at the character level are
applied. So for instance, if the analyzer performs both lowercasing and
stemming, only the lowercasing will be applied: it would be wrong to perform
stemming on a word that is missing some of its letters.</p>
</div>
<div class="paragraph">
<p>By setting <code>analyze_wildcard</code> to true, queries that end with a <code>*</code> will be
analyzed and a boolean query will be built out of the different tokens, by
ensuring exact matches on the first N-1 tokens, and prefix match on the last
token.</p>
</div>
</div>
<div class="sect5">
<h6 id="_regular_expressions">Regular expressions</h6>
<div class="paragraph">
<p>Regular expression patterns can be embedded in the query string by
wrapping them in forward-slashes (<code>"/"</code>):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>name:/joh?n(ath[oa]n)/</pre>
</div>
</div>
<div class="paragraph">
<p>The supported regular expression syntax is explained in <a href="regexp-syntax.html">Regular expression syntax</a>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>allow_leading_wildcard</code> parameter does not have any control over
regular expressions.  A query string such as the following would force
OpenSearch to visit every term in the index:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/.*n/</pre>
</div>
</div>
<div class="paragraph">
<p>Use with caution!</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="query-string-fuzziness">Fuzziness</h6>
<div class="paragraph">
<p>We can search for terms that are
similar to, but not exactly like our search terms, using the ``fuzzy''
operator:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>quikc~ brwn~ foks~</pre>
</div>
</div>
<div class="paragraph">
<p>This uses the
<a href="https://en.wikipedia.org/wiki/Damerau-Levenshtein_distance">Damerau-Levenshtein distance</a>
to find all terms with a maximum of
two changes, where a change is the insertion, deletion
or substitution of a single character, or transposition of two adjacent
characters.</p>
</div>
<div class="paragraph">
<p>The default <em>edit distance</em> is <code>2</code>, but an edit distance of <code>1</code> should be
sufficient to catch 80% of all human misspellings. It can be specified as:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>quikc~1</pre>
</div>
</div>
<div id="avoid-widlcards-fuzzy-searches" class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="title">Avoid mixing fuzziness with wildcards</div>
<div class="paragraph">
<p>Mixing <a href="api-conventions.html#fuzziness">fuzzy</a> and <a href="full-text-queries.html#query-string-wildcard">wildcard</a> operators is
<em>not</em> supported. When mixed, one of the operators is not applied. For example,
you can search for <code>app~1</code> (fuzzy) or <code>app*</code> (wildcard), but searches for
<code>app*~1</code> do not apply the fuzzy operator (<code>~1</code>).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_proximity_searches">Proximity searches</h6>
<div class="paragraph">
<p>While a phrase query (eg <code>"john smith"</code>) expects all of the terms in exactly
the same order, a proximity query allows the specified words to be further
apart or in a different order.  In the same way that fuzzy queries can
specify a maximum edit distance for characters in a word, a proximity search
allows us to specify a maximum edit distance of words in a phrase:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"fox quick"~5</pre>
</div>
</div>
<div class="paragraph">
<p>The closer the text in a field is to the original order specified in the
query string, the more relevant that document is considered to be. When
compared to the above example query, the phrase <code>"quick fox"</code> would be
considered more relevant than <code>"quick brown fox"</code>.</p>
</div>
</div>
<div class="sect5">
<h6 id="_ranges">Ranges</h6>
<div class="paragraph">
<p>Ranges can be specified for date, numeric or string fields. Inclusive ranges
are specified with square brackets <code>[min TO max]</code> and exclusive ranges with
curly brackets <code>{min TO max}</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>All days in 2012:</p>
<div class="literalblock">
<div class="content">
<pre>date:[2012-01-01 TO 2012-12-31]</pre>
</div>
</div>
</li>
<li>
<p>Numbers 1..5</p>
<div class="literalblock">
<div class="content">
<pre>count:[1 TO 5]</pre>
</div>
</div>
</li>
<li>
<p>Tags between <code>alpha</code> and <code>omega</code>, excluding <code>alpha</code> and <code>omega</code>:</p>
<div class="literalblock">
<div class="content">
<pre>tag:{alpha TO omega}</pre>
</div>
</div>
</li>
<li>
<p>Numbers from 10 upwards</p>
<div class="literalblock">
<div class="content">
<pre>count:[10 TO *]</pre>
</div>
</div>
</li>
<li>
<p>Dates before 2012</p>
<div class="literalblock">
<div class="content">
<pre>date:{* TO 2012-01-01}</pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Curly and square brackets can be combined:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Numbers from 1 up to but not including 5</p>
<div class="literalblock">
<div class="content">
<pre>count:[1 TO 5}</pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ranges with one side unbounded can use the following syntax:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>age:&gt;10
age:&gt;=10
age:&lt;10
age:&lt;=10</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>To combine an upper and lower bound with the simplified syntax, you
would need to join two clauses with an <code>AND</code> operator:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>age:(&gt;=10 AND &lt;20)
age:(+&gt;=10 +&lt;20)</pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The parsing of ranges in query strings can be complex and error prone. It is
much more reliable to use an explicit <a href="term-level-queries.html#query-dsl-range-query"><code>range</code> query</a>.</p>
</div>
</div>
<div class="sect5">
<h6 id="_boosting">Boosting</h6>
<div class="paragraph">
<p>Use the <em>boost</em> operator <code>^</code> to make one term more relevant than another.
For instance, if we want to find all documents about foxes, but we are
especially interested in quick foxes:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>quick^2 fox</pre>
</div>
</div>
<div class="paragraph">
<p>The default <code>boost</code> value is 1, but can be any positive floating point number.
Boosts between 0 and 1 reduce relevance.</p>
</div>
<div class="paragraph">
<p>Boosts can also be applied to phrases or to groups:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"john smith"^2   (foo bar)^4</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_boolean_operators">Boolean operators</h6>
<div class="paragraph">
<p>By default, all terms are optional, as long as one term matches.  A search
for <code>foo bar baz</code> will find any document that contains one or more of
<code>foo</code> or <code>bar</code> or <code>baz</code>.  We have already discussed the <code>default_operator</code>
above which allows you to force all terms to be required, but there are
also <em>boolean operators</em> which can be used in the query string itself
to provide more control.</p>
</div>
<div class="paragraph">
<p>The preferred operators are <code>+</code> (this term <strong>must</strong> be present) and <code>-</code>
(this term <strong>must not</strong> be present). All other terms are optional.
For example, this query:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>quick brown +fox -news</pre>
</div>
</div>
<div class="paragraph">
<p>states that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>fox</code> must be present</p>
</li>
<li>
<p><code>news</code> must not be present</p>
</li>
<li>
<p><code>quick</code> and <code>brown</code> are optional&#8201;&#8212;&#8201;their presence increases the relevance</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The familiar boolean operators <code>AND</code>, <code>OR</code> and <code>NOT</code> (also written <code>&amp;&amp;</code>, <code>||</code>
and <code>!</code>) are also supported but beware that they do not honor the usual
precedence rules, so parentheses should be used whenever multiple operators are
used together. For instance the previous query could be rewritten as:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>((quick AND fox) OR (brown AND fox) OR fox) AND NOT news</code></dt>
<dd>
<p>This form now replicates the logic from the original query correctly, but
the relevance scoring bears little resemblance to the original.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>In contrast, the same query rewritten using the <a href="full-text-queries.html#query-dsl-match-query"><code>match</code> query</a>
would look like this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>{
    "bool": {
        "must":     { "match": "fox"         },
        "should":   { "match": "quick brown" },
        "must_not": { "match": "news"        }
    }
}</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_grouping">Grouping</h6>
<div class="paragraph">
<p>Multiple terms or clauses can be grouped together with parentheses, to form
sub-queries:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>(quick OR brown) AND fox</pre>
</div>
</div>
<div class="paragraph">
<p>Groups can be used to target a particular field, or to boost the result
of a sub-query:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>status:(active OR pending) title:(full text search)^2</pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_reserved_characters">Reserved characters</h6>
<div class="paragraph">
<p>If you need to use any of the characters which function as operators in your
query itself (and not as operators), then you should escape them with
a leading backslash. For instance, to search for <code>(1+1)=2</code>, you would
need to write your query as <code>\(1\+1\)\=2</code>. When using JSON for the request body, two preceding backslashes (<code>\\</code>) are required; the backslash is a reserved escaping character in JSON strings.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /my-index-000001/_search
{
  "query" : {
    "query_string" : {
      "query" : "bilbo\\!",
      "fields"  : ["user.id"]
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The reserved characters are:  <code>+ - = &amp;&amp; || &gt; &lt; ! ( ) { } [ ] ^ " ~ * ? : \ /</code></p>
</div>
<div class="paragraph">
<p>Failing to escape these special characters correctly could lead to a syntax error which prevents your query from running.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<code>&lt;</code> and <code>&gt;</code> can&#8217;t be escaped at all. The only way to prevent them from
attempting to create a range query is to remove them from the query string
entirely.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_whitespaces_and_empty_queries">Whitespaces and empty queries</h6>
<div class="paragraph">
<p>Whitespace is not considered an operator.</p>
</div>
<div class="paragraph">
<p>If the query string is empty or only contains whitespaces the query will
yield an empty result set.</p>
</div>
</div>
<div class="sect5">
<h6 id="query-string-nested">Avoid using the <code>query_string</code> query for nested documents</h6>
<div class="paragraph">
<p><code>query_string</code> searches do not return <a href="mapping-types.html#nested">nested</a> documents. To search
nested documents, use the <a href="joining-queries.html#query-dsl-nested-query"><code>nested</code> query</a>.</p>
</div>
</div>
<div class="sect5">
<h6 id="query-string-multi-field">Search multiple fields</h6>
<div class="paragraph">
<p>You can use the <code>fields</code> parameter to perform a <code>query_string</code> search across
multiple fields.</p>
</div>
<div class="paragraph">
<p>The idea of running the <code>query_string</code> query against multiple fields is to
expand each query term to an OR clause like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>field1:query_term OR field2:query_term | ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>For example, the following query</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "query_string": {
      "fields": [ "content", "name" ],
      "query": "this AND that"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>matches the same words as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "query_string": {
      "query": "(content:this OR name:this) AND (content:that OR name:that)"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since several queries are generated from the individual search terms,
combining them is automatically done using a <code>dis_max</code> query with a <code>tie_breaker</code>.
For example (the <code>name</code> is boosted by 5 using <code>^5</code> notation):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "query_string" : {
      "fields" : ["content", "name^5"],
      "query" : "this AND that OR thus",
      "tie_breaker" : 0
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Simple wildcard can also be used to search "within" specific inner
elements of the document. For example, if we have a <code>city</code> object with
several fields (or inner object with fields) in it, we can automatically
search on all "city" fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "query_string" : {
      "fields" : ["city.*"],
      "query" : "this AND that OR thus"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another option is to provide the wildcard fields search in the query
string itself (properly escaping the <code><strong></code> sign), for example:
<code>city.\</strong>:something</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "query_string" : {
      "query" : "city.\\*:(this AND that OR thus)"
    }
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Since <code>\</code> (backslash) is a special character in json strings, it needs to
be escaped, hence the two backslashes in the above <code>query_string</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The fields parameter can also include pattern based field names,
allowing to automatically expand to the relevant fields (dynamically
introduced fields included). For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "query_string" : {
      "fields" : ["content", "name.*^5"],
      "query" : "this AND that OR thus"
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="query-string-multi-field-parms">Additional parameters for multiple field searches</h6>
<div class="paragraph">
<p>When running the <code>query_string</code> query against multiple fields, the
following additional parameters are supported.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>type</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string) Determines how the query matches and scores documents. Valid
values are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>best_fields</code> (Default)</dt>
<dd>
<p>Finds documents which match any field and uses the highest
<a href="query-filter-context.html#relevance-scores"><code>_score</code></a> from any matching field. See
<a href="full-text-queries.html#type-best-fields"><code>best_fields</code></a>.</p>
</dd>
<dt class="hdlist1"><code>bool_prefix</code></dt>
<dd>
<p>Creates a <code>match_bool_prefix</code> query on each field and combines the <code>_score</code> from
each field. See <a href="full-text-queries.html#type-bool-prefix"><code>bool_prefix</code></a>.</p>
</dd>
<dt class="hdlist1"><code>cross_fields</code></dt>
<dd>
<p>Treats fields with the same <code>analyzer</code> as though they were one big field. Looks
for each word in <strong>any</strong> field. See <a href="full-text-queries.html#type-cross-fields"><code>cross_fields</code></a>.</p>
</dd>
<dt class="hdlist1"><code>most_fields</code></dt>
<dd>
<p>Finds documents which match any field and combines the <code>_score</code> from each field.
See <a href="full-text-queries.html#type-most-fields"><code>most_fields</code></a>.</p>
</dd>
<dt class="hdlist1"><code>phrase</code></dt>
<dd>
<p>Runs a <code>match_phrase</code> query on each field and uses the <code>_score</code> from the best
field. See <a href="full-text-queries.html#type-phrase"><code>phrase</code> and <code>phrase_prefix</code></a>.</p>
</dd>
<dt class="hdlist1"><code>phrase_prefix</code></dt>
<dd>
<p>Runs a <code>match_phrase_prefix</code> query on each field and uses the <code>_score</code> from the
best field. See <a href="full-text-queries.html#type-phrase"><code>phrase</code> and <code>phrase_prefix</code></a>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>NOTE:
Additional top-level <code>multi_match</code> parameters may be available based on the
<a href="full-text-queries.html#multi-match-types"><code>type</code></a> value.</p>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect4">
<h5 id="query-string-synonyms">Synonyms and the <code>query_string</code> query</h5>
<div class="paragraph">
<p>The <code>query_string</code> query supports multi-terms synonym expansion with the <a href="analysis-tokenfilters.html#analysis-synonym-graph-tokenfilter">synonym_graph</a> token filter. When this filter is used, the parser creates a phrase query for each multi-terms synonyms.
For example, the following synonym: <code>ny, new york</code> would produce:</p>
</div>
<div class="paragraph">
<p><code>(ny OR ("new york"))</code></p>
</div>
<div class="paragraph">
<p>It is also possible to match multi terms synonyms with conjunctions instead:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
   "query": {
       "query_string" : {
           "default_field": "title",
           "query" : "ny city",
           "auto_generate_synonyms_phrase_query" : false
       }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example above creates a boolean query:</p>
</div>
<div class="paragraph">
<p><code>(ny OR (new AND york)) city</code></p>
</div>
<div class="paragraph">
<p>that matches documents with the term <code>ny</code> or the conjunction <code>new AND york</code>.
By default the parameter <code>auto_generate_synonyms_phrase_query</code> is set to <code>true</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="query-string-min-should-match">How <code>minimum_should_match</code> works</h5>
<div class="paragraph">
<p>The <code>query_string</code> splits the query around each operator to create a boolean
query for the entire input. You can use <code>minimum_should_match</code> to control how
many "should" clauses in the resulting query should match.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "query_string": {
      "fields": [
        "title"
      ],
      "query": "this that thus",
      "minimum_should_match": 2
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example above creates a boolean query:</p>
</div>
<div class="paragraph">
<p><code>(title:this title:that title:thus)~2</code></p>
</div>
<div class="paragraph">
<p>that matches documents with at least two of the terms <code>this</code>, <code>that</code> or <code>thus</code>
in the single field <code>title</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="query-string-min-should-match-multi">How <code>minimum_should_match</code> works for multiple fields</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "query_string": {
      "fields": [
        "title",
        "content"
      ],
      "query": "this that thus",
      "minimum_should_match": 2
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example above creates a boolean query:</p>
</div>
<div class="paragraph">
<p><code>content:this content:that content:thus) | (title:this title:that title:thus</code></p>
</div>
<div class="paragraph">
<p>that matches documents with the disjunction max over the fields <code>title</code> and
<code>content</code>. Here the <code>minimum_should_match</code> parameter can&#8217;t be applied.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "query_string": {
      "fields": [
        "title",
        "content"
      ],
      "query": "this OR that OR thus",
      "minimum_should_match": 2
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adding explicit operators forces each term to be considered as a separate clause.</p>
</div>
<div class="paragraph">
<p>The example above creates a boolean query:</p>
</div>
<div class="paragraph">
<p><code>content:this | title:this) (content:that | title:that) (content:thus | title:thus~2</code></p>
</div>
<div class="paragraph">
<p>that matches documents with at least two of the three "should" clauses, each of
them made of the disjunction max over the fields for each term.</p>
</div>
</div>
<div class="sect4">
<h5 id="query-string-min-should-match-cross">How <code>minimum_should_match</code> works for cross-field searches</h5>
<div class="paragraph">
<p>A <code>cross_fields</code> value in the <code>type</code> field indicates fields with the same
analyzer are grouped together when the input is analyzed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "query_string": {
      "fields": [
        "title",
        "content"
      ],
      "query": "this OR that OR thus",
      "type": "cross_fields",
      "minimum_should_match": 2
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example above creates a boolean query:</p>
</div>
<div class="paragraph">
<p><code>(blended(terms:[field2:this, field1:this]) blended(terms:[field2:that, field1:that]) blended(terms:[field2:thus, field1:thus]))~2</code></p>
</div>
<div class="paragraph">
<p>that matches documents with at least two of the three per-term blended queries.</p>
</div>
</div>
<div class="sect4">
<h5 id="_allow_expensive_queries">Allow expensive queries</h5>
<div class="paragraph">
<p>Query string query can be internally be transformed to a <a href="term-level-queries.html#query-dsl-prefix-query"><code>prefix query</code></a> which means
that if the prefix queries are disabled as explained <a href="term-level-queries.html#prefix-query-allow-expensive-queries">here</a> the query will not be
executed and an exception will be thrown.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="query-dsl-simple-query-string-query">Simple query string query</h3>
<titleabbrev>Simple query string</titleabbrev>
<div class="paragraph">
<p>Returns documents based on a provided query string, using a parser with a
limited but fault-tolerant syntax.</p>
</div>
<div class="paragraph">
<p>This query uses a <a href="full-text-queries.html#simple-query-string-syntax">simple syntax</a> to parse and
split the provided query string into terms based on special operators. The query
then <a href="analysis.html">analyzes</a> each term independently before returning matching
documents.</p>
</div>
<div class="paragraph">
<p>While its syntax is more limited than the
<a href="full-text-queries.html#query-dsl-query-string-query"><code>query_string</code> query</a>, the <code>simple_query_string</code>
query does not return errors for invalid syntax. Instead, it ignores any invalid
parts of the query string.</p>
</div>
<div class="sect3">
<h4 id="simple-query-string-query-ex-request">Example request</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "simple_query_string" : {
        "query": "\"fried eggs\" +(eggplant | potato) -frittata",
        "fields": ["title^5", "body"],
        "default_operator": "and"
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="simple-query-string-top-level-params">Top-level parameters for <code>simple_query_string</code></h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>query</code></dt>
<dd>
<p>(Required, string) Query string you wish to parse and use for search. See <a href="full-text-queries.html#simple-query-string-syntax">Simple query string syntax</a>.</p>
</dd>
<dt class="hdlist1"><code>fields</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, array of strings) Array of fields you wish to search.</p>
</div>
<div class="paragraph">
<p>This field accepts wildcard expressions. You also can boost relevance scores for
matches to particular fields using a caret (<code>^</code>) notation. See
<a href="full-text-queries.html#simple-query-string-boost">Wildcards and per-field boosts in the <code>fields</code> parameter</a> for examples.</p>
</div>
<div class="paragraph">
<p>Defaults to the <code>index.query.default_field</code> index setting, which has a default
value of <code><strong></code>. The <code></strong></code> value extracts all fields that are eligible to term
queries and filters the metadata fields. All extracted fields are then combined
to build a query if no <code>prefix</code> is specified.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
There is a limit on the number of fields that can be queried at once.
It is defined by the <code>indices.query.bool.max_clause_count</code>
<a href="settings.html#search-settings">search setting</a>, which defaults to <code>1024</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>default_operator</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string) Default boolean logic used to interpret text in the query
string if no operators are specified. Valid values are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>OR</code> (Default)</dt>
<dd>
<p>For example, a query string of <code>capital of Hungary</code> is interpreted as <code>capital
OR of OR Hungary</code>.</p>
</dd>
<dt class="hdlist1"><code>AND</code></dt>
<dd>
<p>For example, a query string of <code>capital of Hungary</code> is interpreted as <code>capital
AND of AND Hungary</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>all_fields</code></dt>
<dd>
<p>(Optional, boolean) Deprecated. Set <code>fields</code> to <code>*</code> instead. If <code>true</code>,
search all searchable fields in the index&#8217;s field mapping.</p>
</dd>
<dt class="hdlist1"><code>analyze_wildcard</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, the query attempts to analyze wildcard terms in
the query string. Defaults to <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>analyzer</code></dt>
<dd>
<p>(Optional, string) <a href="analysis.html">Analyzer</a> used to convert text in the
query string into tokens. Defaults to the
<a href="configure-text-analysis.html#specify-index-time-analyzer">index-time analyzer</a> mapped for the
<code>default_field</code>. If no analyzer is mapped, the index&#8217;s default analyzer is used.</p>
</dd>
<dt class="hdlist1"><code>auto_generate_synonyms_phrase_query</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, <a href="full-text-queries.html#query-dsl-match-query-phrase">match phrase</a>
queries are automatically created for multi-term synonyms. Defaults to <code>true</code>.
See <a href="full-text-queries.html#simple-query-string-synonyms">Synonyms</a> for an example.</p>
</dd>
<dt class="hdlist1"><code>flags</code></dt>
<dd>
<p>(Optional, string) List of enabled operators for the
<a href="full-text-queries.html#simple-query-string-syntax">simple query string syntax</a>. Defaults to <code>ALL</code>
(all operators). See <a href="full-text-queries.html#supported-flags">Limit operators</a> for valid values.</p>
</dd>
<dt class="hdlist1"><code>fuzzy_max_expansions</code></dt>
<dd>
<p>(Optional, integer) Maximum number of terms to which the query expands for fuzzy
matching. Defaults to <code>50</code>.</p>
</dd>
<dt class="hdlist1"><code>fuzzy_prefix_length</code></dt>
<dd>
<p>(Optional, integer) Number of beginning characters left unchanged for fuzzy
matching. Defaults to <code>0</code>.</p>
</dd>
<dt class="hdlist1"><code>fuzzy_transpositions</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, edits for fuzzy matching include
transpositions of two adjacent characters (ab → ba). Defaults to <code>true</code>.</p>
</dd>
<dt class="hdlist1"><code>lenient</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, format-based errors, such as providing a text
value for a <a href="mapping-types.html#number">numeric</a> field, are ignored. Defaults to <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>minimum_should_match</code></dt>
<dd>
<p>(Optional, string) Minimum number of clauses that must match for a document to
be returned. See the <a href="query-dsl-minimum-should-match.html"><code>minimum_should_match</code>
parameter</a> for valid values and more information.</p>
</dd>
<dt class="hdlist1"><code>quote_field_suffix</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string) Suffix appended to quoted text in the query string.</p>
</div>
<div class="paragraph">
<p>You can use this suffix to use a different analysis method for exact matches.
See <a href="recipes.html#mixing-exact-search-with-stemming">Mixing exact search with stemming</a>.</p>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="simple-query-string-query-notes">Notes</h4>
<div class="sect4">
<h5 id="simple-query-string-syntax">Simple query string syntax</h5>
<div class="paragraph">
<p>The <code>simple_query_string</code> query supports the following operators:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>+</code> signifies AND operation</p>
</li>
<li>
<p><code>|</code> signifies OR operation</p>
</li>
<li>
<p><code>-</code> negates a single token</p>
</li>
<li>
<p><code>"</code> wraps a number of tokens to signify a phrase for searching</p>
</li>
<li>
<p><code>*</code> at the end of a term signifies a prefix query</p>
</li>
<li>
<p><code>(</code> and <code>)</code> signify precedence</p>
</li>
<li>
<p><code>~N</code> after a word signifies edit distance (fuzziness)</p>
</li>
<li>
<p><code>~N</code> after a phrase signifies slop amount</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To use one of these characters literally, escape it with a preceding backslash
(<code>\</code>).</p>
</div>
<div class="paragraph">
<p>The behavior of these operators may differ depending on the <code>default_operator</code>
value. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "simple_query_string": {
      "fields": [ "content" ],
      "query": "foo bar -baz"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This search is intended to only return documents containing <code>foo</code> or <code>bar</code> that
also do <strong>not</strong> contain <code>baz</code>. However because of a <code>default_operator</code> of <code>OR</code>,
this search actually returns documents that contain <code>foo</code> or <code>bar</code> and any
documents that don&#8217;t contain <code>baz</code>. To return documents as intended, change the
query string to <code>foo bar +-baz</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="supported-flags">Limit operators</h5>
<div class="paragraph">
<p>You can use the <code>flags</code> parameter to limit the supported operators for the
simple query string syntax.</p>
</div>
<div class="paragraph">
<p>To explicitly enable only specific operators, use a <code>|</code> separator. For example,
a <code>flags</code> value of <code>OR|AND|PREFIX</code> disables all operators except <code>OR</code>, <code>AND</code>,
and <code>PREFIX</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "simple_query_string": {
      "query": "foo | bar + baz*",
      "flags": "OR|AND|PREFIX"
    }
  }
}</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="supported-flags-values">Valid values</h6>
<div class="paragraph">
<p>The available flags are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ALL</code> (Default)</dt>
<dd>
<p>Enables all optional operators.</p>
</dd>
<dt class="hdlist1"><code>AND</code></dt>
<dd>
<p>Enables the <code>+</code> AND operator.</p>
</dd>
<dt class="hdlist1"><code>ESCAPE</code></dt>
<dd>
<p>Enables <code>\</code> as an escape character.</p>
</dd>
<dt class="hdlist1"><code>FUZZY</code></dt>
<dd>
<p>Enables the <code>~N</code> operator after a word, where <code>N</code> is an integer denoting the
allowed edit distance for matching. See <a href="api-conventions.html#fuzziness">Fuzziness</a>.</p>
</dd>
<dt class="hdlist1"><code>NEAR</code></dt>
<dd>
<p>Enables the <code>~N</code> operator, after a phrase where <code>N</code> is the maximum number of
positions allowed between matching tokens. Synonymous to <code>SLOP</code>.</p>
</dd>
<dt class="hdlist1"><code>NONE</code></dt>
<dd>
<p>Disables all operators.</p>
</dd>
<dt class="hdlist1"><code>NOT</code></dt>
<dd>
<p>Enables the <code>-</code> NOT operator.</p>
</dd>
<dt class="hdlist1"><code>OR</code></dt>
<dd>
<p>Enables the <code>\|</code> OR operator.</p>
</dd>
<dt class="hdlist1"><code>PHRASE</code></dt>
<dd>
<p>Enables the <code>"</code> quotes operator used to search for phrases.</p>
</dd>
<dt class="hdlist1"><code>PRECEDENCE</code></dt>
<dd>
<p>Enables the <code>(</code> and <code>)</code> operators to control operator precedence.</p>
</dd>
<dt class="hdlist1"><code>PREFIX</code></dt>
<dd>
<p>Enables the <code>*</code> prefix operator.</p>
</dd>
<dt class="hdlist1"><code>SLOP</code></dt>
<dd>
<p>Enables the <code>~N</code> operator, after a phrase where <code>N</code> is maximum number of
positions allowed between matching tokens. Synonymous to <code>NEAR</code>.</p>
</dd>
<dt class="hdlist1"><code>WHITESPACE</code></dt>
<dd>
<p>Enables whitespace as split characters.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect4">
<h5 id="simple-query-string-boost">Wildcards and per-field boosts in the <code>fields</code> parameter</h5>
<div class="paragraph">
<p>Fields can be specified with wildcards, eg:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "simple_query_string" : {
      "query":    "Will Smith",
      "fields": [ "title", "*_name" ] <b class="conum">(1)</b>
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Query the <code>title</code>, <code>first_name</code> and <code>last_name</code> fields.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Individual fields can be boosted with the caret (<code>^</code>) notation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
  "query": {
    "simple_query_string" : {
      "query" : "this is a test",
      "fields" : [ "subject^3", "message" ] <b class="conum">(1)</b>
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>subject</code> field is three times as important as the <code>message</code> field.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="simple-query-string-synonyms">Synonyms</h5>
<div class="paragraph">
<p>The <code>simple_query_string</code> query supports multi-terms synonym expansion with the <a href="analysis-tokenfilters.html#analysis-synonym-graph-tokenfilter">synonym_graph</a> token filter. When this filter is used, the parser creates a phrase query for each multi-terms synonyms.
For example, the following synonym: <code>"ny, new york"</code> would produce:</p>
</div>
<div class="paragraph">
<p><code>(ny OR ("new york"))</code></p>
</div>
<div class="paragraph">
<p>It is also possible to match multi terms synonyms with conjunctions instead:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_search
{
   "query": {
       "simple_query_string" : {
           "query" : "ny city",
           "auto_generate_synonyms_phrase_query" : false
       }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example above creates a boolean query:</p>
</div>
<div class="paragraph">
<p><code>(ny OR (new AND york)) city)</code></p>
</div>
<div class="paragraph">
<p>that matches documents with the term <code>ny</code> or the conjunction <code>new AND york</code>.
By default the parameter <code>auto_generate_synonyms_phrase_query</code> is set to <code>true</code>.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph nav-footer">
<p>← Previous: <a href="compound-queries.html">Compound queries</a> | ↑ Up: <a href="query-dsl.html">Query DSL</a> | ⌂ Home: <a href="index.html">OpenSearch Reference</a> | Next: <a href="geo-queries.html">Geo queries</a> →</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-04-12 14:08:20 -0700
</div>
</div>
</body>
</html>