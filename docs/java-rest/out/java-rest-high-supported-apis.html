<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<title>Java REST Client</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:50%;border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<style>.toc-current{font-weight: bold;} .toc-root{font-family: "Open Sans","DejaVu Sans",sans-serif;
                       font-size: 0.9em;} #content{display: flex; flex-direction: column; flex: 1 1 auto;}
             .nav-footer{text-align: center; margin-top: auto;}
             .nav-footer > p > a {white-space: nowrap;}</style>
</head>
<body id="java-rest-high-supported-apis" class="book toc2 toc-left">
<div id="header">
<h1>Java REST Client</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<p><span class="toc-root"><a href="index.html">Java REST Client</a></span></p><ul class="sectlevel1">
<li><a href="java-rest-overview.html">Overview</a>
</li>
<li><a href="java-rest-low.html">Java Low Level REST Client</a>
</li>
<li><a href="java-rest-high.html">Java High Level REST Client</a>
<ul class="sectlevel1">
<li><a href="java-rest-high-getting-started.html">Getting started</a>
</li>
<li><a href="java-rest-high-supported-apis.html"><span class="toc-current">Document APIs</span></a>
<ul class="sectlevel2">
<li><a href="java-rest-high-supported-apis.html#java-rest-high-document-index">Index API</a>
</li>
<li><a href="java-rest-high-supported-apis.html#java-rest-high-document-get">Get API</a>
</li>
<li><a href="java-rest-high-supported-apis.html#java-rest-high-document-get-source">Get Source API</a>
</li>
<li><a href="java-rest-high-supported-apis.html#java-rest-high-document-exists">Exists API</a>
</li>
<li><a href="java-rest-high-supported-apis.html#java-rest-high-document-delete">Delete API</a>
</li>
<li><a href="java-rest-high-supported-apis.html#java-rest-high-document-update">Update API</a>
</li>
<li><a href="java-rest-high-supported-apis.html#java-rest-high-document-term-vectors">Term Vectors API</a>
</li>
<li><a href="java-rest-high-supported-apis.html#java-rest-high-document-bulk">Bulk API</a>
</li>
<li><a href="java-rest-high-supported-apis.html#java-rest-high-document-multi-get">Multi-Get API</a>
</li>
<li><a href="java-rest-high-supported-apis.html#java-rest-high-document-reindex">Reindex API</a>
</li>
<li><a href="java-rest-high-supported-apis.html#java-rest-high-document-update-by-query">Update By Query API</a>
</li>
<li><a href="java-rest-high-supported-apis.html#java-rest-high-document-delete-by-query">Delete By Query API</a>
</li>
<li><a href="java-rest-high-supported-apis.html#java-rest-high-document-rethrottle">Rethrottle API</a>
</li>
<li><a href="java-rest-high-supported-apis.html#java-rest-high-document-multi-term-vectors">Multi Term Vectors API</a>
</li>
</ul>
</li>
<li><a href="_search_apis.html">Search APIs</a>
</li>
<li><a href="_miscellaneous_apis.html">Miscellaneous APIs</a>
</li>
<li><a href="_index_apis.html">Index APIs</a>
</li>
<li><a href="_cluster_apis.html">Cluster APIs</a>
</li>
<li><a href="_ingest_apis.html">Ingest APIs</a>
</li>
<li><a href="_snapshot_apis.html">Snapshot APIs</a>
</li>
<li><a href="_tasks_apis.html">Tasks APIs</a>
</li>
<li><a href="_script_apis.html">Script APIs</a>
</li>
<li><a href="java-rest-high-java-builders.html">Using Java Builders</a>
</li>
<li><a href="java-rest-high-level-migration.html">Migration Guide</a>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="java-rest-high-supported-apis">Document APIs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Java High Level REST Client supports the following Document APIs:</p>
</div>
<div id="single-doc" class="dlist">
<dl>
<dt class="hdlist1">Single document APIs</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="java-rest-high-supported-apis.html#java-rest-high-document-index">Index API</a></p>
</li>
<li>
<p><a href="java-rest-high-supported-apis.html#java-rest-high-document-get">Get API</a></p>
</li>
<li>
<p><a href="java-rest-high-supported-apis.html#java-rest-high-document-get-source">Get Source API</a></p>
</li>
<li>
<p><a href="java-rest-high-supported-apis.html#java-rest-high-document-exists">Exists API</a></p>
</li>
<li>
<p><a href="java-rest-high-supported-apis.html#java-rest-high-document-delete">Delete API</a></p>
</li>
<li>
<p><a href="java-rest-high-supported-apis.html#java-rest-high-document-update">Update API</a></p>
</li>
<li>
<p><a href="java-rest-high-supported-apis.html#java-rest-high-document-term-vectors">Term Vectors API</a></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div id="multi-doc" class="dlist">
<dl>
<dt class="hdlist1">Multi-document APIs</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><a href="java-rest-high-supported-apis.html#java-rest-high-document-bulk">Bulk API</a></p>
</li>
<li>
<p><a href="java-rest-high-supported-apis.html#java-rest-high-document-multi-get">Multi-Get API</a></p>
</li>
<li>
<p><a href="java-rest-high-supported-apis.html#java-rest-high-document-reindex">Reindex API</a></p>
</li>
<li>
<p><a href="java-rest-high-supported-apis.html#java-rest-high-document-update-by-query">Update By Query API</a></p>
</li>
<li>
<p><a href="java-rest-high-supported-apis.html#java-rest-high-document-delete-by-query">Delete By Query API</a></p>
</li>
<li>
<p><a href="java-rest-high-supported-apis.html#java-rest-high-document-rethrottle">Rethrottle API</a></p>
</li>
<li>
<p><a href="java-rest-high-supported-apis.html#java-rest-high-document-multi-term-vectors">Multi Term Vectors API</a></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="java-rest-high-document-index">Index API</h3>
<div class="sect3">
<h4 id="java-rest-high-document-index-request">Index Request</h4>
<div class="paragraph">
<p>An <code>IndexRequest</code> requires the following arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            IndexRequest request = new IndexRequest("posts"); // <b class="conum">(1)</b>
            request.id("1"); // <b class="conum">(2)</b>
            String jsonString = "{" +
                    "\"user\":\"kimchy\"," +
                    "\"postDate\":\"2013-01-30\"," +
                    "\"message\":\"trying out OpenSearch\"" +
                    "}";
            request.source(jsonString, XContentType.JSON); // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Index</p>
</li>
<li>
<p>Document id for the request</p>
</li>
<li>
<p>Document source provided as a <code>String</code></p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_providing_the_document_source">Providing the document source</h4>
<div class="paragraph">
<p>The document source can be provided in different ways in addition to the
<code>String</code> example shown above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            Map&lt;String, Object&gt; jsonMap = new HashMap&lt;&gt;();
            jsonMap.put("user", "kimchy");
            jsonMap.put("postDate", new Date());
            jsonMap.put("message", "trying out OpenSearch");
            IndexRequest indexRequest = new IndexRequest("posts")
                .id("1").source(jsonMap); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Document source provided as a <code>Map</code> which gets automatically converted
to JSON format</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            XContentBuilder builder = XContentFactory.jsonBuilder();
            builder.startObject();
            {
                builder.field("user", "kimchy");
                builder.timeField("postDate", new Date());
                builder.field("message", "trying out OpenSearch");
            }
            builder.endObject();
            IndexRequest indexRequest = new IndexRequest("posts")
                .id("1").source(builder);  // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Document source provided as an <code>XContentBuilder</code> object, the OpenSearch
built-in helpers to generate JSON content</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            IndexRequest indexRequest = new IndexRequest("posts")
                .id("1")
                .source("user", "kimchy",
                    "postDate", new Date(),
                    "message", "trying out OpenSearch"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Document source provided as <code>Object</code> key-pairs, which gets converted to
JSON format</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.routing("routing"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Routing value</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.timeout(TimeValue.timeValueSeconds(1)); // <b class="conum">(1)</b>
            request.timeout("1s"); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to wait for primary shard to become available as a <code>TimeValue</code></p>
</li>
<li>
<p>Timeout to wait for primary shard to become available as a <code>String</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setRefreshPolicy(WriteRequest.RefreshPolicy.WAIT_UNTIL); // <b class="conum">(1)</b>
            request.setRefreshPolicy("wait_for");                            // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Refresh policy as a <code>WriteRequest.RefreshPolicy</code> instance</p>
</li>
<li>
<p>Refresh policy as a <code>String</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.version(2); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Version</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.versionType(VersionType.EXTERNAL); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Version type</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.opType(DocWriteRequest.OpType.CREATE); // <b class="conum">(1)</b>
            request.opType("create"); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Operation type provided as an <code>DocWriteRequest.OpType</code> value</p>
</li>
<li>
<p>Operation type provided as a <code>String</code>: can be <code>create</code> or <code>index</code> (default)</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setPipeline("pipeline"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The name of the ingest pipeline to be executed before indexing the document</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-index-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>IndexRequest</code> in the following manner, the client waits
for the <code>IndexResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            IndexResponse indexResponse = client.index(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-index-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>IndexRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous index method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.indexAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>IndexRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>index</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            listener = new ActionListener&lt;IndexResponse&gt;() {
                @Override
                public void onResponse(IndexResponse indexResponse) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>IndexRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-index-response">Index Response</h4>
<div class="paragraph">
<p>The returned <code>IndexResponse</code> allows to retrieve information about the executed
 operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            String index = indexResponse.getIndex();
            String id = indexResponse.getId();
            if (indexResponse.getResult() == DocWriteResponse.Result.CREATED) {
                // <b class="conum">(1)</b>
            } else if (indexResponse.getResult() == DocWriteResponse.Result.UPDATED) {
                // <b class="conum">(2)</b>
            }
            ReplicationResponse.ShardInfo shardInfo = indexResponse.getShardInfo();
            if (shardInfo.getTotal() != shardInfo.getSuccessful()) {
                // <b class="conum">(3)</b>
            }
            if (shardInfo.getFailed() &gt; 0) {
                for (ReplicationResponse.ShardInfo.Failure failure :
                        shardInfo.getFailures()) {
                    String reason = failure.reason(); // <b class="conum">(4)</b>
                }
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Handle (if needed) the case where the document was created for the first
time</p>
</li>
<li>
<p>Handle (if needed) the case where the document was rewritten as it was
already existing</p>
</li>
<li>
<p>Handle the situation where number of successful shards is less than
total shards</p>
</li>
<li>
<p>Handle the potential failures</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If there is a version conflict, an <code>OpenSearchException</code> will
be thrown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            IndexRequest request = new IndexRequest("posts")
                .id("1")
                .source("field", "value")
                .setIfSeqNo(10L)
                .setIfPrimaryTerm(20);
            try {
                IndexResponse response = client.index(request, RequestOptions.DEFAULT);
            } catch(OpenSearchException e) {
                if (e.status() == RestStatus.CONFLICT) {
                    // <b class="conum">(1)</b>
                }
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The raised exception indicates that a version conflict error was returned</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Same will happen in case <code>opType</code> was set to <code>create</code> and a document with
same index and id already existed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            IndexRequest request = new IndexRequest("posts")
                .id("1")
                .source("field", "value")
                .opType(DocWriteRequest.OpType.CREATE);
            try {
                IndexResponse response = client.index(request, RequestOptions.DEFAULT);
            } catch(OpenSearchException e) {
                if (e.status() == RestStatus.CONFLICT) {
                    // <b class="conum">(1)</b>
                }
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The raised exception indicates that a version conflict error was returned</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-document-get">Get API</h3>
<div class="sect3">
<h4 id="java-rest-high-document-get-request">Get Request</h4>
<div class="paragraph">
<p>A <code>GetRequest</code> requires the following arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            GetRequest getRequest = new GetRequest(
                    "posts", // <b class="conum">(1)</b>
                    "1");   // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Index</p>
</li>
<li>
<p>Document id</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-get-request-optional-arguments">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.fetchSourceContext(FetchSourceContext.DO_NOT_FETCH_SOURCE); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Disable source retrieval, enabled by default</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            String[] includes = new String[]{"message", "*Date"};
            String[] excludes = Strings.EMPTY_ARRAY;
            FetchSourceContext fetchSourceContext =
                    new FetchSourceContext(true, includes, excludes);
            request.fetchSourceContext(fetchSourceContext); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Configure source inclusion for specific fields</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            String[] includes = Strings.EMPTY_ARRAY;
            String[] excludes = new String[]{"message"};
            FetchSourceContext fetchSourceContext =
                    new FetchSourceContext(true, includes, excludes);
            request.fetchSourceContext(fetchSourceContext); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Configure source exclusion for specific fields</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.storedFields("message"); // <b class="conum">(1)</b>
            GetResponse getResponse = client.get(request, RequestOptions.DEFAULT);
            String message = getResponse.getField("message").getValue(); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Configure retrieval for specific stored fields (requires fields to be
stored separately in the mappings)</p>
</li>
<li>
<p>Retrieve the <code>message</code> stored field (requires the field to be stored
separately in the mappings)</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.routing("routing"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Routing value</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.preference("preference"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Preference value</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.realtime(false); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set realtime flag to <code>false</code> (<code>true</code> by default)</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.refresh(true); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Perform a refresh before retrieving the document (<code>false</code> by default)</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.version(2); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Version</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.versionType(VersionType.EXTERNAL); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Version type</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-get-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>GetRequest</code> in the following manner, the client waits
for the <code>GetResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            GetResponse getResponse = client.get(getRequest, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-get-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>GetRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous get method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.getAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>GetRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>get</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ActionListener&lt;GetResponse&gt; listener = new ActionListener&lt;GetResponse&gt;() {
                @Override
                public void onResponse(GetResponse getResponse) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>GetRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-get-response">Get Response</h4>
<div class="paragraph">
<p>The returned <code>GetResponse</code> allows to retrieve the requested document along with
its metadata and eventually stored fields.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            String index = getResponse.getIndex();
            String id = getResponse.getId();
            if (getResponse.isExists()) {
                long version = getResponse.getVersion();
                String sourceAsString = getResponse.getSourceAsString();        // <b class="conum">(1)</b>
                Map&lt;String, Object&gt; sourceAsMap = getResponse.getSourceAsMap(); // <b class="conum">(2)</b>
                byte[] sourceAsBytes = getResponse.getSourceAsBytes();          // <b class="conum">(3)</b>
            } else {
                // <b class="conum">(4)</b>
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Retrieve the document as a <code>String</code></p>
</li>
<li>
<p>Retrieve the document as a <code>Map&lt;String, Object&gt;</code></p>
</li>
<li>
<p>Retrieve the document as a <code>byte[]</code></p>
</li>
<li>
<p>Handle the scenario where the document was not found. Note that although
the returned response has <code>404</code> status code, a valid <code>GetResponse</code> is
returned rather than an exception thrown. Such response does not hold any
source document and its <code>isExists</code> method returns <code>false</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When a get request is performed against an index that does not exist, the
response has <code>404</code> status code, an <code>OpenSearchException</code> gets thrown
which needs to be handled as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            GetRequest request = new GetRequest("does_not_exist", "1");
            try {
                GetResponse getResponse = client.get(request, RequestOptions.DEFAULT);
            } catch (OpenSearchException e) {
                if (e.status() == RestStatus.NOT_FOUND) {
                    // <b class="conum">(1)</b>
                }
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Handle the exception thrown because the index does not exist</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In case a specific document version has been requested, and the existing
document has a different version number, a version conflict is raised:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            try {
                GetRequest request = new GetRequest("posts", "1").version(2);
                GetResponse getResponse = client.get(request, RequestOptions.DEFAULT);
            } catch (OpenSearchException exception) {
                if (exception.status() == RestStatus.CONFLICT) {
                    // <b class="conum">(1)</b>
                }
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The raised exception indicates that a version conflict error was returned</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-document-get-source">Get Source API</h3>
<div class="paragraph">
<p>This API helps to get only the <code>_source</code> field of a document.</p>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-get-source-request">Get Source Request</h4>
<div class="paragraph">
<p>A <code>GetSourceRequest</code> requires the following arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        GetSourceRequest getSourceRequest = new GetSourceRequest(
            "posts", // <b class="conum">(1)</b>
            "1");   // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Index</p>
</li>
<li>
<p>Document id</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-get-source-request-optional">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        String[] includes = Strings.EMPTY_ARRAY;  // <b class="conum">(2)</b>
        String[] excludes = new String[]{"postDate"};
        getSourceRequest.fetchSourceContext(
            new FetchSourceContext(true, includes, excludes)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>FetchSourceContext</code> 's first argument <code>fetchSource</code> must be <code>true</code>, otherwise
<code>OpenSearchException</code> get thrown</p>
</li>
<li>
<p>Arguments of the context <code>excludes</code> and <code>includes</code> are optional
(see examples in Get API documentation)</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        getSourceRequest.routing("routing"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Routing value</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        getSourceRequest.preference("preference"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Preference value</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        getSourceRequest.realtime(false); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set realtime flag to <code>false</code> (<code>true</code> by default)</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        getSourceRequest.refresh(true); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Perform a refresh before retrieving the document (<code>false</code> by default)</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-get-source-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>GetSourceRequest</code> in the following manner, the client waits
for the <code>GetSourceResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            GetSourceResponse response =
                client.getSource(getSourceRequest, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-get-source-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>GetSourceRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous get-source method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.getSourceAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>GetSourceRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>get-source</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ActionListener&lt;GetSourceResponse&gt; listener =
                new ActionListener&lt;GetSourceResponse&gt;() {
                    @Override
                    public void onResponse(GetSourceResponse getResponse) {
                        // <b class="conum">(1)</b>
                    }

                    @Override
                    public void onFailure(Exception e) {
                        // <b class="conum">(2)</b>
                    }
                };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>GetSourceRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-get-source-response">Get Source Response</h4>
<div class="paragraph">
<p>The returned <code>GetSourceResponse</code> contains the field <code>source</code> that represents the
source of a document as a map.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            Map&lt;String, Object&gt; source = response.getSource();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-document-exists">Exists API</h3>
<div class="paragraph">
<p>The exists API returns <code>true</code> if a document exists, and <code>false</code> otherwise.</p>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-exists-request">Exists Request</h4>
<div class="paragraph">
<p>It uses <code>GetRequest</code> just like the <a href="java-rest-high-supported-apis.html#java-rest-high-document-get">Get API</a>.
All of its <a href="java-rest-high-supported-apis.html#java-rest-high-document-get-request-optional-arguments">optional arguments</a>
are supported. Since <code>exists()</code> only returns <code>true</code> or <code>false</code>, we recommend
turning off fetching <code>_source</code> and any stored fields so the request is
slightly lighter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        GetRequest getRequest = new GetRequest(
            "posts", // <b class="conum">(1)</b>
            "1");    // <b class="conum">(2)</b>
        getRequest.fetchSourceContext(new FetchSourceContext(false)); // <b class="conum">(3)</b>
        getRequest.storedFields("_none_");                            // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Index</p>
</li>
<li>
<p>Document id</p>
</li>
<li>
<p>Disable fetching <code>_source</code>.</p>
</li>
<li>
<p>Disable fetching stored fields.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-exists-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>GetRequest</code> in the following manner, the client waits
for the <code>boolean</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            boolean exists = client.exists(getRequest, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-exists-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>GetRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous exists method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.existsAsync(getRequest, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>GetRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>exists</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ActionListener&lt;Boolean&gt; listener = new ActionListener&lt;Boolean&gt;() {
                @Override
                public void onResponse(Boolean exists) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>GetRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_source_exists_request">Source exists request</h4>
<div class="paragraph">
<p>A variant of the exists request is <code>existsSource</code> method which has the additional check
that the document in question has stored the <code>source</code>. If the mapping for the index has opted
to remove support for storing JSON source in documents then this method will return false
for documents in this index.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-document-delete">Delete API</h3>
<div class="sect3">
<h4 id="java-rest-high-document-delete-request">Delete Request</h4>
<div class="paragraph">
<p>A <code>DeleteRequest</code> has two required arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            DeleteRequest request = new DeleteRequest(
                    "posts",    // <b class="conum">(1)</b>
                    "1");       // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Index</p>
</li>
<li>
<p>Document id</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_2">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.routing("routing"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Routing value</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.timeout(TimeValue.timeValueMinutes(2)); // <b class="conum">(1)</b>
            request.timeout("2m"); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to wait for primary shard to become available as a <code>TimeValue</code></p>
</li>
<li>
<p>Timeout to wait for primary shard to become available as a <code>String</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setRefreshPolicy(WriteRequest.RefreshPolicy.WAIT_UNTIL); // <b class="conum">(1)</b>
            request.setRefreshPolicy("wait_for");                            // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Refresh policy as a <code>WriteRequest.RefreshPolicy</code> instance</p>
</li>
<li>
<p>Refresh policy as a <code>String</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.version(2); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Version</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.versionType(VersionType.EXTERNAL); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Version type</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-delete-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>DeleteRequest</code> in the following manner, the client waits
for the <code>DeleteResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            DeleteResponse deleteResponse = client.delete(
                    request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-delete-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>DeleteRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous delete method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.deleteAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>DeleteRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>delete</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            listener = new ActionListener&lt;DeleteResponse&gt;() {
                @Override
                public void onResponse(DeleteResponse deleteResponse) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>DeleteRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-delete-response">Delete Response</h4>
<div class="paragraph">
<p>The returned <code>DeleteResponse</code> allows to retrieve information about the executed
 operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            String index = deleteResponse.getIndex();
            String id = deleteResponse.getId();
            long version = deleteResponse.getVersion();
            ReplicationResponse.ShardInfo shardInfo = deleteResponse.getShardInfo();
            if (shardInfo.getTotal() != shardInfo.getSuccessful()) {
                // <b class="conum">(1)</b>
            }
            if (shardInfo.getFailed() &gt; 0) {
                for (ReplicationResponse.ShardInfo.Failure failure :
                        shardInfo.getFailures()) {
                    String reason = failure.reason(); // <b class="conum">(2)</b>
                }
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Handle the situation where number of successful shards is less than
total shards</p>
</li>
<li>
<p>Handle the potential failures</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>It is also possible to check whether the document was found or not:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            DeleteRequest request = new DeleteRequest("posts", "does_not_exist");
            DeleteResponse deleteResponse = client.delete(
                    request, RequestOptions.DEFAULT);
            if (deleteResponse.getResult() == DocWriteResponse.Result.NOT_FOUND) {
                // <b class="conum">(1)</b>
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Do something if the document to be deleted was not found</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If there is a version conflict, an <code>OpenSearchException</code> will
be thrown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            try {
                DeleteResponse deleteResponse = client.delete(
                    new DeleteRequest("posts", "1").setIfSeqNo(100).setIfPrimaryTerm(2),
                        RequestOptions.DEFAULT);
            } catch (OpenSearchException exception) {
                if (exception.status() == RestStatus.CONFLICT) {
                    // <b class="conum">(1)</b>
                }
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The raised exception indicates that a version conflict error was returned</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-document-update">Update API</h3>
<div class="sect3">
<h4 id="java-rest-high-document-update-request">Update Request</h4>
<div class="paragraph">
<p>An <code>UpdateRequest</code> requires the following arguments:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            UpdateRequest request = new UpdateRequest(
                    "posts", // <b class="conum">(1)</b>
                    "1");   // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Index</p>
</li>
<li>
<p>Document id</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The Update API allows to update an existing document by using a script
or by passing a partial document.</p>
</div>
</div>
<div class="sect3">
<h4 id="_updates_with_a_script">Updates with a script</h4>
<div class="paragraph">
<p>The script can be provided as an inline script:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            Map&lt;String, Object&gt; parameters = singletonMap("count", 4); // <b class="conum">(1)</b>

            Script inline = new Script(ScriptType.INLINE, "painless",
                    "ctx._source.field += params.count", parameters);  // <b class="conum">(2)</b>
            request.script(inline);  // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Script parameters provided as a <code>Map</code> of objects</p>
</li>
<li>
<p>Create an inline script using the <code>painless</code> language and the previous parameters</p>
</li>
<li>
<p>Sets the script to the update request</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Or as a stored script:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            Script stored = new Script(
                    ScriptType.STORED, null, "increment-field", parameters);  // <b class="conum">(1)</b>
            request.script(stored);  // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Reference to a script stored under the name <code>increment-field</code> in the <code>painless</code> language</p>
</li>
<li>
<p>Sets the script in the update request</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_updates_with_a_partial_document">Updates with a partial document</h4>
<div class="paragraph">
<p>When using updates with a partial document, the partial document will be merged with the
existing document.</p>
</div>
<div class="paragraph">
<p>The partial document can be provided in different ways:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            UpdateRequest request = new UpdateRequest("posts", "1");
            String jsonString = "{" +
                    "\"updated\":\"2017-01-01\"," +
                    "\"reason\":\"daily update\"" +
                    "}";
            request.doc(jsonString, XContentType.JSON); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Partial document source provided as a <code>String</code> in JSON format</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            Map&lt;String, Object&gt; jsonMap = new HashMap&lt;&gt;();
            jsonMap.put("updated", new Date());
            jsonMap.put("reason", "daily update");
            UpdateRequest request = new UpdateRequest("posts", "1")
                    .doc(jsonMap); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Partial document source provided as a <code>Map</code> which gets automatically converted
to JSON format</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            XContentBuilder builder = XContentFactory.jsonBuilder();
            builder.startObject();
            {
                builder.timeField("updated", new Date());
                builder.field("reason", "daily update");
            }
            builder.endObject();
            UpdateRequest request = new UpdateRequest("posts", "1")
                    .doc(builder);  // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Partial document source provided as an <code>XContentBuilder</code> object, the OpenSearch
built-in helpers to generate JSON content</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            UpdateRequest request = new UpdateRequest("posts", "1")
                    .doc("updated", new Date(),
                         "reason", "daily update"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Partial document source provided as <code>Object</code> key-pairs, which gets converted to
JSON format</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_upserts">Upserts</h4>
<div class="paragraph">
<p>If the document does not already exist, it is possible to define some content that
will be inserted as a new document using the <code>upsert</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            String jsonString = "{\"created\":\"2017-01-01\"}";
            request.upsert(jsonString, XContentType.JSON);  // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Upsert document source provided as a <code>String</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Similarly to the partial document updates, the content of the <code>upsert</code> document
can be defined using methods that accept <code>String</code>, <code>Map</code>, <code>XContentBuilder</code> or
<code>Object</code> key-pairs.</p>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_3">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.routing("routing"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Routing value</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.timeout(TimeValue.timeValueSeconds(1)); // <b class="conum">(1)</b>
            request.timeout("1s"); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to wait for primary shard to become available as a <code>TimeValue</code></p>
</li>
<li>
<p>Timeout to wait for primary shard to become available as a <code>String</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setRefreshPolicy(WriteRequest.RefreshPolicy.WAIT_UNTIL); // <b class="conum">(1)</b>
            request.setRefreshPolicy("wait_for");                            // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Refresh policy as a <code>WriteRequest.RefreshPolicy</code> instance</p>
</li>
<li>
<p>Refresh policy as a <code>String</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.retryOnConflict(3); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>How many times to retry the update operation if the document to update has
been changed by another operation between the get and indexing phases of the
update operation</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.fetchSource(true); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Enable source retrieval, disabled by default</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            String[] includes = new String[]{"updated", "r*"};
            String[] excludes = Strings.EMPTY_ARRAY;
            request.fetchSource(
                    new FetchSourceContext(true, includes, excludes)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Configure source inclusion for specific fields</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            String[] includes = Strings.EMPTY_ARRAY;
            String[] excludes = new String[]{"updated"};
            request.fetchSource(
                    new FetchSourceContext(true, includes, excludes)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Configure source exclusion for specific fields</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setIfSeqNo(2L); // <b class="conum">(1)</b>
            request.setIfPrimaryTerm(1L); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>ifSeqNo</p>
</li>
<li>
<p>ifPrimaryTerm</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.detectNoop(false); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Disable the noop detection</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.scriptedUpsert(true); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Indicate that the script must run regardless of whether the document exists or not,
ie the script takes care of creating the document if it does not already exist.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.docAsUpsert(true); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Indicate that the partial document must be used as the upsert document if it
does not exist yet.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.waitForActiveShards(2); // <b class="conum">(1)</b>
            request.waitForActiveShards(ActiveShardCount.ALL); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Sets the number of shard copies that must be active before proceeding with
the update operation.</p>
</li>
<li>
<p>Number of shard copies provided as a <code>ActiveShardCount</code>: can be <code>ActiveShardCount.ALL</code>,
<code>ActiveShardCount.ONE</code> or <code>ActiveShardCount.DEFAULT</code> (default)</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-update-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>UpdateRequest</code> in the following manner, the client waits
for the <code>UpdateResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            UpdateResponse updateResponse = client.update(
                    request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-update-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>UpdateRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous update method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.updateAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>UpdateRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>update</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            listener = new ActionListener&lt;UpdateResponse&gt;() {
                @Override
                public void onResponse(UpdateResponse updateResponse) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>UpdateRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-update-response">Update Response</h4>
<div class="paragraph">
<p>The returned <code>UpdateResponse</code> allows to retrieve information about the executed
operation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            String index = updateResponse.getIndex();
            String id = updateResponse.getId();
            long version = updateResponse.getVersion();
            if (updateResponse.getResult() == DocWriteResponse.Result.CREATED) {
                // <b class="conum">(1)</b>
            } else if (updateResponse.getResult() == DocWriteResponse.Result.UPDATED) {
                // <b class="conum">(2)</b>
            } else if (updateResponse.getResult() == DocWriteResponse.Result.DELETED) {
                // <b class="conum">(3)</b>
            } else if (updateResponse.getResult() == DocWriteResponse.Result.NOOP) {
                // <b class="conum">(4)</b>
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Handle the case where the document was created for the first time (upsert)</p>
</li>
<li>
<p>Handle the case where the document was updated</p>
</li>
<li>
<p>Handle the case where the document was deleted</p>
</li>
<li>
<p>Handle the case where the document was not impacted by the update,
ie no operation (noop) was executed on the document</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When the source retrieval is enabled in the <code>UpdateRequest</code>
through the fetchSource method, the response contains the
source of the updated document:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            GetResult result = updateResponse.getGetResult(); // <b class="conum">(1)</b>
            if (result.isExists()) {
                String sourceAsString = result.sourceAsString(); // <b class="conum">(2)</b>
                Map&lt;String, Object&gt; sourceAsMap = result.sourceAsMap(); // <b class="conum">(3)</b>
                byte[] sourceAsBytes = result.source(); // <b class="conum">(4)</b>
            } else {
                // <b class="conum">(5)</b>
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Retrieve the updated document as a <code>GetResult</code></p>
</li>
<li>
<p>Retrieve the source of the updated document as a <code>String</code></p>
</li>
<li>
<p>Retrieve the source of the updated document as a <code>Map&lt;String, Object&gt;</code></p>
</li>
<li>
<p>Retrieve the source of the updated document as a <code>byte[]</code></p>
</li>
<li>
<p>Handle the scenario where the source of the document is not present in
the response (this is the case by default)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>It is also possible to check for shard failures:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ReplicationResponse.ShardInfo shardInfo = updateResponse.getShardInfo();
            if (shardInfo.getTotal() != shardInfo.getSuccessful()) {
                // <b class="conum">(1)</b>
            }
            if (shardInfo.getFailed() &gt; 0) {
                for (ReplicationResponse.ShardInfo.Failure failure :
                        shardInfo.getFailures()) {
                    String reason = failure.reason(); // <b class="conum">(2)</b>
                }
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Handle the situation where number of successful shards is less than
total shards</p>
</li>
<li>
<p>Handle the potential failures</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When a <code>UpdateRequest</code> is performed against a document that does not exist,
the response has <code>404</code> status code, an <code>OpenSearchException</code> gets thrown
which needs to be handled as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            UpdateRequest request = new UpdateRequest("posts", "does_not_exist")
                    .doc("field", "value");
            try {
                UpdateResponse updateResponse = client.update(
                        request, RequestOptions.DEFAULT);
            } catch (OpenSearchException e) {
                if (e.status() == RestStatus.NOT_FOUND) {
                    // <b class="conum">(1)</b>
                }
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Handle the exception thrown because the document not exist</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If there is a version conflict, an <code>OpenSearchException</code> will
be thrown:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            UpdateRequest request = new UpdateRequest("posts", "1")
                    .doc("field", "value")
                    .setIfSeqNo(101L)
                    .setIfPrimaryTerm(200L);
            try {
                UpdateResponse updateResponse = client.update(
                        request, RequestOptions.DEFAULT);
            } catch(OpenSearchException e) {
                if (e.status() == RestStatus.CONFLICT) {
                    // <b class="conum">(1)</b>
                }
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The raised exception indicates that a version conflict error was returned.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-document-term-vectors">Term Vectors API</h3>
<div class="paragraph">
<p>Term Vectors API returns information and statistics on terms in the fields
of a particular document. The document could be stored in the index or
artificially provided by the user.</p>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-term-vectors-request">Term Vectors Request</h4>
<div class="paragraph">
<p>A <code>TermVectorsRequest</code> expects an <code>index</code>, a <code>type</code> and an <code>id</code> to specify
a certain document, and fields for which the information is retrieved.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            TermVectorsRequest request = new TermVectorsRequest("authors", "1");
            request.setFields("user");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Term vectors can also be generated for artificial documents, that is for
documents not present in the index:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            XContentBuilder docBuilder = XContentFactory.jsonBuilder();
            docBuilder.startObject().field("user", "guest-user").endObject();
            TermVectorsRequest request = new TermVectorsRequest("authors",
                docBuilder); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>An artificial document is provided as an <code>XContentBuilder</code> object,
the OpenSearch built-in helper to generate JSON content.</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="_optional_arguments_4">Optional arguments</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setFieldStatistics(false); // <b class="conum">(1)</b>
            request.setTermStatistics(true); // <b class="conum">(2)</b>
            request.setPositions(false); // <b class="conum">(3)</b>
            request.setOffsets(false); // <b class="conum">(4)</b>
            request.setPayloads(false); // <b class="conum">(5)</b>

            Map&lt;String, Integer&gt; filterSettings = new HashMap&lt;&gt;();
            filterSettings.put("max_num_terms", 3);
            filterSettings.put("min_term_freq", 1);
            filterSettings.put("max_term_freq", 10);
            filterSettings.put("min_doc_freq", 1);
            filterSettings.put("max_doc_freq", 100);
            filterSettings.put("min_word_length", 1);
            filterSettings.put("max_word_length", 10);

            request.setFilterSettings(filterSettings);  // <b class="conum">(6)</b>

            Map&lt;String, String&gt; perFieldAnalyzer = new HashMap&lt;&gt;();
            perFieldAnalyzer.put("user", "keyword");
            request.setPerFieldAnalyzer(perFieldAnalyzer);  // <b class="conum">(7)</b>

            request.setRealtime(false); // <b class="conum">(8)</b>
            request.setRouting("routing"); // <b class="conum">(9)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set <code>fieldStatistics</code> to <code>false</code> (default is <code>true</code>) to omit document count,
sum of document frequencies, sum of total term frequencies.</p>
</li>
<li>
<p>Set <code>termStatistics</code> to <code>true</code> (default is <code>false</code>) to display
total term frequency and document frequency.</p>
</li>
<li>
<p>Set <code>positions</code> to <code>false</code> (default is <code>true</code>) to omit the output of
positions.</p>
</li>
<li>
<p>Set <code>offsets</code> to <code>false</code> (default is <code>true</code>) to omit the output of
offsets.</p>
</li>
<li>
<p>Set <code>payloads</code> to <code>false</code> (default is <code>true</code>) to omit the output of
payloads.</p>
</li>
<li>
<p>Set <code>filterSettings</code> to filter the terms that can be returned based
on their tf-idf scores.</p>
</li>
<li>
<p>Set <code>perFieldAnalyzer</code> to specify  a different analyzer than
the one that the field has.</p>
</li>
<li>
<p>Set <code>realtime</code> to <code>false</code> (default is <code>true</code>) to retrieve term vectors
near realtime.</p>
</li>
<li>
<p>Set a routing parameter</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-term-vectors-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>TermVectorsRequest</code> in the following manner, the client waits
for the <code>TermVectorsResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        TermVectorsResponse response =
                client.termvectors(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-term-vectors-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>TermVectorsRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous term-vectors method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        client.termvectorsAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>TermVectorsRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>term-vectors</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        listener = new ActionListener&lt;TermVectorsResponse&gt;() {
            @Override
            public void onResponse(TermVectorsResponse termVectorsResponse) {
                // <b class="conum">(1)</b>
            }
            @Override
            public void onFailure(Exception e) {
                // <b class="conum">(2)</b>
            }
        };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>TermVectorsRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-term-vectors-response">Term Vectors Response</h4>
<div class="paragraph">
<p><code>TermVectorsResponse</code> contains the following information:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        String index = response.getIndex(); // <b class="conum">(1)</b>
        String type = response.getType(); // <b class="conum">(2)</b>
        String id = response.getId(); // <b class="conum">(3)</b>
        boolean found = response.getFound(); // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The index name of the document.</p>
</li>
<li>
<p>The type name of the document.</p>
</li>
<li>
<p>The id of the document.</p>
</li>
<li>
<p>Indicates whether or not the document found.</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="_inspecting_term_vectors">Inspecting Term Vectors</h5>
<div class="paragraph">
<p>If <code>TermVectorsResponse</code> contains non-null list of term vectors,
more information about each term vector can be obtained using the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            for (TermVectorsResponse.TermVector tv : response.getTermVectorsList()) {
                String fieldname = tv.getFieldName(); // <b class="conum">(1)</b>
                int docCount = tv.getFieldStatistics().getDocCount(); // <b class="conum">(2)</b>
                long sumTotalTermFreq =
                        tv.getFieldStatistics().getSumTotalTermFreq(); // <b class="conum">(3)</b>
                long sumDocFreq = tv.getFieldStatistics().getSumDocFreq(); // <b class="conum">(4)</b>
                if (tv.getTerms() != null) {
                    List&lt;TermVectorsResponse.TermVector.Term&gt; terms =
                            tv.getTerms(); // <b class="conum">(5)</b>
                    for (TermVectorsResponse.TermVector.Term term : terms) {
                        String termStr = term.getTerm(); // <b class="conum">(6)</b>
                        int termFreq = term.getTermFreq(); // <b class="conum">(7)</b>
                        int docFreq = term.getDocFreq(); // <b class="conum">(8)</b>
                        long totalTermFreq = term.getTotalTermFreq(); // <b class="conum">(9)</b>
                        float score = term.getScore(); // <b class="conum">(10)</b>
                        if (term.getTokens() != null) {
                            List&lt;TermVectorsResponse.TermVector.Token&gt; tokens =
                                    term.getTokens(); // <b class="conum">(11)</b>
                            for (TermVectorsResponse.TermVector.Token token : tokens) {
                                int position = token.getPosition(); // <b class="conum">(12)</b>
                                int startOffset = token.getStartOffset(); // <b class="conum">(13)</b>
                                int endOffset = token.getEndOffset(); // <b class="conum">(14)</b>
                                String payload = token.getPayload(); // <b class="conum">(15)</b>
                            }
                        }
                    }
                }
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The name of the current field</p>
</li>
<li>
<p>Fields statistics for the current field - document count</p>
</li>
<li>
<p>Fields statistics for the current field - sum of total term frequencies</p>
</li>
<li>
<p>Fields statistics for the current field - sum of document frequencies</p>
</li>
<li>
<p>Terms for the current field</p>
</li>
<li>
<p>The name of the term</p>
</li>
<li>
<p>Term frequency of the term</p>
</li>
<li>
<p>Document frequency of the term</p>
</li>
<li>
<p>Total term frequency of the term</p>
</li>
<li>
<p>Score of the term</p>
</li>
<li>
<p>Tokens of the term</p>
</li>
<li>
<p>Position of the token</p>
</li>
<li>
<p>Start offset of the token</p>
</li>
<li>
<p>End offset of the token</p>
</li>
<li>
<p>Payload of the token</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-document-bulk">Bulk API</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The Java High Level REST Client provides the
<a href="java-rest-high-supported-apis.html#java-rest-high-document-bulk-processor">Bulk Processor</a> to assist with bulk requests.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-bulk-request">Bulk Request</h4>
<div class="paragraph">
<p>A <code>BulkRequest</code> can be used to execute multiple index, update and/or delete
operations using a single request.</p>
</div>
<div class="paragraph">
<p>It requires at least one operation to be added to the Bulk request:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            BulkRequest request = new BulkRequest(); // <b class="conum">(1)</b>
            request.add(new IndexRequest("posts").id("1")  // <b class="conum">(2)</b>
                    .source(XContentType.JSON,"field", "foo"));
            request.add(new IndexRequest("posts").id("2")  // <b class="conum">(3)</b>
                    .source(XContentType.JSON,"field", "bar"));
            request.add(new IndexRequest("posts").id("3")  // <b class="conum">(4)</b>
                    .source(XContentType.JSON,"field", "baz"));</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Creates the <code>BulkRequest</code></p>
</li>
<li>
<p>Adds a first <code>IndexRequest</code> to the Bulk request. See <a href="java-rest-high-supported-apis.html#java-rest-high-document-index">Index API</a> for
more information on how to build <code>IndexRequest</code>.</p>
</li>
<li>
<p>Adds a second <code>IndexRequest</code></p>
</li>
<li>
<p>Adds a third <code>IndexRequest</code></p>
</li>
</ol>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
The Bulk API supports only documents encoded in JSON or SMILE.
Providing documents in any other format will result in an error.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>And different operation types can be added to the same <code>BulkRequest</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            BulkRequest request = new BulkRequest();
            request.add(new DeleteRequest("posts", "3")); // <b class="conum">(1)</b>
            request.add(new UpdateRequest("posts", "2") // <b class="conum">(2)</b>
                    .doc(XContentType.JSON,"other", "test"));
            request.add(new IndexRequest("posts").id("4")  // <b class="conum">(3)</b>
                    .source(XContentType.JSON,"field", "baz"));</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Adds a <code>DeleteRequest</code> to the <code>BulkRequest</code>. See <a href="java-rest-high-supported-apis.html#java-rest-high-document-delete">Delete API</a>
for more information on how to build <code>DeleteRequest</code>.</p>
</li>
<li>
<p>Adds an <code>UpdateRequest</code> to the <code>BulkRequest</code>. See <a href="java-rest-high-supported-apis.html#java-rest-high-document-update">Update API</a>
for more information on how to build <code>UpdateRequest</code>.</p>
</li>
<li>
<p>Adds an <code>IndexRequest</code> using the SMILE format</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_5">Optional arguments</h4>
<div class="paragraph">
<p>The following arguments can optionally be provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.timeout(TimeValue.timeValueMinutes(2)); // <b class="conum">(1)</b>
            request.timeout("2m"); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to wait for the bulk request to be performed as a <code>TimeValue</code></p>
</li>
<li>
<p>Timeout to wait for the bulk request to be performed as a <code>String</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setRefreshPolicy(WriteRequest.RefreshPolicy.WAIT_UNTIL); // <b class="conum">(1)</b>
            request.setRefreshPolicy("wait_for");                            // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Refresh policy as a <code>WriteRequest.RefreshPolicy</code> instance</p>
</li>
<li>
<p>Refresh policy as a <code>String</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.waitForActiveShards(2); // <b class="conum">(1)</b>
            request.waitForActiveShards(ActiveShardCount.ALL); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Sets the number of shard copies that must be active before proceeding with
the index/update/delete operations.</p>
</li>
<li>
<p>Number of shard copies provided as a <code>ActiveShardCount</code>: can be
<code>ActiveShardCount.ALL</code>, <code>ActiveShardCount.ONE</code> or
<code>ActiveShardCount.DEFAULT</code> (default)</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.pipeline("pipelineId"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Global pipelineId used on all sub requests, unless overridden on a sub request</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.routing("routingId"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Global routingId used on all sub requests, unless overridden on a sub request</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            BulkRequest defaulted = new BulkRequest("posts"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A bulk request with a global index used on all sub requests, unless overridden on a sub request.
This parameter is @Nullable and can only be set during <code>BulkRequest</code> creation.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-bulk-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>BulkRequest</code> in the following manner, the client waits
for the <code>BulkResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            BulkResponse bulkResponse = client.bulk(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-bulk-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>BulkRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous bulk method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.bulkAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>BulkRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>bulk</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ActionListener&lt;BulkResponse&gt; listener = new ActionListener&lt;BulkResponse&gt;() {
                @Override
                public void onResponse(BulkResponse bulkResponse) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>BulkRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-bulk-response">Bulk Response</h4>
<div class="paragraph">
<p>The returned <code>BulkResponse</code> contains information about the executed operations and
 allows to iterate over each result as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            for (BulkItemResponse bulkItemResponse : bulkResponse) { // <b class="conum">(1)</b>
                DocWriteResponse itemResponse = bulkItemResponse.getResponse(); // <b class="conum">(2)</b>

                switch (bulkItemResponse.getOpType()) {
                case INDEX:    // <b class="conum">(3)</b>
                case CREATE:
                    IndexResponse indexResponse = (IndexResponse) itemResponse;
                    break;
                case UPDATE:   // <b class="conum">(4)</b>
                    UpdateResponse updateResponse = (UpdateResponse) itemResponse;
                    break;
                case DELETE:   // <b class="conum">(5)</b>
                    DeleteResponse deleteResponse = (DeleteResponse) itemResponse;
                }
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Iterate over the results of all operations</p>
</li>
<li>
<p>Retrieve the response of the operation (successful or not), can be
<code>IndexResponse</code>, <code>UpdateResponse</code> or <code>DeleteResponse</code> which can all be seen as
<code>DocWriteResponse</code> instances</p>
</li>
<li>
<p>Handle the response of an index operation</p>
</li>
<li>
<p>Handle the response of a update operation</p>
</li>
<li>
<p>Handle the response of a delete operation</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The Bulk response provides a method to quickly check if one or more operation
has failed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            if (bulkResponse.hasFailures()) { // <b class="conum">(1)</b>

            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This method returns <code>true</code> if at least one operation failed</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In such situation it is necessary to iterate over all operation results in order
to check if the operation failed, and if so, retrieve the corresponding failure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            for (BulkItemResponse bulkItemResponse : bulkResponse) {
                if (bulkItemResponse.isFailed()) { // <b class="conum">(1)</b>
                    BulkItemResponse.Failure failure =
                            bulkItemResponse.getFailure(); // <b class="conum">(2)</b>
                }
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Indicate if a given operation failed</p>
</li>
<li>
<p>Retrieve the failure of the failed operation</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-bulk-processor">Bulk Processor</h4>
<div class="paragraph">
<p>The <code>BulkProcessor</code> simplifies the usage of the Bulk API by providing
a utility class that allows index/update/delete operations to be
transparently executed as they are added to the processor.</p>
</div>
<div class="paragraph">
<p>In order to execute the requests, the <code>BulkProcessor</code> requires the following
components:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>RestHighLevelClient</code></dt>
<dd>
<p>This client is used to execute the <code>BulkRequest</code>
and to retrieve the <code>BulkResponse</code></p>
</dd>
<dt class="hdlist1"><code>BulkProcessor.Listener</code></dt>
<dd>
<p>This listener is called before and after
every <code>BulkRequest</code> execution or when a <code>BulkRequest</code> failed</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Then the <code>BulkProcessor.builder</code> method can be used to build a new
<code>BulkProcessor</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            BulkProcessor.Listener listener = new BulkProcessor.Listener() { // <b class="conum">(1)</b>
                @Override
                public void beforeBulk(long executionId, BulkRequest request) {
                    // <b class="conum">(2)</b>
                }

                @Override
                public void afterBulk(long executionId, BulkRequest request,
                        BulkResponse response) {
                    // <b class="conum">(3)</b>
                }

                @Override
                public void afterBulk(long executionId, BulkRequest request,
                        Throwable failure) {
                    // <b class="conum">(4)</b>
                }
            };

            BulkProcessor bulkProcessor = BulkProcessor.builder(
                    (request, bulkListener) -&gt;
                        client.bulkAsync(request, RequestOptions.DEFAULT, bulkListener),
                    listener).build(); // <b class="conum">(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Create the <code>BulkProcessor.Listener</code></p>
</li>
<li>
<p>This method is called before each execution of a <code>BulkRequest</code></p>
</li>
<li>
<p>This method is called after each execution of a <code>BulkRequest</code></p>
</li>
<li>
<p>This method is called when a <code>BulkRequest</code> failed</p>
</li>
<li>
<p>Create the <code>BulkProcessor</code> by calling the <code>build()</code> method from
the <code>BulkProcessor.Builder</code>. The <code>RestHighLevelClient.bulkAsync()</code>
method will be used to execute the <code>BulkRequest</code> under the hood.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The <code>BulkProcessor.Builder</code> provides methods to configure how the
<code>BulkProcessor</code> should handle requests execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            BulkProcessor.Builder builder = BulkProcessor.builder(
                    (request, bulkListener) -&gt;
                        client.bulkAsync(request, RequestOptions.DEFAULT, bulkListener),
                    listener);
            builder.setBulkActions(500); // <b class="conum">(1)</b>
            builder.setBulkSize(new ByteSizeValue(1L, ByteSizeUnit.MB)); // <b class="conum">(2)</b>
            builder.setConcurrentRequests(0); // <b class="conum">(3)</b>
            builder.setFlushInterval(TimeValue.timeValueSeconds(10L)); // <b class="conum">(4)</b>
            builder.setBackoffPolicy(BackoffPolicy
                    .constantBackoff(TimeValue.timeValueSeconds(1L), 3)); // <b class="conum">(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set when to flush a new bulk request based on the number of
actions currently added (defaults to 1000, use -1 to disable it)</p>
</li>
<li>
<p>Set when to flush a new bulk request based on the size of
actions currently added (defaults to 5Mb, use -1 to disable it)</p>
</li>
<li>
<p>Set the number of concurrent requests allowed to be executed
(default to 1, use 0 to only allow the execution of a single request)</p>
</li>
<li>
<p>Set a flush interval flushing any <code>BulkRequest</code> pending if the
interval passes (defaults to not set)</p>
</li>
<li>
<p>Set a constant back off policy that initially waits for 1 second
and retries up to 3 times. See <code>BackoffPolicy.noBackoff()</code>,
<code>BackoffPolicy.constantBackoff()</code> and <code>BackoffPolicy.exponentialBackoff()</code>
for more options.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Once the <code>BulkProcessor</code> is created requests can be added to it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            IndexRequest one = new IndexRequest("posts").id("1")
                    .source(XContentType.JSON, "title",
                            "In which order are my OpenSearch queries executed?");
            IndexRequest two = new IndexRequest("posts").id("2")
                    .source(XContentType.JSON, "title",
                            "Current status and upcoming changes in OpenSearch");
            IndexRequest three = new IndexRequest("posts").id("3")
                    .source(XContentType.JSON, "title",
                            "The Future of Federated Search in OpenSearch");

            bulkProcessor.add(one);
            bulkProcessor.add(two);
            bulkProcessor.add(three);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The requests will be executed by the <code>BulkProcessor</code>, which takes care of
calling the <code>BulkProcessor.Listener</code> for every bulk request.</p>
</div>
<div class="paragraph">
<p>The listener provides methods to access to the <code>BulkRequest</code> and the <code>BulkResponse</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            BulkProcessor.Listener listener = new BulkProcessor.Listener() {
                @Override
                public void beforeBulk(long executionId, BulkRequest request) {
                    int numberOfActions = request.numberOfActions(); // <b class="conum">(1)</b>
                    logger.debug("Executing bulk [{}] with {} requests",
                            executionId, numberOfActions);
                }

                @Override
                public void afterBulk(long executionId, BulkRequest request,
                        BulkResponse response) {
                    if (response.hasFailures()) { // <b class="conum">(2)</b>
                        logger.warn("Bulk [{}] executed with failures", executionId);
                    } else {
                        logger.debug("Bulk [{}] completed in {} milliseconds",
                                executionId, response.getTook().getMillis());
                    }
                }

                @Override
                public void afterBulk(long executionId, BulkRequest request,
                        Throwable failure) {
                    logger.error("Failed to execute bulk", failure); // <b class="conum">(3)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called before each execution of a <code>BulkRequest</code>, this method allows to know
the number of operations that are going to be executed within the <code>BulkRequest</code></p>
</li>
<li>
<p>Called after each execution of a <code>BulkRequest</code>, this method allows to know if
the <code>BulkResponse</code> contains errors</p>
</li>
<li>
<p>Called if the <code>BulkRequest</code> failed, this method allows to know
the failure</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Once all requests have been added to the <code>BulkProcessor</code>, its instance needs to
be closed using one of the two available closing methods.</p>
</div>
<div class="paragraph">
<p>The <code>awaitClose()</code> method can be used to wait until all requests have been
processed or the specified waiting time elapses:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            boolean terminated = bulkProcessor.awaitClose(30L, TimeUnit.SECONDS); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The method returns <code>true</code> if all bulk requests completed and <code>false</code> if the
waiting time elapsed before all the bulk requests completed</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The <code>close()</code> method can be used to immediately close the <code>BulkProcessor</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            bulkProcessor.close();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Both methods flush the requests added to the processor before closing the
processor and also forbid any new request to be added to it.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-document-multi-get">Multi-Get API</h3>
<div class="paragraph">
<p>The <code>multiGet</code> API executes multiple <a href="java-rest-high-supported-apis.html#java-rest-high-document-get"><code>get</code></a>
requests in a single http request in parallel.</p>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-multi-get-request">Multi-Get Request</h4>
<div class="paragraph">
<p>A <code>MultiGetRequest</code> is built empty and you add `MultiGetRequest.Item`s to configure
what to fetch:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            MultiGetRequest request = new MultiGetRequest();
            request.add(new MultiGetRequest.Item(
                "index",         // <b class="conum">(1)</b>
                "example_id"));  // <b class="conum">(2)</b>
            request.add(new MultiGetRequest.Item("index", "another_id")); // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Index</p>
</li>
<li>
<p>Document id</p>
</li>
<li>
<p>Add another item to fetch</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_6">Optional arguments</h4>
<div class="paragraph">
<p><code>multiGet</code> supports the same optional arguments that the
<a href="java-rest-high-supported-apis.html#java-rest-high-document-get-request-optional-arguments"><code>get</code> API</a> supports.
You can set most of these on the <code>Item</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.add(new MultiGetRequest.Item("index", "example_id")
                .fetchSourceContext(FetchSourceContext.DO_NOT_FETCH_SOURCE));  // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Disable source retrieval, enabled by default</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            String[] includes = new String[] {"foo", "*r"};
            String[] excludes = Strings.EMPTY_ARRAY;
            FetchSourceContext fetchSourceContext =
                    new FetchSourceContext(true, includes, excludes);
            request.add(new MultiGetRequest.Item("index", "example_id")
                .fetchSourceContext(fetchSourceContext));  // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Configure source inclusion for specific fields</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            String[] includes = Strings.EMPTY_ARRAY;
            String[] excludes = new String[] {"foo", "*r"};
            FetchSourceContext fetchSourceContext =
                    new FetchSourceContext(true, includes, excludes);
            request.add(new MultiGetRequest.Item("index", "example_id")
                .fetchSourceContext(fetchSourceContext));  // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Configure source exclusion for specific fields</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.add(new MultiGetRequest.Item("index", "example_id")
                .storedFields("foo"));  // <b class="conum">(1)</b>
            MultiGetResponse response = client.mget(request, RequestOptions.DEFAULT);
            MultiGetItemResponse item = response.getResponses()[0];
            String value = item.getResponse().getField("foo").getValue(); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Configure retrieval for specific stored fields (requires fields to be
stored separately in the mappings)</p>
</li>
<li>
<p>Retrieve the <code>foo</code> stored field (requires the field to be stored
separately in the mappings)</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.add(new MultiGetRequest.Item("index", "with_routing")
                .routing("some_routing"));          // <b class="conum">(1)</b>
            request.add(new MultiGetRequest.Item("index", "with_version")
                .versionType(VersionType.EXTERNAL)  // <b class="conum">(2)</b>
                .version(10123L));                  // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Routing value</p>
</li>
<li>
<p>Version</p>
</li>
<li>
<p>Version type</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><a href="https://www.opensearch.org/guide/en/opensearch/reference/{branch}/search-search.html#search-preference"><code>preference</code></a>,
<a href="https://www.opensearch.org/guide/en/opensearch/reference/{branch}/docs-get.html#realtime"><code>realtime</code></a>
and
<a href="https://www.opensearch.org/guide/en/opensearch/reference/{branch}/docs-get.html#get-refresh"><code>refresh</code></a> can be set on the main request but
not on any items:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.preference("some_preference");  // <b class="conum">(1)</b>
            request.realtime(false);                // <b class="conum">(2)</b>
            request.refresh(true);                  // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Preference value</p>
</li>
<li>
<p>Set realtime flag to <code>false</code> (<code>true</code> by default)</p>
</li>
<li>
<p>Perform a refresh before retrieving the document (<code>false</code> by default)</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-multi-get-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>MultiGetRequest</code> in the following manner, the client waits
for the <code>MultiGetResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            MultiGetResponse response = client.mget(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-multi-get-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>MultiGetRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous multi-get method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.mgetAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>MultiGetRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>multi-get</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            listener = new ActionListener&lt;MultiGetResponse&gt;() {
                @Override
                public void onResponse(MultiGetResponse response) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>MultiGetRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-multi-get-response">Multi Get Response</h4>
<div class="paragraph">
<p>The returned <code>MultiGetResponse</code> contains a list of <code>MultiGetItemResponse`s in
`getResponses</code> in the same order that they were requested.
<code>MultiGetItemResponse</code> contains <strong>either</strong> a
<a href="java-rest-high-supported-apis.html#java-rest-high-document-get-response"><code>GetResponse</code></a> if the get succeeded
or a <code>MultiGetResponse.Failure</code> if it failed. A success looks just like a
normal <code>GetResponse</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            MultiGetItemResponse firstItem = response.getResponses()[0];
            assertNull(firstItem.getFailure());              // <b class="conum">(1)</b>
            GetResponse firstGet = firstItem.getResponse();  // <b class="conum">(2)</b>
            String index = firstItem.getIndex();
            String id = firstItem.getId();
            if (firstGet.isExists()) {
                long version = firstGet.getVersion();
                String sourceAsString = firstGet.getSourceAsString();        // <b class="conum">(3)</b>
                Map&lt;String, Object&gt; sourceAsMap = firstGet.getSourceAsMap(); // <b class="conum">(4)</b>
                byte[] sourceAsBytes = firstGet.getSourceAsBytes();          // <b class="conum">(5)</b>
            } else {
                // <b class="conum">(6)</b>
            }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>getFailure</code> returns null because there isn&#8217;t a failure.</p>
</li>
<li>
<p><code>getResponse</code> returns the <code>GetResponse</code>.</p>
</li>
<li>
<p>Retrieve the document as a <code>String</code></p>
</li>
<li>
<p>Retrieve the document as a <code>Map&lt;String, Object&gt;</code></p>
</li>
<li>
<p>Retrieve the document as a <code>byte[]</code></p>
</li>
<li>
<p>Handle the scenario where the document was not found. Note that although
the returned response has <code>404</code> status code, a valid <code>GetResponse</code> is
returned rather than an exception thrown. Such response does not hold any
source document and its <code>isExists</code> method returns <code>false</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When one of the subrequests as performed against an index that does not exist
<code>getFailure</code> will contain an exception:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            assertNull(missingIndexItem.getResponse());                // <b class="conum">(1)</b>
            Exception e = missingIndexItem.getFailure().getFailure();  // <b class="conum">(2)</b>
            OpenSearchException ee = (OpenSearchException) e;    // <b class="conum">(3)</b>
            // TODO status is broken! fix in a followup
            // assertEquals(RestStatus.NOT_FOUND, ee.status());        // <b class="conum">(4)</b>
            assertThat(e.getMessage(),
                containsString("reason=no such index [missing_index]")); // <b class="conum">(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>getResponse</code> is null.</p>
</li>
<li>
<p><code>getFailure</code> isn&#8217;t and contains an <code>Exception</code>.</p>
</li>
<li>
<p>That <code>Exception</code> is actually an <code>OpenSearchException</code></p>
</li>
<li>
<p>and it has a status of <code>NOT_FOUND</code>. It&#8217;d have been an HTTP 404 if this
wasn&#8217;t a multi get.</p>
</li>
<li>
<p><code>getMessage</code> explains the actual cause, <code>no such index</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In case a specific document version has been requested, and the existing
document has a different version number, a version conflict is raised:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            MultiGetRequest request = new MultiGetRequest();
            request.add(new MultiGetRequest.Item("index", "example_id")
                .version(1000L));
            MultiGetResponse response = client.mget(request, RequestOptions.DEFAULT);
            MultiGetItemResponse item = response.getResponses()[0];
            assertNull(item.getResponse());                          // <b class="conum">(1)</b>
            Exception e = item.getFailure().getFailure();            // <b class="conum">(2)</b>
            OpenSearchException ee = (OpenSearchException) e;  // <b class="conum">(3)</b>
            // TODO status is broken! fix in a followup
            // assertEquals(RestStatus.CONFLICT, ee.status());          // <b class="conum">(4)</b>
            assertThat(e.getMessage(),
                containsString("version conflict, current version [1] is "
                    + "different than the one provided [1000]"));    // <b class="conum">(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>getResponse</code> is null.</p>
</li>
<li>
<p><code>getFailure</code> isn&#8217;t and contains an <code>Exception</code>.</p>
</li>
<li>
<p>That <code>Exception</code> is actually an <code>OpenSearchException</code></p>
</li>
<li>
<p>and it has a status of <code>CONFLICT</code>. It&#8217;d have been an HTTP 409 if this
wasn&#8217;t a multi get.</p>
</li>
<li>
<p><code>getMessage</code> explains the actual cause, `</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-document-reindex">Reindex API</h3>
<div class="sect3">
<h4 id="java-rest-high-document-reindex-request">Reindex Request</h4>
<div class="paragraph">
<p>A <code>ReindexRequest</code> can be used to copy documents from one or more indexes into a
destination index.</p>
</div>
<div class="paragraph">
<p>It requires an existing source index and a target index which may or may not exist pre-request. Reindex does not attempt
to set up the destination index. It does not copy the settings of the source index. You should set up the destination
index prior to running a _reindex action, including setting up mappings, shard counts, replicas, etc.</p>
</div>
<div class="paragraph">
<p>The simplest form of a <code>ReindexRequest</code> looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ReindexRequest request = new ReindexRequest(); // <b class="conum">(1)</b>
            request.setSourceIndices("source1", "source2"); // <b class="conum">(2)</b>
            request.setDestIndex("dest");  // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Creates the <code>ReindexRequest</code></p>
</li>
<li>
<p>Adds a list of sources to copy from</p>
</li>
<li>
<p>Adds the destination index</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The <code>dest</code> element can be configured like the index API to control optimistic concurrency control. Just leaving out
<code>versionType</code> (as above) or setting it to internal will cause OpenSearch to blindly dump documents into the target.
Setting <code>versionType</code> to external will cause OpenSearch to preserve the version from the source, create any documents
that are missing, and update any documents that have an older version in the destination index than they do in the
source index.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setDestVersionType(VersionType.EXTERNAL); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set the versionType to <code>EXTERNAL</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Setting <code>opType</code> to <code>create</code> will cause <code>_reindex</code> to only create missing documents in the target index. All existing
documents will cause a version conflict. The default <code>opType</code> is <code>index</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setDestOpType("create"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set the opType to <code>create</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By default version conflicts abort the <code>_reindex</code> process but you can just count
them instead with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setConflicts("proceed"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set <code>proceed</code> on version conflict</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You can limit the documents by adding a query.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setSourceQuery(new TermQueryBuilder("user", "kimchy")); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Only copy documents which have field <code>user</code> set to <code>bilbo</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Its also possible to limit the number of processed documents by setting <code>maxDocs</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setMaxDocs(10); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Only copy 10 documents</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By default <code>_reindex</code> uses batches of 1000. You can change the batch size with <code>sourceBatchSize</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setSourceBatchSize(100); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Use batches of 100 documents</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Reindex can also use the ingest feature by specifying a <code>pipeline</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setDestPipeline("my_pipeline"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>set pipeline to <code>my_pipeline</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>ReindexRequest</code> also supports a <code>script</code> that modifies the document. It allows you to
also change the document&#8217;s metadata. The following example illustrates that.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setScript(
                new Script(
                    ScriptType.INLINE, "painless",
                    "if (ctx._source.user == 'kimchy') {ctx._source.likes++;}",
                    Collections.emptyMap())); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>setScript</code> to increment the <code>likes</code> field on all documents with user <code>bilbo</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>ReindexRequest</code> supports reindexing from a remote OpenSearch cluster. When using a remote cluster the query should be
specified inside the <code>RemoteInfo</code> object and not using <code>setSourceQuery</code>. If both the remote info and the source query are
set it results in a validation error during the request. The reason for this is that the remote OpenSearch may not
understand queries built by the modern query builders. The remote cluster support works all the way back to OpenSearch
0.90 and the query language has changed since then. When reaching older versions, it is safer to write the query by hand
in JSON.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setRemoteInfo(
                new RemoteInfo(
                    "http", remoteHost, remotePort, null,
                    new BytesArray(new MatchAllQueryBuilder().toString()),
                    user, password, Collections.emptyMap(),
                    new TimeValue(100, TimeUnit.MILLISECONDS),
                    new TimeValue(100, TimeUnit.SECONDS)
                )
            ); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>set remote opensearch cluster</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>ReindexRequest</code> also helps in automatically parallelizing using <code>sliced-scroll</code> to
slice on <code>_id</code>. Use <code>setSlices</code> to specify the number of slices to use.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setSlices(2); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>set number of slices to use</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>ReindexRequest</code> uses the <code>scroll</code> parameter to control how long it keeps the
"search context" alive.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setScroll(TimeValue.timeValueMinutes(10)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>set scroll time</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_7">Optional arguments</h4>
<div class="paragraph">
<p>In addition to the options above the following arguments can optionally be also provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setTimeout(TimeValue.timeValueMinutes(2)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to wait for the reindex request to be performed as a <code>TimeValue</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setRefresh(true); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Refresh index after calling reindex</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-reindex-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>ReindexRequest</code> in the following manner, the client waits
for the <code>BulkByScrollResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            BulkByScrollResponse bulkResponse =
                    client.reindex(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-reindex-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>ReindexRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous reindex method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.reindexAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>ReindexRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>reindex</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            listener = new ActionListener&lt;BulkByScrollResponse&gt;() {
                @Override
                public void onResponse(BulkByScrollResponse bulkResponse) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>ReindexRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-reindex-task-submission">Reindex task submission</h4>
<div class="paragraph">
<p>It is also possible to submit a <code>ReindexRequest</code> and not wait for it completion with the use of Task API. This is an equivalent of a REST request
with wait_for_completion flag set to false.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            ReindexRequest reindexRequest = new ReindexRequest(); // <b class="conum">(1)</b>
            reindexRequest.setSourceIndices(sourceIndex);
            reindexRequest.setDestIndex(destinationIndex);
            reindexRequest.setRefresh(true);

            TaskSubmissionResponse reindexSubmission = highLevelClient()
                .submitReindexTask(reindexRequest, RequestOptions.DEFAULT); // <b class="conum">(2)</b>

            String taskId = reindexSubmission.getTask(); // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>A <code>ReindexRequest</code> is constructed the same way as for the synchronous method</p>
</li>
<li>
<p>A submit method returns a <code>TaskSubmissionResponse</code> which contains a task identifier.</p>
</li>
<li>
<p>The task identifier can be used to get <code>response</code> from a completed task.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-reindex-response">Reindex Response</h4>
<div class="paragraph">
<p>The returned <code>BulkByScrollResponse</code> contains information about the executed operations and
allows to iterate over each result as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            TimeValue timeTaken = bulkResponse.getTook(); // <b class="conum">(1)</b>
            boolean timedOut = bulkResponse.isTimedOut(); // <b class="conum">(2)</b>
            long totalDocs = bulkResponse.getTotal(); // <b class="conum">(3)</b>
            long updatedDocs = bulkResponse.getUpdated(); // <b class="conum">(4)</b>
            long createdDocs = bulkResponse.getCreated(); // <b class="conum">(5)</b>
            long deletedDocs = bulkResponse.getDeleted(); // <b class="conum">(6)</b>
            long batches = bulkResponse.getBatches(); // <b class="conum">(7)</b>
            long noops = bulkResponse.getNoops(); // <b class="conum">(8)</b>
            long versionConflicts = bulkResponse.getVersionConflicts(); // <b class="conum">(9)</b>
            long bulkRetries = bulkResponse.getBulkRetries(); // <b class="conum">(10)</b>
            long searchRetries = bulkResponse.getSearchRetries(); // <b class="conum">(11)</b>
            TimeValue throttledMillis = bulkResponse.getStatus().getThrottled(); // <b class="conum">(12)</b>
            TimeValue throttledUntilMillis =
                    bulkResponse.getStatus().getThrottledUntil(); // <b class="conum">(13)</b>
            List&lt;ScrollableHitSource.SearchFailure&gt; searchFailures =
                    bulkResponse.getSearchFailures(); // <b class="conum">(14)</b>
            List&lt;BulkItemResponse.Failure&gt; bulkFailures =
                    bulkResponse.getBulkFailures(); // <b class="conum">(15)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Get total time taken</p>
</li>
<li>
<p>Check if the request timed out</p>
</li>
<li>
<p>Get total number of docs processed</p>
</li>
<li>
<p>Number of docs that were updated</p>
</li>
<li>
<p>Number of docs that were created</p>
</li>
<li>
<p>Number of docs that were deleted</p>
</li>
<li>
<p>Number of batches that were executed</p>
</li>
<li>
<p>Number of skipped docs</p>
</li>
<li>
<p>Number of version conflicts</p>
</li>
<li>
<p>Number of times request had to retry bulk index operations</p>
</li>
<li>
<p>Number of times request had to retry search operations</p>
</li>
<li>
<p>The total time this request has throttled itself not including the current throttle time if it is currently sleeping</p>
</li>
<li>
<p>Remaining delay of any current throttle sleep or 0 if not sleeping</p>
</li>
<li>
<p>Failures during search phase</p>
</li>
<li>
<p>Failures during bulk index operation</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-document-update-by-query">Update By Query API</h3>
<div class="sect3">
<h4 id="java-rest-high-document-update-by-query-request">Update By Query Request</h4>
<div class="paragraph">
<p>A <code>UpdateByQueryRequest</code> can be used to update documents in an index.</p>
</div>
<div class="paragraph">
<p>It requires an existing index (or a set of indices) on which the update is to
be performed.</p>
</div>
<div class="paragraph">
<p>The simplest form of a <code>UpdateByQueryRequest</code> looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            UpdateByQueryRequest request =
                    new UpdateByQueryRequest("source1", "source2"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Creates the <code>UpdateByQueryRequest</code> on a set of indices.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By default version conflicts abort the <code>UpdateByQueryRequest</code> process but you can just
count them instead with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setConflicts("proceed"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set <code>proceed</code> on version conflict</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You can limit the documents by adding a query.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setQuery(new TermQueryBuilder("user", "kimchy")); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Only copy documents which have field <code>user</code> set to <code>bilbo</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Its also possible to limit the number of processed documents by setting <code>maxDocs</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setMaxDocs(10); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Only copy 10 documents</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By default <code>UpdateByQueryRequest</code> uses batches of 1000. You can change the batch size with
<code>setBatchSize</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setBatchSize(100); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Use batches of 100 documents</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Update by query can also use the ingest feature by specifying a <code>pipeline</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setPipeline("my_pipeline"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>set pipeline to <code>my_pipeline</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>UpdateByQueryRequest</code> also supports a <code>script</code> that modifies the document:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setScript(
                new Script(
                    ScriptType.INLINE, "painless",
                    "if (ctx._source.user == 'kimchy') {ctx._source.likes++;}",
                    Collections.emptyMap())); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p><code>setScript</code> to increment the <code>likes</code> field on all documents with user <code>bilbo</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>UpdateByQueryRequest</code> can be parallelized using <code>sliced-scroll</code> with <code>setSlices</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setSlices(2); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>set number of slices to use</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>UpdateByQueryRequest</code> uses the <code>scroll</code> parameter to control how long it keeps the "search context" alive.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setScroll(TimeValue.timeValueMinutes(10)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>set scroll time</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If you provide routing then the routing is copied to the scroll query, limiting the process to the shards that match
that routing value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setRouting("=cat"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>set routing</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_8">Optional arguments</h4>
<div class="paragraph">
<p>In addition to the options above the following arguments can optionally be also provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setTimeout(TimeValue.timeValueMinutes(2)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to wait for the update by query request to be performed as a <code>TimeValue</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setRefresh(true); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Refresh index after calling update by query</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setIndicesOptions(IndicesOptions.LENIENT_EXPAND_OPEN); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set indices options</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-update-by-query-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>UpdateByQueryRequest</code> in the following manner, the client waits
for the <code>UpdateByQueryResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            BulkByScrollResponse bulkResponse =
                    client.updateByQuery(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-update-by-query-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>UpdateByQueryRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous update-by-query method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.updateByQueryAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>UpdateByQueryRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>update-by-query</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            listener = new ActionListener&lt;BulkByScrollResponse&gt;() {
                @Override
                public void onResponse(BulkByScrollResponse bulkResponse) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>UpdateByQueryRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-update-by-query-response">Update By Query Response</h4>
<div class="paragraph">
<p>The returned <code>UpdateByQueryResponse</code> contains information about the executed operations and
allows to iterate over each result as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            TimeValue timeTaken = bulkResponse.getTook(); // <b class="conum">(1)</b>
            boolean timedOut = bulkResponse.isTimedOut(); // <b class="conum">(2)</b>
            long totalDocs = bulkResponse.getTotal(); // <b class="conum">(3)</b>
            long updatedDocs = bulkResponse.getUpdated(); // <b class="conum">(4)</b>
            long deletedDocs = bulkResponse.getDeleted(); // <b class="conum">(5)</b>
            long batches = bulkResponse.getBatches(); // <b class="conum">(6)</b>
            long noops = bulkResponse.getNoops(); // <b class="conum">(7)</b>
            long versionConflicts = bulkResponse.getVersionConflicts(); // <b class="conum">(8)</b>
            long bulkRetries = bulkResponse.getBulkRetries(); // <b class="conum">(9)</b>
            long searchRetries = bulkResponse.getSearchRetries(); // <b class="conum">(10)</b>
            TimeValue throttledMillis = bulkResponse.getStatus().getThrottled(); // <b class="conum">(11)</b>
            TimeValue throttledUntilMillis =
                    bulkResponse.getStatus().getThrottledUntil(); // <b class="conum">(12)</b>
            List&lt;ScrollableHitSource.SearchFailure&gt; searchFailures =
                    bulkResponse.getSearchFailures(); // <b class="conum">(13)</b>
            List&lt;BulkItemResponse.Failure&gt; bulkFailures =
                    bulkResponse.getBulkFailures(); // <b class="conum">(14)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Get total time taken</p>
</li>
<li>
<p>Check if the request timed out</p>
</li>
<li>
<p>Get total number of docs processed</p>
</li>
<li>
<p>Number of docs that were updated</p>
</li>
<li>
<p>Number of docs that were deleted</p>
</li>
<li>
<p>Number of batches that were executed</p>
</li>
<li>
<p>Number of skipped docs</p>
</li>
<li>
<p>Number of version conflicts</p>
</li>
<li>
<p>Number of times request had to retry bulk index operations</p>
</li>
<li>
<p>Number of times request had to retry search operations</p>
</li>
<li>
<p>The total time this request has throttled itself not including the current throttle time if it is currently sleeping</p>
</li>
<li>
<p>Remaining delay of any current throttle sleep or 0 if not sleeping</p>
</li>
<li>
<p>Failures during search phase</p>
</li>
<li>
<p>Failures during bulk index operation</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-document-delete-by-query">Delete By Query API</h3>
<div class="sect3">
<h4 id="java-rest-high-document-delete-by-query-request">Delete By Query Request</h4>
<div class="paragraph">
<p>A <code>DeleteByQueryRequest</code> can be used to delete documents from an index. It requires an
existing index (or a set of indices) on which deletion is to be performed.</p>
</div>
<div class="paragraph">
<p>The simplest form of a <code>DeleteByQueryRequest</code> looks like this and deletes all documents
in an index:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            DeleteByQueryRequest request =
                    new DeleteByQueryRequest("source1", "source2"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Creates the <code>DeleteByQueryRequest</code> on a set of indices.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By default version conflicts abort the <code>DeleteByQueryRequest</code> process but you can just
count them with this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setConflicts("proceed"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set <code>proceed</code> on version conflict</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You can limit the documents by adding a query.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setQuery(new TermQueryBuilder("user", "kimchy")); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Only copy documents which have field <code>user</code> set to <code>bilbo</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Its also possible to limit the number of processed documents by setting <code>maxDocs</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setMaxDocs(10); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Only copy 10 documents</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By default <code>DeleteByQueryRequest</code> uses batches of 1000. You can change the batch size
with <code>setBatchSize</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setBatchSize(100); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Use batches of 100 documents</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>DeleteByQueryRequest</code> can also be parallelized using <code>sliced-scroll</code> with <code>setSlices</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setSlices(2); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>set number of slices to use</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>DeleteByQueryRequest</code> uses the <code>scroll</code> parameter to control how long it keeps the
"search context" alive.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setScroll(TimeValue.timeValueMinutes(10)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>set scroll time</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>If you provide routing then the routing is copied to the scroll query, limiting the process to the shards that match
that routing value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setRouting("=cat"); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>set routing</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_optional_arguments_9">Optional arguments</h4>
<div class="paragraph">
<p>In addition to the options above the following arguments can optionally be also provided:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setTimeout(TimeValue.timeValueMinutes(2)); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Timeout to wait for the delete by query request to be performed as a <code>TimeValue</code></p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setRefresh(true); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Refresh index after calling delete by query</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            request.setIndicesOptions(IndicesOptions.LENIENT_EXPAND_OPEN); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Set indices options</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-delete-by-query-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>DeleteByQueryRequest</code> in the following manner, the client waits
for the <code>DeleteByQueryResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            BulkByScrollResponse bulkResponse =
                    client.deleteByQuery(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-delete-by-query-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>DeleteByQueryRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous delete-by-query method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.deleteByQueryAsync(request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>DeleteByQueryRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>delete-by-query</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            listener = new ActionListener&lt;BulkByScrollResponse&gt;() {
                @Override
                public void onResponse(BulkByScrollResponse bulkResponse) {
                    // <b class="conum">(1)</b>
                }

                @Override
                public void onFailure(Exception e) {
                    // <b class="conum">(2)</b>
                }
            };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>DeleteByQueryRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-delete-by-query-response">Delete By Query Response</h4>
<div class="paragraph">
<p>The returned <code>DeleteByQueryResponse</code> contains information about the executed operations and
allows to iterate over each result as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            TimeValue timeTaken = bulkResponse.getTook(); // <b class="conum">(1)</b>
            boolean timedOut = bulkResponse.isTimedOut(); // <b class="conum">(2)</b>
            long totalDocs = bulkResponse.getTotal(); // <b class="conum">(3)</b>
            long deletedDocs = bulkResponse.getDeleted(); // <b class="conum">(4)</b>
            long batches = bulkResponse.getBatches(); // <b class="conum">(5)</b>
            long noops = bulkResponse.getNoops(); // <b class="conum">(6)</b>
            long versionConflicts = bulkResponse.getVersionConflicts(); // <b class="conum">(7)</b>
            long bulkRetries = bulkResponse.getBulkRetries(); // <b class="conum">(8)</b>
            long searchRetries = bulkResponse.getSearchRetries(); // <b class="conum">(9)</b>
            TimeValue throttledMillis = bulkResponse.getStatus().getThrottled(); // <b class="conum">(10)</b>
            TimeValue throttledUntilMillis =
                    bulkResponse.getStatus().getThrottledUntil(); // <b class="conum">(11)</b>
            List&lt;ScrollableHitSource.SearchFailure&gt; searchFailures =
                    bulkResponse.getSearchFailures(); // <b class="conum">(12)</b>
            List&lt;BulkItemResponse.Failure&gt; bulkFailures =
                    bulkResponse.getBulkFailures(); // <b class="conum">(13)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Get total time taken</p>
</li>
<li>
<p>Check if the request timed out</p>
</li>
<li>
<p>Get total number of docs processed</p>
</li>
<li>
<p>Number of docs that were deleted</p>
</li>
<li>
<p>Number of batches that were executed</p>
</li>
<li>
<p>Number of skipped docs</p>
</li>
<li>
<p>Number of version conflicts</p>
</li>
<li>
<p>Number of times request had to retry bulk index operations</p>
</li>
<li>
<p>Number of times request had to retry search operations</p>
</li>
<li>
<p>The total time this request has throttled itself not including the current throttle time if it is currently sleeping</p>
</li>
<li>
<p>Remaining delay of any current throttle sleep or 0 if not sleeping</p>
</li>
<li>
<p>Failures during search phase</p>
</li>
<li>
<p>Failures during bulk index operation</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-document-rethrottle">Rethrottle API</h3>
<div class="sect3">
<h4 id="java-rest-high-document-rethrottle-request">Rethrottle Request</h4>
<div class="paragraph">
<p>A <code>RethrottleRequest</code> can be used to change the current throttling on a running
reindex, update-by-query or delete-by-query task or to disable throttling of
the task entirely. It requires the task Id of the task to change.</p>
</div>
<div class="paragraph">
<p>In its simplest form, you can use it to disable throttling of a running
task using the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            RethrottleRequest request = new RethrottleRequest(taskId); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Create a <code>RethrottleRequest</code> that disables throttling for a specific task id</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>By providing a <code>requestsPerSecond</code> argument, the request will change the
existing task throttling to the specified value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            RethrottleRequest request = new RethrottleRequest(taskId, 100.0f); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Request to change the throttling of a task to 100 requests per second</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The rethrottling request can be executed by using one of the three appropriate
methods depending on whether a reindex, update-by-query or delete-by-query task
should be rethrottled:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            client.reindexRethrottle(request, RequestOptions.DEFAULT);       // <b class="conum">(1)</b>
            client.updateByQueryRethrottle(request, RequestOptions.DEFAULT); // <b class="conum">(2)</b>
            client.deleteByQueryRethrottle(request, RequestOptions.DEFAULT); // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Execute reindex rethrottling request</p>
</li>
<li>
<p>The same for update-by-query</p>
</li>
<li>
<p>The same for delete-by-query</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-rethrottle-async">Asynchronous Execution</h4>
<div class="paragraph">
<p>The asynchronous execution of a rethrottle request requires both the <code>RethrottleRequest</code>
instance and an <code>ActionListener</code> instance to be passed to the asynchronous
method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        client.reindexRethrottleAsync(request,
                RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b>
        client.updateByQueryRethrottleAsync(request,
                RequestOptions.DEFAULT, listener); // <b class="conum">(2)</b>
        client.deleteByQueryRethrottleAsync(request,
                RequestOptions.DEFAULT, listener); // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Execute reindex rethrottling asynchronously</p>
</li>
<li>
<p>The same for update-by-query</p>
</li>
<li>
<p>The same for delete-by-query</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately.
Once it is completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. A typical listener looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        listener = new ActionListener&lt;ListTasksResponse&gt;() {
            @Override
            public void onResponse(ListTasksResponse response) {
                // <b class="conum">(1)</b>
            }

            @Override
            public void onFailure(Exception e) {
                // <b class="conum">(2)</b>
            }
        };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Code executed when the request is successfully completed</p>
</li>
<li>
<p>Code executed when the request fails with an exception</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-rethrottle-response">Rethrottle Response</h4>
<div class="paragraph">
<p>Rethrottling returns the task that has been rethrottled in the form of a
<code>ListTasksResponse</code>. The structure of this response object is described in detail
in <a href="_tasks_apis.html#java-rest-high-cluster-list-tasks-response">this section</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="java-rest-high-document-multi-term-vectors">Multi Term Vectors API</h3>
<div class="paragraph">
<p>Multi Term Vectors API allows to get multiple term vectors at once.</p>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-multi-term-vectors-request">Multi Term Vectors Request</h4>
<div class="paragraph">
<p>There are two ways to create a <code>MultiTermVectorsRequest</code>.</p>
</div>
<div class="paragraph">
<p>The first way is to create an empty <code>MultiTermVectorsRequest</code>, and then add individual
<a href="java-rest-high-supported-apis.html#java-rest-high-document-term-vectors">term vectors requests</a> to it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">            MultiTermVectorsRequest request = new MultiTermVectorsRequest(); // <b class="conum">(1)</b>
            TermVectorsRequest tvrequest1 =
                new TermVectorsRequest("authors", "1");
            tvrequest1.setFields("user");
            request.add(tvrequest1); // <b class="conum">(2)</b>

            XContentBuilder docBuilder = XContentFactory.jsonBuilder();
            docBuilder.startObject().field("user", "guest-user").endObject();
            TermVectorsRequest tvrequest2 =
                new TermVectorsRequest("authors", docBuilder);
            request.add(tvrequest2); // <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Create an empty <code>MultiTermVectorsRequest</code>.</p>
</li>
<li>
<p>Add the first <code>TermVectorsRequest</code> to the <code>MultiTermVectorsRequest</code>.</p>
</li>
<li>
<p>Add the second <code>TermVectorsRequest</code> for an artificial doc to the <code>MultiTermVectorsRequest</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The second way can be used when all term vectors requests share the same
arguments, such as index and other settings. In this case, a template
<code>TermVectorsRequest</code> can be created with all necessary settings set, and
this template request can be passed to <code>MultiTermVectorsRequest</code> along with all
documents' ids for which to execute these requests.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        TermVectorsRequest tvrequestTemplate =
            new TermVectorsRequest("authors", "fake_id"); // <b class="conum">(1)</b>
        tvrequestTemplate.setFields("user");
        String[] ids = {"1", "2"};
        MultiTermVectorsRequest request =
            new MultiTermVectorsRequest(ids, tvrequestTemplate); // <b class="conum">(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Create a template <code>TermVectorsRequest</code>.</p>
</li>
<li>
<p>Pass documents' ids and the template to the <code>MultiTermVectorsRequest</code>.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-multi-term-vectors-sync">Synchronous execution</h4>
<div class="paragraph">
<p>When executing a <code>MultiTermVectorsRequest</code> in the following manner, the client waits
for the <code>MultiTermVectorsResponse</code> to be returned before continuing with code execution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        MultiTermVectorsResponse response =
            client.mtermvectors(request, RequestOptions.DEFAULT);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Synchronous calls may throw an <code>IOException</code> in case of either failing to
parse the REST response in the high-level REST client, the request times out
or similar cases where there is no response coming back from the server.</p>
</div>
<div class="paragraph">
<p>In cases where the server returns a <code>4xx</code> or <code>5xx</code> error code, the high-level
client tries to parse the response body error details instead and then throws
a generic <code>OpenSearchException</code> and adds the original <code>ResponseException</code> as a
suppressed exception to it.</p>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-multi-term-vectors-async">Asynchronous execution</h4>
<div class="paragraph">
<p>Executing a <code>MultiTermVectorsRequest</code> can also be done in an asynchronous fashion so that
the client can return directly. Users need to specify how the response or
potential failures will be handled by passing the request and a listener to the
asynchronous multi-term-vectors method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        client.mtermvectorsAsync(
            request, RequestOptions.DEFAULT, listener); // <b class="conum">(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The <code>MultiTermVectorsRequest</code> to execute and the <code>ActionListener</code> to use when
the execution completes</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The asynchronous method does not block and returns immediately. Once it is
completed the <code>ActionListener</code> is called back using the <code>onResponse</code> method
if the execution successfully completed or using the <code>onFailure</code> method if
it failed. Failure scenarios and expected exceptions are the same as in the
synchronous execution case.</p>
</div>
<div class="paragraph">
<p>A typical listener for <code>multi-term-vectors</code> looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        listener = new ActionListener&lt;MultiTermVectorsResponse&gt;() {
            @Override
            public void onResponse(MultiTermVectorsResponse mtvResponse) {
                // <b class="conum">(1)</b>
            }
            @Override
            public void onFailure(Exception e) {
                // <b class="conum">(2)</b>
            }
        };</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Called when the execution is successfully completed.</p>
</li>
<li>
<p>Called when the whole <code>MultiTermVectorsRequest</code> fails.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="java-rest-high-document-multi-term-vectors-response">Multi Term Vectors Response</h4>
<div class="paragraph">
<p><code>MultiTermVectorsResponse</code> allows to get the list of term vectors responses,
each of which can be inspected as described in
<a href="java-rest-high-supported-apis.html#java-rest-high-document-term-vectors">Term Vectors API</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">        List&lt;TermVectorsResponse&gt; tvresponseList =
            response.getTermVectorsResponses(); // <b class="conum">(1)</b>
        if (tvresponseList != null) {
            for (TermVectorsResponse tvresponse : tvresponseList) {
            }
        }</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Get a list of <code>TermVectorsResponse</code></p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph nav-footer">
<p>Previous:<a href="java-rest-high-getting-started.html">Getting started</a>| Up:<a href="java-rest-high.html">Java High Level REST Client</a>| Home:<a href="index.html">Java REST Client</a>| Next:<a href="_search_apis.html">Search APIs</a></p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-04-05 12:06:59 -0700
</div>
</div>
</body>
</html>