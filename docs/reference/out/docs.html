<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<title>OpenSearch Reference</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:50%;border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<style>.toc-current{font-weight: bold;} .toc-root{font-family: "Open Sans","DejaVu Sans",sans-serif;
                       font-size: 0.9em;} #content{display: flex; flex-direction: column; flex: 1 1 auto;}
             .nav-footer{text-align: center; margin-top: auto;}
             .nav-footer > p > a {white-space: nowrap;}</style>
</head>
<body id="docs" class="book toc2 toc-left">
<div id="header">
<h1>OpenSearch Reference</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<p><span class="toc-root"><a href="index.html">OpenSearch Reference</a></span></p><ul class="sectlevel1">
<li><a href="opensearch-intro.html">What is OpenSearch?</a>
</li>
<li><a href="getting-started.html">Getting started with OpenSearch</a>
</li>
<li><a href="setup.html">Set up OpenSearch</a>
</li>
<li><a href="setup-upgrade.html">Upgrade OpenSearch</a>
</li>
<li><a href="index-modules.html">Index modules</a>
</li>
<li><a href="mapping.html">Mapping</a>
</li>
<li><a href="analysis.html">Text analysis</a>
</li>
<li><a href="index-templates.html">Index templates</a>
</li>
<li><a href="ingest.html">Ingest node</a>
</li>
<li><a href="search-your-data.html">Search your data</a>
</li>
<li><a href="query-dsl.html">Query DSL</a>
</li>
<li><a href="search-aggregations.html">Aggregations</a>
</li>
<li><a href="modules-scripting.html">Scripting</a>
</li>
<li><a href="high-availability.html">Set up a cluster for high availability</a>
</li>
<li><a href="snapshot-restore.html">Snapshot and restore</a>
</li>
<li><a href="commands.html">Command line tools</a>
</li>
<li><a href="how-to.html">How To</a>
</li>
<li><a href="glossary.html">Glossary of terms</a>
</li>
<li><a href="rest-apis.html">REST APIs</a>
<ul class="sectlevel1">
<li><a href="api-conventions.html">API conventions</a>
</li>
<li><a href="cat.html">Compact and aligned text (CAT) APIs</a>
</li>
<li><a href="cluster.html">Cluster APIs</a>
</li>
<li><a href="docs.html"><span class="toc-current">Document APIs</span></a>
<ul class="sectlevel2">
<li><a href="docs.html#docs-replication">Reading and Writing documents</a>
</li>
<li><a href="docs.html#docs-index_">Index API</a>
</li>
<li><a href="docs.html#docs-get">Get API</a>
</li>
<li><a href="docs.html#docs-delete">Delete API</a>
</li>
<li><a href="docs.html#docs-delete-by-query">Delete by query API</a>
</li>
<li><a href="docs.html#docs-update">Update API</a>
</li>
<li><a href="docs.html#docs-update-by-query">Update By Query API</a>
</li>
<li><a href="docs.html#docs-multi-get">Multi get (mget) API</a>
</li>
<li><a href="docs.html#docs-bulk">Bulk API</a>
</li>
<li><a href="docs.html#docs-reindex">Reindex API</a>
</li>
<li><a href="docs.html#docs-termvectors">Term vectors API</a>
</li>
<li><a href="docs.html#docs-multi-termvectors">Multi term vectors API</a>
</li>
<li><a href="docs.html#docs-refresh"><code>?refresh</code></a>
</li>
<li><a href="docs.html#optimistic-concurrency-control">Optimistic concurrency control</a>
</li>
</ul>
</li>
<li><a href="indices.html">Index APIs</a>
</li>
<li><a href="ingest-apis.html">Ingest APIs</a>
</li>
<li><a href="search.html">Search APIs</a>
</li>
</ul>
</li>
<li><a href="breaking-changes.html">Migration guide</a>
</li>
<li><a href="opensearch-release-notes.html">Release notes</a>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="docs">Document APIs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section starts with a short introduction to OpenSearch&#8217;s <a href="docs.html#docs-replication">data replication model</a>, followed by a
detailed description of the following CRUD APIs:</p>
</div>
<div class="ulist">
<div class="title">Single document APIs</div>
<ul>
<li>
<p><a href="docs.html#docs-index_">Index API</a></p>
</li>
<li>
<p><a href="docs.html#docs-get">Get API</a></p>
</li>
<li>
<p><a href="docs.html#docs-delete">Delete API</a></p>
</li>
<li>
<p><a href="docs.html#docs-update">Update API</a></p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Multi-document APIs</div>
<ul>
<li>
<p><a href="docs.html#docs-multi-get">Multi get (mget) API</a></p>
</li>
<li>
<p><a href="docs.html#docs-bulk">Bulk API</a></p>
</li>
<li>
<p><a href="docs.html#docs-delete-by-query">Delete by query API</a></p>
</li>
<li>
<p><a href="docs.html#docs-update-by-query">Update By Query API</a></p>
</li>
<li>
<p><a href="docs.html#docs-reindex">Reindex API</a></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
All CRUD APIs are single-index APIs. The <code>index</code> parameter accepts a single
index name, or an <code>alias</code> which points to a single index.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="docs-replication">Reading and Writing documents</h3>
<h4 id="_introduction" class="discrete">Introduction</h4>
<div class="paragraph">
<p>Each index in OpenSearch is <a href="opensearch-intro.html#scalability">divided into shards</a>
and each shard can have multiple copies. These copies are known as a <em>replication group</em> and must be kept in sync when documents
are added or removed. If we fail to do so, reading from one copy will result in very different results than reading from another.
The process of keeping the shard copies in sync and serving reads from them is what we call the <em>data replication model</em>.</p>
</div>
<div class="paragraph">
<p>OpenSearch’s data replication model is based on the <em>primary-backup model</em> and is described very well in the
<a href="https://www.microsoft.com/en-us/research/publication/pacifica-replication-in-log-based-distributed-storage-systems/">PacificA paper</a> of
Microsoft Research. That model is based on having a single copy from the replication group that acts as the primary shard.
The other copies are called <em>replica shards</em>. The primary serves as the main entry point for all indexing operations. It is in charge of
validating them and making sure they are correct. Once an index operation has been accepted by the primary, the primary is also
responsible for replicating the operation to the other copies.</p>
</div>
<div class="paragraph">
<p>This purpose of this section is to give a high level overview of the OpenSearch replication model and discuss the implications
it has for various interactions between write and read operations.</p>
</div>
<h4 id="basic-write-model" class="discrete">Basic write model</h4>
<div class="paragraph">
<p>Every indexing operation in OpenSearch is first resolved to a replication group using <a href="docs.html#index-routing">routing</a>,
typically based on the document ID. Once the replication group has been determined, the operation is forwarded
internally to the current <em>primary shard</em> of the group. This stage of indexing is referred to as the <em>coordinating stage</em>.</p>
</div>
<div class="paragraph">
<p>The next stage of indexing is the <em>primary stage</em>, performed on the primary shard. The primary shard is responsible
for validating the operation and forwarding it to the other replicas. Since replicas can be offline, the primary
is not required to replicate to all replicas. Instead, OpenSearch maintains a list of shard copies that should
receive the operation. This list is called the <em>in-sync copies</em> and is maintained by the master node. As the name implies,
these are the set of "good" shard copies that are guaranteed to have processed all of the index and delete operations that
have been acknowledged to the user. The primary is responsible for maintaining this invariant and thus has to replicate all
operations to each copy in this set.</p>
</div>
<div class="paragraph">
<p>The primary shard follows this basic flow:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Validate incoming operation and reject it if structurally invalid (Example: have an object field where a number is expected)</p>
</li>
<li>
<p>Execute the operation locally i.e. indexing or deleting the relevant document. This will also validate the content of fields
and reject if needed (Example: a keyword value is too long for indexing in Lucene).</p>
</li>
<li>
<p>Forward the operation to each replica in the current in-sync copies set. If there are multiple replicas, this is done in parallel.</p>
</li>
<li>
<p>Once all replicas have successfully performed the operation and responded to the primary, the primary acknowledges the successful
completion of the request to the client.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Each in-sync replica copy performs the indexing operation locally so that it has a copy. This stage of indexing is the
<em>replica stage</em>.</p>
</div>
<div class="paragraph">
<p>These indexing stages (coordinating, primary, and replica) are sequential. To enable internal retries, the lifetime of each stage
encompasses the lifetime of each subsequent stage. For example, the coordinating stage is not complete until each primary
stage, which may be spread out across different primary shards, has completed. Each primary stage will not complete until the
in-sync replicas have finished indexing the docs locally and responded to the replica requests.</p>
</div>
<h5 id="_failure_handling" class="discrete">Failure handling</h5>
<div class="paragraph">
<p>Many things can go wrong during indexing&#8201;&#8212;&#8201;disks can get corrupted, nodes can be disconnected from each other, or some
configuration mistake could cause an operation to fail on a replica despite it being successful on the primary. These
are infrequent but the primary has to respond to them.</p>
</div>
<div class="paragraph">
<p>In the case that the primary itself fails, the node hosting the primary will send a message to the master about it. The indexing
operation will wait (up to 1 minute, by <a href="index-modules.html#dynamic-index-settings">default</a>) for the master to promote one of the replicas to be a
new primary. The operation will then be forwarded to the new primary for processing. Note that the master also monitors the
health of the nodes and may decide to proactively demote a primary. This typically happens when the node holding the primary
is isolated from the cluster by a networking issue. See <a href="docs.html#demoted-primary">here</a> for more details.</p>
</div>
<div class="paragraph">
<p>Once the operation has been successfully performed on the primary, the primary has to deal with potential failures
when executing it on the replica shards. This may be caused by an actual failure on the replica or due to a network
issue preventing the operation from reaching the replica (or preventing the replica from responding). All of these
share the same end result: a replica which is part of the in-sync replica set misses an operation that is about to
be acknowledged. In order to avoid violating the invariant, the primary sends a message to the master requesting
that the problematic shard be removed from the in-sync replica set. Only once removal of the shard has been acknowledged
by the master does the primary acknowledge the operation. Note that the master will also instruct another node to start
building a new shard copy in order to restore the system to a healthy state.</p>
</div>
<div id="demoted-primary" class="paragraph">
<p>While forwarding an operation to the replicas, the primary will use the replicas to validate that it is still the
active primary. If the primary has been isolated due to a network partition (or a long GC) it may continue to process
incoming indexing operations before realising that it has been demoted. Operations that come from a stale primary
will be rejected by the replicas. When the primary receives a response from the replica rejecting its request because
it is no longer the primary then it will reach out to the master and will learn that it has been replaced. The
operation is then routed to the new primary.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">What happens if there are no replicas?</div>
<div class="paragraph">
<p>This is a valid scenario that can happen due to index configuration or simply
because all the replicas have failed. In that case the primary is processing operations without any external validation,
which may seem problematic. On the other hand, the primary cannot fail other shards on its own but request the master to do
so on its behalf. This means that the master knows that the primary is the only single good copy. We are therefore guaranteed
that the master will not promote any other (out-of-date) shard copy to be a  new primary and that any operation indexed
into the primary will not be lost. Of course, since at that point we are running with only single copy of the data, physical hardware
issues can cause data loss. See <a href="docs.html#index-wait-for-active-shards">Active shards</a> for some mitigation options.</p>
</div>
</div>
</div>
<h4 id="_basic_read_model" class="discrete">Basic read model</h4>
<div class="paragraph">
<p>Reads in OpenSearch can be very lightweight lookups by ID or a heavy search request with complex aggregations that
take non-trivial CPU power. One of the beauties of the primary-backup model is that it keeps all shard copies identical
(with the exception of in-flight operations). As such, a single in-sync copy is sufficient to serve read requests.</p>
</div>
<div class="paragraph">
<p>When a read request is received by a node, that node is responsible for forwarding it to the nodes that hold the relevant shards,
collating the responses, and responding to the client. We call that node the <em>coordinating node</em> for that request. The basic flow
is as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Resolve the read requests to the relevant shards. Note that since most searches will be sent to one or more indices,
they typically need to read from multiple shards, each representing a different subset of the data.</p>
</li>
<li>
<p>Select an active copy of each relevant shard, from the shard replication group. This can be either the primary or
a replica. By default, OpenSearch uses <a href="search-shard-routing.html#search-adaptive-replica">adaptive replica
selection</a> to select the shard copies.</p>
</li>
<li>
<p>Send shard level read requests to the selected copies.</p>
</li>
<li>
<p>Combine the results and respond. Note that in the case of get by ID look up, only one shard is relevant and this step can be skipped.</p>
</li>
</ol>
</div>
<h5 id="shard-failures" class="discrete">Shard failures</h5>
<div class="paragraph">
<p>When a shard fails to respond to a read request, the coordinating node sends the
request to another shard copy in the same replication group. Repeated failures
can result in no available shard copies.</p>
</div>
<div class="paragraph">
<p>To ensure fast responses, the following APIs will
respond with partial results if one or more shards fail:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="search.html#search-search">Search</a></p>
</li>
<li>
<p><a href="search.html#search-multi-search">Multi Search</a></p>
</li>
<li>
<p><a href="docs.html#docs-bulk">Bulk</a></p>
</li>
<li>
<p><a href="docs.html#docs-multi-get">Multi Get</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Responses containing partial results still provide a <code>200 OK</code> HTTP status code.
Shard failures are indicated by the <code>timed_out</code> and <code>_shards</code> fields of
the response header.</p>
</div>
<h4 id="_a_few_simple_implications" class="discrete">A few simple implications</h4>
<div class="paragraph">
<p>Each of these basic flows determines how OpenSearch behaves as a system for both reads and writes. Furthermore, since read
and write requests can be executed concurrently, these two basic flows interact with each other. This has a few inherent implications:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Efficient reads</dt>
<dd>
<p>Under normal operation each read operation is performed once for each relevant replication group.
Only under failure conditions do multiple copies of the same shard execute the same search.</p>
</dd>
<dt class="hdlist1">Read unacknowledged</dt>
<dd>
<p>Since the primary first indexes locally and then replicates the request, it is possible for a
concurrent read to already see the change before it has been acknowledged.</p>
</dd>
<dt class="hdlist1">Two copies by default</dt>
<dd>
<p>This model can be fault tolerant while maintaining only two copies of the data. This is in contrast to
quorum-based system where the minimum number of copies for fault tolerance is 3.</p>
</dd>
</dl>
</div>
<h4 id="_failures" class="discrete">Failures</h4>
<div class="paragraph">
<p>Under failures, the following is possible:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">A single shard can slow down indexing</dt>
<dd>
<p>Because the primary waits for all replicas in the in-sync copies set during each operation,
a single slow shard can slow down the entire replication group. This is the price we pay for the read efficiency mentioned above.
Of course a single slow shard will also slow down unlucky searches that have been routed to it.</p>
</dd>
<dt class="hdlist1">Dirty reads</dt>
<dd>
<p>An isolated primary can expose writes that will not be acknowledged. This is caused by the fact that an isolated
primary will only realize that it is isolated once it sends requests to its replicas or when reaching out to the master.
At that point the operation is already indexed into the primary and can be read by a concurrent read. OpenSearch mitigates
this risk by pinging the master every second (by default) and rejecting indexing operations if no master is known.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="docs-index_">Index API</h3>
<titleabbrev>Index</titleabbrev>
<div class="paragraph">
<p>Adds a JSON document to the specified index and makes
it searchable. If the target is an index and the document already exists,
the request updates the document and increments its version.</p>
</div>
<div class="sect3">
<h4 id="docs-index-api-request">Request</h4>
<div class="paragraph">
<p><code>PUT /&lt;target&gt;/_doc/&lt;_id&gt;</code></p>
</div>
<div class="paragraph">
<p><code>POST /&lt;target&gt;/_doc/</code></p>
</div>
<div class="paragraph">
<p><code>PUT /&lt;target&gt;/_create/&lt;_id&gt;</code></p>
</div>
<div class="paragraph">
<p><code>POST /&lt;target&gt;/_create/&lt;_id&gt;</code></p>
</div>
</div>
<div class="sect3">
<h4 id="docs-index-api-path-params">Path parameters</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>&lt;target&gt;</code></dt>
<dd>
<p>(Required, string) Name of the index to target.</p>
<div class="paragraph">
<p>If the target doesn&#8217;t exist,
this request creates the index.</p>
</div>
<div class="paragraph">
<p>You can check for existing targets using the resolve index API.</p>
</div>
</dd>
<dt class="hdlist1"><code>&lt;_id&gt;</code></dt>
<dd>
<p>(Optional, string) Unique identifier for the document.</p>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>This parameter is required for the following request formats:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>PUT /&lt;target&gt;/_doc/&lt;_id&gt;</code></p>
</li>
<li>
<p><code>PUT /&lt;target&gt;/_create/&lt;_id&gt;</code></p>
</li>
<li>
<p><code>POST /&lt;target&gt;/_create/&lt;_id&gt;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To automatically generate a document ID, use the <code>POST /&lt;target&gt;/_doc/</code> request
format and omit this parameter.</p>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-index-api-query-params">Query parameters</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>if_seq_no</code></dt>
<dd>
<p>(Optional, integer) Only perform the operation if the document has this
sequence number. See <a href="docs.html#optimistic-concurrency-control-index">Optimistic concurrency control</a>.</p>
</dd>
<dt class="hdlist1"><code>if_primary_term</code></dt>
<dd>
<p>(Optional, integer) Only perform the operation if the document has
this primary term. See <a href="docs.html#optimistic-concurrency-control-index">Optimistic concurrency control</a>.</p>
</dd>
</dl>
</div>
<div id="docs-index-api-op_type" class="dlist">
<dl>
<dt class="hdlist1"><code>op_type</code></dt>
<dd>
<p>(Optional, enum) Set to <code>create</code> to only index the document
if it does not already exist (<em>put if absent</em>). If a document with the specified
<code>_id</code> already exists, the indexing operation will fail. Same as using the
<code>&lt;index&gt;/_create</code> endpoint. Valid values: <code>index</code>, <code>create</code>.
If document id is specified, it defaults to <code>index</code>. Otherwise, it defaults to <code>create</code>.</p>
</dd>
<dt class="hdlist1"><code>pipeline</code></dt>
<dd>
<p>(Optional, string) ID of the pipeline to use to preprocess incoming documents.</p>
</dd>
<dt class="hdlist1"><code>refresh</code></dt>
<dd>
<p>(Optional, enum) If <code>true</code>, OpenSearch refreshes the affected shards to make this
operation visible to search, if <code>wait_for</code> then wait for a refresh to make
this operation visible to search, if <code>false</code> do nothing with refreshes.
Valid values: <code>true</code>, <code>false</code>, <code>wait_for</code>. Default: <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>routing</code></dt>
<dd>
<p>(Optional, string) Target the specified primary shard.</p>
</dd>
<dt class="hdlist1"><code>timeout</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, <a href="api-conventions.html#time-units">time units</a>)
Period the request waits for the following operations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="docs.html#index-creation">Automatic index creation</a></p>
</li>
<li>
<p><a href="dynamic-mapping.html">Dynamic mapping</a> updates</p>
</li>
<li>
<p><a href="docs.html#index-wait-for-active-shards">Waiting for active shards</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Defaults to <code>1m</code> (one minute). This guarantees OpenSearch waits for at least the
timeout before failing. The actual wait time could be longer, particularly when
multiple waits occur.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>version</code></dt>
<dd>
<p>(Optional, integer) Explicit version number for concurrency control.
The specified version must match the current version of the document for the
request to succeed.</p>
</dd>
<dt class="hdlist1"><code>version_type</code></dt>
<dd>
<p>(Optional, enum) Specific version type: <code>internal</code>, <code>external</code>,
<code>external_gte</code>.</p>
</dd>
<dt class="hdlist1"><code>wait_for_active_shards</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string) The number of shard copies that must be active before
proceeding with the operation. Set to <code>all</code> or any positive integer up
to the total number of shards in the index (<code>number_of_replicas+1</code>).
Default: 1, the primary shard.</p>
</div>
<div class="paragraph">
<p>See <a href="docs.html#index-wait-for-active-shards">Active shards</a>.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>require_alias</code></dt>
<dd>
<p>(Optional, Boolean)
If <code>true</code>, the destination must be an <a href="indices.html#indices-aliases">index alias</a>. Defaults to
<code>false</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-index-api-request-body">Request body</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>&lt;field&gt;</code></dt>
<dd>
<p>(Required, string) Request body contains the JSON source for the document
data.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-index-api-response-body">Response body</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>_shards</code></dt>
<dd>
<p>Provides information about the replication process of the index operation.</p>
</dd>
<dt class="hdlist1"><code>_shards.total</code></dt>
<dd>
<p>Indicates how many shard copies (primary and replica shards) the index operation
should be executed on.</p>
</dd>
<dt class="hdlist1"><code>_shards.successful</code></dt>
<dd>
<p>Indicates the number of shard copies the index operation succeeded on.
When the index operation is successful, <code>successful</code> is at least 1.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Replica shards might not all be started when an indexing operation
returns successfully&#8212;&#8203;by default, only the primary is required. Set
<code>wait_for_active_shards</code> to change this default behavior. See
<a href="docs.html#index-wait-for-active-shards">Active shards</a>.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1"><code>_shards.failed</code></dt>
<dd>
<p>An array that contains replication-related errors in the case an index operation
failed on a replica shard. 0 indicates there were no failures.</p>
</dd>
<dt class="hdlist1"><code>_index</code></dt>
<dd>
<p>The name of the index the document was added to.</p>
</dd>
<dt class="hdlist1"><code>_type</code></dt>
<dd>
<p>The document type. OpenSearch indices now support a single document type, <code>_doc</code>.</p>
</dd>
<dt class="hdlist1"><code>_id</code></dt>
<dd>
<p>The unique identifier for the added document.</p>
</dd>
<dt class="hdlist1"><code>_version</code></dt>
<dd>
<p>The document version. Incremented each time the document is updated.</p>
</dd>
<dt class="hdlist1"><code>_seq_no</code></dt>
<dd>
<p>The sequence number assigned to the document for the indexing operation.
Sequence numbers are used to ensure an older version of a document
doesn’t overwrite a newer version. See <a href="docs.html#optimistic-concurrency-control-index">Optimistic concurrency control</a>.</p>
</dd>
<dt class="hdlist1"><code>_primary_term</code></dt>
<dd>
<p>The primary term assigned to the document for the indexing operation.
See <a href="docs.html#optimistic-concurrency-control-index">Optimistic concurrency control</a>.</p>
</dd>
<dt class="hdlist1"><code>result</code></dt>
<dd>
<p>The result of the indexing operation, <code>created</code> or <code>updated</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-index-api-desc">Description</h4>
<div class="paragraph">
<p>You can index a new JSON document with the <code>_doc</code> or <code>_create</code> resource. Using
<code>_create</code> guarantees that the document is only indexed if it does not already
exist. To update an existing document, you must use the <code>_doc</code> resource.</p>
</div>
<div class="sect4">
<h5 id="index-creation">Automatically create indices</h5>
<div class="paragraph">
<p>If the target doesn&#8217;t exist,
the operation automatically creates the index and applies any matching
<a href="index-templates.html">index templates</a>.</p>
</div>
<div class="paragraph">
<p>If no mapping exists, the index operation
creates a dynamic mapping. By default, new fields and objects are
automatically added to the mapping if needed. For more information about field
mapping, see <a href="mapping.html">mapping</a> and the <a href="indices.html#indices-put-mapping">put mapping</a> API.</p>
</div>
<div class="paragraph">
<p>Automatic index creation is controlled by the <code>action.auto_create_index</code>
setting. This setting defaults to <code>true</code>, which allows any index to be created
automatically. You can modify this setting to explicitly allow or block
automatic creation of indices that match specified patterns, or set it to
<code>false</code> to disable automatic index creation entirely. Specify a
comma-separated list of patterns you want to allow, or prefix each pattern with
<code>+</code> or <code>-</code> to indicate whether it should be allowed or blocked.  When a list is
specified, the default behaviour is to disallow.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT _cluster/settings
{
  "persistent": {
    "action.auto_create_index": "my-index-000001,index10,-index1*,+ind*" <b class="conum">(1)</b>
  }
}

PUT _cluster/settings
{
  "persistent": {
    "action.auto_create_index": "false" <b class="conum">(2)</b>
  }
}

PUT _cluster/settings
{
  "persistent": {
    "action.auto_create_index": "true" <b class="conum">(3)</b>
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Allow auto-creation of indices called <code>my-index-000001</code> or <code>index10</code>, block the
creation of indices that match the pattern <code>index1*</code>, and allow creation of
any other indices that match the <code>ind*</code> pattern. Patterns are matched in
the order specified.</p>
</li>
<li>
<p>Disable automatic index creation entirely.</p>
</li>
<li>
<p>Allow automatic creation of any index. This is the default.</p>
</li>
</ol>
</div>
<h5 id="operation-type" class="discrete">Put if absent</h5>
<div class="paragraph">
<p>You can force a create operation by using the <code><em>create</code> resource or
setting the <code>op_type</code> parameter to _create</em>. In this case,
the index operation fails if a document with the specified ID
already exists in the index.</p>
</div>
<h5 id="create-document-ids-automatically" class="discrete">Create document IDs automatically</h5>
<div class="paragraph">
<p>When using the <code>POST /&lt;target&gt;/_doc/</code> request format, the <code>op_type</code> is
automatically set to <code>create</code> and the index operation generates a unique ID for
the document.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST my-index-000001/_doc/
{
  "@timestamp": "2099-11-15T13:12:00",
  "message": "GET /search HTTP/1.1 200 1070000",
  "user": {
    "id": "bilbo"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The API returns the following result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "_shards": {
    "total": 2,
    "failed": 0,
    "successful": 2
  },
  "_index": "my-index-000001",
   "_type": "_doc",
  "_id": "W0tpsmIBdwcYyG50zbta",
  "_version": 1,
  "_seq_no": 0,
  "_primary_term": 1,
  "result": "created"
}</code></pre>
</div>
</div>
<h5 id="optimistic-concurrency-control-index" class="discrete">Optimistic concurrency control</h5>
<div class="paragraph">
<p>Index operations can be made conditional and only be performed if the last
modification to the document was assigned the sequence number and primary
term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters. If a
mismatch is detected, the operation will result in a <code>VersionConflictException</code>
and a status code of 409. See <a href="docs.html#optimistic-concurrency-control">Optimistic concurrency control</a> for more details.</p>
</div>
<h5 id="index-routing" class="discrete">Routing</h5>
<div class="paragraph">
<p>By default, shard placement&#8201;&#8212;&#8201;or <code>routing</code>&#8201;&#8212;&#8201;is controlled by using a
hash of the document&#8217;s id value. For more explicit control, the value
fed into the hash function used by the router can be directly specified
on a per-operation basis using the <code>routing</code> parameter. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST my-index-000001/_doc?routing=bilbo
{
  "@timestamp": "2099-11-15T13:12:00",
  "message": "GET /search HTTP/1.1 200 1070000",
  "user": {
    "id": "bilbo"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the document is routed to a shard based on
the <code>routing</code> parameter provided: "bilbo".</p>
</div>
<div class="paragraph">
<p>When setting up explicit mapping, you can also use the <code>_routing</code> field
to direct the index operation to extract the routing value from the
document itself. This does come at the (very minimal) cost of an
additional document parsing pass. If the <code>_routing</code> mapping is defined
and set to be <code>required</code>, the index operation will fail if no routing
value is provided or extracted.</p>
</div>
<h5 id="index-distributed" class="discrete">Distributed</h5>
<div class="paragraph">
<p>The index operation is directed to the primary shard based on its route
(see the Routing section above) and performed on the actual node
containing this shard. After the primary shard completes the operation,
if needed, the update is distributed to applicable replicas.</p>
</div>
<h5 id="index-wait-for-active-shards" class="discrete">Active shards</h5>
<div class="paragraph">
<p>To improve the resiliency of writes to the system, indexing operations
can be configured to wait for a certain number of active shard copies
before proceeding with the operation. If the requisite number of active
shard copies are not available, then the write operation must wait and
retry, until either the requisite shard copies have started or a timeout
occurs. By default, write operations only wait for the primary shards
to be active before proceeding (i.e. <code>wait_for_active_shards=1</code>).
This default can be overridden in the index settings dynamically
by setting <code>index.write.wait_for_active_shards</code>. To alter this behavior
per operation, the <code>wait_for_active_shards</code> request parameter can be used.</p>
</div>
<div class="paragraph">
<p>Valid values are <code>all</code> or any positive integer up to the total number
of configured copies per shard in the index (which is <code>number_of_replicas+1</code>).
Specifying a negative value or a number greater than the number of
shard copies will throw an error.</p>
</div>
<div class="paragraph">
<p>For example, suppose we have a cluster of three nodes, <code>A</code>, <code>B</code>, and <code>C</code> and
we create an index <code>index</code> with the number of replicas set to 3 (resulting in
4 shard copies, one more copy than there are nodes). If we
attempt an indexing operation, by default the operation will only ensure
the primary copy of each shard is available before proceeding. This means
that even if <code>B</code> and <code>C</code> went down, and <code>A</code> hosted the primary shard copies,
the indexing operation would still proceed with only one copy of the data.
If <code>wait_for_active_shards</code> is set on the request to <code>3</code> (and all 3 nodes
are up), then the indexing operation will require 3 active shard copies
before proceeding, a requirement which should be met because there are 3
active nodes in the cluster, each one holding a copy of the shard. However,
if we set <code>wait_for_active_shards</code> to <code>all</code> (or to <code>4</code>, which is the same),
the indexing operation will not proceed as we do not have all 4 copies of
each shard active in the index. The operation will timeout
unless a new node is brought up in the cluster to host the fourth copy of
the shard.</p>
</div>
<div class="paragraph">
<p>It is important to note that this setting greatly reduces the chances of
the write operation not writing to the requisite number of shard copies,
but it does not completely eliminate the possibility, because this check
occurs before the write operation commences. Once the write operation
is underway, it is still possible for replication to fail on any number of
shard copies but still succeed on the primary. The <code>_shards</code> section of the
write operation&#8217;s response reveals the number of shard copies on which
replication succeeded/failed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">{
  "_shards": {
    "total": 2,
    "failed": 0,
    "successful": 2
  }
}</code></pre>
</div>
</div>
<h5 id="index-refresh" class="discrete">Refresh</h5>
<div class="paragraph">
<p>Control when the changes made by this request are visible to search. See
<a href="docs.html#docs-refresh">refresh</a>.</p>
</div>
<h5 id="index-noop" class="discrete">Noop updates</h5>
<div class="paragraph">
<p>When updating a document using the index API a new version of the document is
always created even if the document hasn&#8217;t changed. If this isn&#8217;t acceptable
use the <code>_update</code> API with <code>detect_noop</code> set to true. This option isn&#8217;t
available on the index API because the index API doesn&#8217;t fetch the old source
and isn&#8217;t able to compare it against the new source.</p>
</div>
<div class="paragraph">
<p>There isn&#8217;t a hard and fast rule about when noop updates aren&#8217;t acceptable.
It&#8217;s a combination of lots of factors like how frequently your data source
sends updates that are actually noops and how many queries per second
OpenSearch runs on the shard receiving the updates.</p>
</div>
<h5 id="timeout" class="discrete">Timeout</h5>
<div class="paragraph">
<p>The primary shard assigned to perform the index operation might not be
available when the index operation is executed. Some reasons for this
might be that the primary shard is currently recovering from a gateway
or undergoing relocation. By default, the index operation will wait on
the primary shard to become available for up to 1 minute before failing
and responding with an error. The <code>timeout</code> parameter can be used to
explicitly specify how long it waits. Here is an example of setting it
to 5 minutes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001/_doc/1?timeout=5m
{
  "@timestamp": "2099-11-15T13:12:00",
  "message": "GET /search HTTP/1.1 200 1070000",
  "user": {
    "id": "bilbo"
  }
}</code></pre>
</div>
</div>
<h5 id="index-versioning" class="discrete">Versioning</h5>
<div class="paragraph">
<p>Each indexed document is given a version number. By default,
internal versioning is used that starts at 1 and increments
with each update, deletes included. Optionally, the version number can be
set to an external value (for example, if maintained in a
database). To enable this functionality, <code>version_type</code> should be set to
<code>external</code>. The value provided must be a numeric, long value greater than or equal to 0,
and less than around 9.2e+18.</p>
</div>
<div class="paragraph">
<p>When using the external version type, the system checks to see if
the version number passed to the index request is greater than the
version of the currently stored document. If true, the document will be
indexed and the new version number used. If the value provided is less
than or equal to the stored document&#8217;s version number, a version
conflict will occur and the index operation will fail. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001/_doc/1?version=2&amp;version_type=external
{
  "user": {
    "id": "elkbee"
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Versioning is completely real time, and is not affected by the
near real time aspects of search operations. If no version is provided,
then the operation is executed without any version checks.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the previous example, the operation will succeed since the supplied
version of 2 is higher than
the current document version of 1. If the document was already updated
and its version was set to 2 or higher, the indexing command will fail
and result in a conflict (409 http status code).</p>
</div>
<div class="paragraph">
<p>A nice side effect is that there is no need to maintain strict ordering
of async indexing operations executed as a result of changes to a source
database, as long as version numbers from the source database are used.
Even the simple case of updating the OpenSearch index using data from
a database is simplified if external versioning is used, as only the
latest version will be used if the index operations arrive out of order for
whatever reason.</p>
</div>
<h5 id="index-version-types" class="discrete">Version types</h5>
<div class="paragraph">
<p>In addition to the <code>external</code> version type, OpenSearch
also supports other types for specific use cases:</p>
</div>
<div id="_version_types" class="dlist">
<dl>
<dt class="hdlist1"><code>internal</code></dt>
<dd>
<p>Only index the document if the given version is identical to the version
of the stored document.</p>
</dd>
<dt class="hdlist1"><code>external</code> or <code>external_gt</code></dt>
<dd>
<p>Only index the document if the given version is strictly higher
than the version of the stored document <strong>or</strong> if there is no existing document. The given
version will be used as the new version and will be stored with the new document. The supplied
version must be a non-negative long number.</p>
</dd>
<dt class="hdlist1"><code>external_gte</code></dt>
<dd>
<p>Only index the document if the given version is <strong>equal</strong> or higher
than the version of the stored document. If there is no existing document
the operation will succeed as well. The given version will be used as the new version
and will be stored with the new document. The supplied version must be a non-negative long number.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The <code>external_gte</code> version type is meant for special use cases and
should be used with care. If used incorrectly, it can result in loss of data.
There is another option, <code>force</code>, which is deprecated because it can cause
primary and replica shards to diverge.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="docs-index-api-example">Examples</h4>
<div class="paragraph">
<p>Insert a JSON document into the <code>my-index-000001</code> index with an <code>_id</code> of 1:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001/_doc/1
{
  "@timestamp": "2099-11-15T13:12:00",
  "message": "GET /search HTTP/1.1 200 1070000",
  "user": {
    "id": "bilbo"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The API returns the following result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "_shards": {
    "total": 2,
    "failed": 0,
    "successful": 2
  },
  "_index": "my-index-000001",
   "_type": "_doc",
  "_id": "1",
  "_version": 1,
  "_seq_no": 0,
  "_primary_term": 1,
  "result": "created"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use the <code>_create</code> resource to index a document into the <code>my-index-000001</code> index if
no document with that ID exists:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001/_create/1
{
  "@timestamp": "2099-11-15T13:12:00",
  "message": "GET /search HTTP/1.1 200 1070000",
  "user": {
    "id": "bilbo"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Set the <code>op_type</code> parameter to <em>create</em> to index a document into the <code>my-index-000001</code>
index if no document with that ID exists:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001/_doc/1?op_type=create
{
  "@timestamp": "2099-11-15T13:12:00",
  "message": "GET /search HTTP/1.1 200 1070000",
  "user": {
    "id": "bilbo"
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="docs-get">Get API</h3>
<titleabbrev>Get</titleabbrev>
<div class="paragraph">
<p>Retrieves the specified JSON document from an index.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET my-index-000001/_doc/0</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="docs-get-api-request">Request</h4>
<div class="paragraph">
<p><code>GET &lt;index&gt;/_doc/&lt;_id&gt;</code></p>
</div>
<div class="paragraph">
<p><code>HEAD &lt;index&gt;/_doc/&lt;_id&gt;</code></p>
</div>
<div class="paragraph">
<p><code>GET &lt;index&gt;/_source/&lt;_id&gt;</code></p>
</div>
<div class="paragraph">
<p><code>HEAD &lt;index&gt;/_source/&lt;_id&gt;</code></p>
</div>
</div>
<div class="sect3">
<h4 id="docs-get-api-desc">Description</h4>
<div class="paragraph">
<p>You use GET to retrieve a document and its source or stored fields from a
particular index. Use HEAD to verify that a document exists. You can
use the <code>_source</code> resource retrieve just the document source or verify
that it exists.</p>
</div>
<h5 id="realtime" class="discrete">Realtime</h5>
<div class="paragraph">
<p>By default, the get API is realtime, and is not affected by the refresh
rate of the index (when data will become visible for search). In case where
stored fields are requested (see <code>stored_fields</code> parameter) and the document
has been updated but is not yet refreshed, the get API will have to parse
and analyze the source to extract the stored fields. In order to disable
realtime GET, the <code>realtime</code> parameter can be set to <code>false</code>.</p>
</div>
<h5 id="get-source-filtering" class="discrete">Source filtering</h5>
<div class="paragraph">
<p>By default, the get operation returns the contents of the <code>_source</code> field unless
you have used the <code>stored_fields</code> parameter or if the <code>_source</code> field is disabled.
You can turn off <code>_source</code> retrieval by using the <code>_source</code> parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET my-index-000001/_doc/0?_source=false</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you only need one or two fields from the <code>_source</code>, use the <code>_source_includes</code>
or <code>_source_excludes</code> parameters to include or filter out particular fields.
This can be especially helpful with large documents where partial retrieval can
save on network overhead. Both parameters take a comma separated list
of fields or wildcard expressions. Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET my-index-000001/_doc/0?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you only want to specify includes, you can use a shorter notation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET my-index-000001/_doc/0?_source=*.id</code></pre>
</div>
</div>
<h5 id="get-routing" class="discrete">Routing</h5>
<div class="paragraph">
<p>If routing is used during indexing, the routing value also needs to be
specified to retrieve a document. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET my-index-000001/_doc/2?routing=user1</code></pre>
</div>
</div>
<div class="paragraph">
<p>This request gets the document with id <code>2</code>, but it is routed based on the
user. The document is not fetched if the correct routing is not specified.</p>
</div>
<h5 id="preference" class="discrete">Preference</h5>
<div class="paragraph">
<p>Controls a <code>preference</code> of which shard replicas to execute the get
request on. By default, the operation is randomized between the shard
replicas.</p>
</div>
<div class="paragraph">
<p>The <code>preference</code> can be set to:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>_local</code></dt>
<dd>
<p>The operation will prefer to be executed on a local
allocated shard if possible.</p>
</dd>
<dt class="hdlist1">Custom (string) value</dt>
<dd>
<p>A custom value will be used to guarantee that
the same shards will be used for the same custom value. This can help
with "jumping values" when hitting different shards in different refresh
states. A sample value can be something like the web session id, or the
user name.</p>
</dd>
</dl>
</div>
<h5 id="get-refresh" class="discrete">Refresh</h5>
<div class="paragraph">
<p>The <code>refresh</code> parameter can be set to <code>true</code> in order to refresh the
relevant shard before the get operation and make it searchable. Setting
it to <code>true</code> should be done after careful thought and verification that
this does not cause a heavy load on the system (and slows down
indexing).</p>
</div>
<h5 id="get-distributed" class="discrete">Distributed</h5>
<div class="paragraph">
<p>The get operation gets hashed into a specific shard id. It then gets
redirected to one of the replicas within that shard id and returns the
result. The replicas are the primary shard and its replicas within that
shard id group. This means that the more replicas we have, the
better GET scaling we will have.</p>
</div>
<h5 id="get-versioning" class="discrete">Versioning support</h5>
<div class="paragraph">
<p>You can use the <code>version</code> parameter to retrieve the document only if
its current version is equal to the specified one.</p>
</div>
<div class="paragraph">
<p>Internally, OpenSearch has marked the old document as deleted and added an
entirely new document. The old version of the document doesn’t disappear
immediately, although you won’t be able to access it. OpenSearch cleans up
deleted documents in the background as you continue to index more data.</p>
</div>
</div>
<div class="sect3">
<h4 id="docs-get-api-path-params">Path parameters</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>&lt;index&gt;</code></dt>
<dd>
<p>(Required, string) Name of the index that contains the document.</p>
</dd>
<dt class="hdlist1"><code>&lt;_id&gt;</code></dt>
<dd>
<p>(Required, string) Unique identifier of the document.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-get-api-query-params">Query parameters</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>preference</code></dt>
<dd>
<p>(Optional, string) Specifies the node or shard the operation should be
performed on. Random by default.</p>
</dd>
<dt class="hdlist1"><code>realtime</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, the request is real-time as opposed to near-real-time.
Defaults to <code>true</code>. See <a href="docs.html#realtime">Realtime</a>.</p>
</dd>
<dt class="hdlist1"><code>refresh</code></dt>
<dd>
<p>(Optional, Boolean)
If <code>true</code>, OpenSearch refreshes the affected shards to make this operation visible to
search. If <code>false</code>, do nothing with refreshes. Defaults to <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>routing</code></dt>
<dd>
<p>(Optional, string) Target the specified primary shard.</p>
</dd>
<dt class="hdlist1"><code>stored_fields</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, retrieves the document fields stored in the
index rather than the document <code>_source</code>. Defaults to <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>_source</code></dt>
<dd>
<p>(Optional, string) True or false to return the <code>_source</code> field or not, or a
list of fields to return.</p>
</dd>
<dt class="hdlist1"><code>_source_excludes</code></dt>
<dd>
<p>(Optional, string)
A comma-separated list of <a href="mapping-fields.html#mapping-source-field">source fields</a> to exclude from
the response.</p>
<div class="paragraph">
<p>You can also use this parameter to exclude fields from the subset specified in
<code>_source_includes</code> query parameter.</p>
</div>
<div class="paragraph">
<p>If the <code>_source</code> parameter is <code>false</code>, this parameter is ignored.</p>
</div>
</dd>
<dt class="hdlist1"><code>_source_includes</code></dt>
<dd>
<p>(Optional, string)
A comma-separated list of <a href="mapping-fields.html#mapping-source-field">source fields</a> to
include in the response.</p>
<div class="paragraph">
<p>If this parameter is specified, only these source fields are returned. You can
exclude fields from this subset using the <code>_source_excludes</code> query parameter.</p>
</div>
<div class="paragraph">
<p>If the <code>_source</code> parameter is <code>false</code>, this parameter is ignored.</p>
</div>
</dd>
<dt class="hdlist1"><code>version</code></dt>
<dd>
<p>(Optional, integer) Explicit version number for concurrency control.
The specified version must match the current version of the document for the
request to succeed.</p>
</dd>
<dt class="hdlist1"><code>version_type</code></dt>
<dd>
<p>(Optional, enum) Specific version type: <code>internal</code>, <code>external</code>,
<code>external_gte</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-get-api-response-body">Response body</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>_index</code></dt>
<dd>
<p>The name of the index the document belongs to.</p>
</dd>
<dt class="hdlist1"><code>_type</code></dt>
<dd>
<p>The document type. OpenSearch indices now support a single document type, <code>_doc</code>.</p>
</dd>
<dt class="hdlist1"><code>_id</code></dt>
<dd>
<p>The unique identifier for the document.</p>
</dd>
<dt class="hdlist1"><code>_version</code></dt>
<dd>
<p>The document version. Incremented each time the document is updated.</p>
</dd>
<dt class="hdlist1"><code>_seq_no</code></dt>
<dd>
<p>The sequence number assigned to the document for the indexing
operation. Sequence numbers are used to ensure an older version of a document
doesn’t overwrite a newer version. See <a href="docs.html#optimistic-concurrency-control-index">Optimistic concurrency control</a>.</p>
</dd>
<dt class="hdlist1"><code>_primary_term</code></dt>
<dd>
<p>The primary term assigned to the document for the indexing operation.
See <a href="docs.html#optimistic-concurrency-control-index">Optimistic concurrency control</a>.</p>
</dd>
<dt class="hdlist1"><code>found</code></dt>
<dd>
<p>Indicates whether the document exists: <code>true</code> or <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>_routing</code></dt>
<dd>
<p>The explicit routing, if set.</p>
</dd>
<dt class="hdlist1">'_source'</dt>
<dd>
<p>If <code>found</code> is <code>true</code>, contains the document data formatted in JSON.
Excluded if the <code>_source</code> parameter is set to <code>false</code> or the <code>stored_fields</code>
parameter is set to <code>true</code>.</p>
</dd>
<dt class="hdlist1">'_fields'</dt>
<dd>
<p>If the <code>stored_fields</code> parameter is set to <code>true</code> and <code>found</code> is
<code>true</code>, contains the document fields stored in the index.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-get-api-example">Examples</h4>
<div class="paragraph">
<p>Retrieve the JSON document with the <code>_id</code> 0 from the <code>my-index-000001</code> index:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET my-index-000001/_doc/0</code></pre>
</div>
</div>
<div class="paragraph">
<p>The API returns the following result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "_index": "my-index-000001",
  "_type": "_doc",
  "_id": "0",
  "_version": 1,
  "_seq_no": 0,
  "_primary_term": 1,
  "found": true,
  "_source": {
    "@timestamp": "2099-11-15T14:12:12",
    "http": {
      "request": {
        "method": "get"
      },
      "response": {
        "status_code": 200,
        "bytes": 1070000
      },
      "version": "1.1"
    },
    "source": {
      "ip": "127.0.0.1"
    },
    "message": "GET /search HTTP/1.1 200 1070000",
    "user": {
      "id": "bilbo"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Check to see if a document with the <code>_id</code> 0 exists:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">HEAD my-index-000001/_doc/0</code></pre>
</div>
</div>
<div class="paragraph">
<p>OpenSearch returns a status code of <code>200 - OK</code> if the document exists, or
<code>404 - Not Found</code> if it doesn&#8217;t.</p>
</div>
<h5 id="_source" class="discrete">Get the source field only</h5>
<div class="paragraph">
<p>Use the <code>&lt;index&gt;/_source/&lt;id&gt;</code> resource to get
just the <code>_source</code> field of a document. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET my-index-000001/_source/1</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use the source filtering parameters to control which parts of the
<code>_source</code> are returned:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET my-index-000001/_source/1/?_source_includes=*.id&amp;_source_excludes=entities</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use HEAD with the <code>_source</code> endpoint to efficiently
test whether or not the document _source exists. A document&#8217;s source is not
available if it is disabled in the <a href="mapping-fields.html#mapping-source-field">mapping</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">HEAD my-index-000001/_source/1</code></pre>
</div>
</div>
<h5 id="get-stored-fields" class="discrete">Get stored fields</h5>
<div class="paragraph">
<p>Use the <code>stored_fields</code> parameter to specify the set of stored fields you want
to retrieve. Any requested fields that are not stored are ignored.
Consider for instance the following mapping:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001
{
   "mappings": {
       "properties": {
          "counter": {
             "type": "integer",
             "store": false
          },
          "tags": {
             "type": "keyword",
             "store": true
          }
       }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can add a document:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001/_doc/1
{
  "counter": 1,
  "tags": [ "production" ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And then try to retrieve it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET my-index-000001/_doc/1?stored_fields=tags,counter</code></pre>
</div>
</div>
<div class="paragraph">
<p>The API returns the following result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
   "_index": "my-index-000001",
   "_type": "_doc",
   "_id": "1",
   "_version": 1,
   "_seq_no" : 22,
   "_primary_term" : 1,
   "found": true,
   "fields": {
      "tags": [
         "production"
      ]
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Field values fetched from the document itself are always returned as an array.
Since the <code>counter</code> field is not stored, the get request  ignores it.</p>
</div>
<div class="paragraph">
<p>You can also retrieve metadata fields like the <code>_routing</code> field:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT my-index-000001/_doc/2?routing=user1
{
  "counter" : 1,
  "tags" : ["env2"]
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET my-index-000001/_doc/2?routing=user1&amp;stored_fields=tags,counter</code></pre>
</div>
</div>
<div class="paragraph">
<p>The API returns the following result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
   "_index": "my-index-000001",
   "_type": "_doc",
   "_id": "2",
   "_version": 1,
   "_seq_no" : 13,
   "_primary_term" : 1,
   "_routing": "user1",
   "found": true,
   "fields": {
      "tags": [
         "env2"
      ]
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Only leaf fields can be retrieved with the <code>stored_field</code> option. Object fields
can&#8217;t be returned&#8212;&#8203;if specified, the request fails.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="docs-delete">Delete API</h3>
<titleabbrev>Delete</titleabbrev>
<div class="paragraph">
<p>Removes a JSON document from the specified index.</p>
</div>
<div class="sect3">
<h4 id="docs-delete-api-request">Request</h4>
<div class="paragraph">
<p><code>DELETE /&lt;index&gt;/_doc/&lt;_id&gt;</code></p>
</div>
</div>
<div class="sect3">
<h4 id="docs-delete-api-desc">Description</h4>
<div class="paragraph">
<p>You use DELETE to remove a document from an index. You must specify the
index name and document ID.</p>
</div>
<h5 id="optimistic-concurrency-control-delete" class="discrete">Optimistic concurrency control</h5>
<div class="paragraph">
<p>Delete operations can be made conditional and only be performed if the last
modification to the document was assigned the sequence number and primary
term specified by the <code>if_seq_no</code> and <code>if_primary_term</code> parameters. If a
mismatch is detected, the operation will result in a <code>VersionConflictException</code>
and a status code of 409. See <a href="docs.html#optimistic-concurrency-control">Optimistic concurrency control</a> for more details.</p>
</div>
<h5 id="delete-versioning" class="discrete">Versioning</h5>
<div class="paragraph">
<p>Each document indexed is versioned. When deleting a document, the <code>version</code> can
be specified to make sure the relevant document we are trying to delete is
actually being deleted and it has not changed in the meantime. Every write
operation executed on a document, deletes included, causes its version to be
incremented. The version number of a deleted document remains available for a
short time after deletion to allow for control of concurrent operations. The
length of time for which a deleted document&#8217;s version remains available is
determined by the <code>index.gc_deletes</code> index setting and defaults to 60 seconds.</p>
</div>
<h5 id="delete-routing" class="discrete">Routing</h5>
<div class="paragraph">
<p>If routing is used during indexing, the routing value also needs to be
specified to delete a document.</p>
</div>
<div class="paragraph">
<p>If the <code>_routing</code> mapping is set to <code>required</code> and no routing value is
specified, the delete API throws a <code>RoutingMissingException</code> and rejects
the request.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">DELETE /my-index-000001/_doc/1?routing=shard-1</code></pre>
</div>
</div>
<div class="paragraph">
<p>This request deletes the document with id <code>1</code>, but it is routed based on the
user. The document is not deleted if the correct routing is not specified.</p>
</div>
<h5 id="delete-index-creation" class="discrete">Automatic index creation</h5>
<div class="paragraph">
<p>If an <a href="docs.html#docs-index_">external versioning variant</a> is used,
the delete operation automatically creates the specified index if it does not
exist. For information about manually creating indices, see
<a href="indices.html#indices-create-index">create index API</a>.</p>
</div>
<h5 id="delete-distributed" class="discrete">Distributed</h5>
<div class="paragraph">
<p>The delete operation gets hashed into a specific shard id. It then gets
redirected into the primary shard within that id group, and replicated
(if needed) to shard replicas within that id group.</p>
</div>
<h5 id="delete-wait-for-active-shards" class="discrete">Wait for active shards</h5>
<div class="paragraph">
<p>When making delete requests, you can set the <code>wait_for_active_shards</code>
parameter to require a minimum number of shard copies to be active
before starting to process the delete request. See
<a href="docs.html#index-wait-for-active-shards">here</a> for further details and a usage
example.</p>
</div>
<h5 id="delete-refresh" class="discrete">Refresh</h5>
<div class="paragraph">
<p>Control when the changes made by this request are visible to search. See
<a href="docs.html#docs-refresh"><code>?refresh</code></a>.</p>
</div>
<h5 id="delete-timeout" class="discrete">Timeout</h5>
<div class="paragraph">
<p>The primary shard assigned to perform the delete operation might not be
available when the delete operation is executed. Some reasons for this
might be that the primary shard is currently recovering from a store
or undergoing relocation. By default, the delete operation will wait on
the primary shard to become available for up to 1 minute before failing
and responding with an error. The <code>timeout</code> parameter can be used to
explicitly specify how long it waits. Here is an example of setting it
to 5 minutes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">DELETE /my-index-000001/_doc/1?timeout=5m</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="docs-delete-api-path-params">Path parameters</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>&lt;index&gt;</code></dt>
<dd>
<p>(Required, string) Name of the target index.</p>
</dd>
<dt class="hdlist1"><code>&lt;_id&gt;</code></dt>
<dd>
<p>(Required, string) Unique identifier for the document.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-delete-api-query-params">Query parameters</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>if_seq_no</code></dt>
<dd>
<p>(Optional, integer) Only perform the operation if the document has this
sequence number. See <a href="docs.html#optimistic-concurrency-control-index">Optimistic concurrency control</a>.</p>
</dd>
<dt class="hdlist1"><code>if_primary_term</code></dt>
<dd>
<p>(Optional, integer) Only perform the operation if the document has
this primary term. See <a href="docs.html#optimistic-concurrency-control-index">Optimistic concurrency control</a>.</p>
</dd>
<dt class="hdlist1"><code>pipeline</code></dt>
<dd>
<p>(Optional, string) ID of the pipeline to use to preprocess incoming documents.</p>
</dd>
<dt class="hdlist1"><code>refresh</code></dt>
<dd>
<p>(Optional, enum) If <code>true</code>, OpenSearch refreshes the affected shards to make this
operation visible to search, if <code>wait_for</code> then wait for a refresh to make
this operation visible to search, if <code>false</code> do nothing with refreshes.
Valid values: <code>true</code>, <code>false</code>, <code>wait_for</code>. Default: <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>routing</code></dt>
<dd>
<p>(Optional, string) Target the specified primary shard.</p>
</dd>
<dt class="hdlist1"><code>timeout</code></dt>
<dd>
<p>(Optional, <a href="api-conventions.html#time-units">time units</a>)
Period to <a href="docs.html#index-wait-for-active-shards">wait for active shards</a>. Defaults to
<code>1m</code> (one minute).</p>
</dd>
<dt class="hdlist1"><code>version</code></dt>
<dd>
<p>(Optional, integer) Explicit version number for concurrency control.
The specified version must match the current version of the document for the
request to succeed.</p>
</dd>
<dt class="hdlist1"><code>version_type</code></dt>
<dd>
<p>(Optional, enum) Specific version type: <code>internal</code>, <code>external</code>,
<code>external_gte</code>.</p>
</dd>
<dt class="hdlist1"><code>wait_for_active_shards</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string) The number of shard copies that must be active before
proceeding with the operation. Set to <code>all</code> or any positive integer up
to the total number of shards in the index (<code>number_of_replicas+1</code>).
Default: 1, the primary shard.</p>
</div>
<div class="paragraph">
<p>See <a href="docs.html#index-wait-for-active-shards">Active shards</a>.</p>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-delete-api-example">Examples</h4>
<div class="paragraph">
<p>Delete the JSON document <code>1</code> from the <code>my-index-000001</code> index:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">DELETE /my-index-000001/_doc/1</code></pre>
</div>
</div>
<div class="paragraph">
<p>The API returns the following result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "_shards": {
    "total": 2,
    "failed": 0,
    "successful": 2
  },
  "_index": "my-index-000001",
  "_type": "_doc",
  "_id": "1",
  "_version": 2,
  "_primary_term": 1,
  "_seq_no": 5,
  "result": "deleted"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="docs-delete-by-query">Delete by query API</h3>
<titleabbrev>Delete by query</titleabbrev>
<div class="paragraph">
<p>Deletes documents that match the specified query.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /my-index-000001/_delete_by_query
{
  "query": {
    "match": {
      "user.id": "elkbee"
    }
  }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="docs-delete-by-query-api-request">Request</h4>
<div class="paragraph">
<p><code>POST /&lt;target&gt;/_delete_by_query</code></p>
</div>
</div>
<div class="sect3">
<h4 id="docs-delete-by-query-api-desc">Description</h4>
<div class="paragraph">
<p>You can specify the query criteria in the request URI or the request body
using the same syntax as the  <a href="search.html#search-search">Search API</a>.</p>
</div>
<div class="paragraph">
<p>When you submit a delete by query request, OpenSearch gets a snapshot of the index
when it begins processing the request and deletes matching documents using
<code>internal</code> versioning. If a document changes between the time that the
snapshot is taken and the delete operation is processed, it results in a version
conflict and the delete operation fails.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Documents with a version equal to 0 cannot be deleted using delete by
query because <code>internal</code> versioning does not support 0 as a valid
version number.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>While processing a delete by query request, OpenSearch performs multiple search
requests sequentially to find all of the matching documents to delete. A bulk
delete request is performed for each batch of matching documents. If a
search or bulk request is rejected, the requests are retried up to 10 times, with
exponential back off. If the maximum retry limit is reached, processing halts
and all failed requests are returned in the response. Any delete requests that
completed successfully still stick, they are not rolled back.</p>
</div>
<div class="paragraph">
<p>You can opt to count version conflicts instead of halting and returning by
setting <code>conflicts</code> to <code>proceed</code>.</p>
</div>
<div class="sect4">
<h5 id="_refreshing_shards">Refreshing shards</h5>
<div class="paragraph">
<p>Specifying the <code>refresh</code> parameter refreshes all shards involved in the delete
by query once the request completes. This is different than the delete API&#8217;s
<code>refresh</code> parameter, which causes just the shard that received the delete
request to be refreshed. Unlike the delete API, it does not support
<code>wait_for</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="docs-delete-by-query-task-api">Running delete by query asynchronously</h5>
<div class="paragraph">
<p>If the request contains <code>wait_for_completion=false</code>, OpenSearch
performs some preflight checks, launches the request, and returns a
<a href="cluster.html#tasks"><code>task</code></a> you can use to cancel or get the status of the task. OpenSearch creates a
record of this task as a document at <code>.tasks/task/${taskId}</code>. When you are
done with a task, you should delete the task document so OpenSearch can reclaim the
space.</p>
</div>
</div>
<div class="sect4">
<h5 id="_waiting_for_active_shards">Waiting for active shards</h5>
<div class="paragraph">
<p><code>wait_for_active_shards</code> controls how many copies of a shard must be active
before proceeding with the request. See <a href="docs.html#index-wait-for-active-shards">Active shards</a>
for details. <code>timeout</code> controls how long each write request waits for unavailable
shards to become available. Both work exactly the way they work in the
<a href="docs.html#docs-bulk">Bulk API</a>. Delete by query uses scrolled searches, so you can also
specify the <code>scroll</code> parameter to control how long it keeps the search context
alive, for example <code>?scroll=10m</code>. The default is 5 minutes.</p>
</div>
</div>
<div class="sect4">
<h5 id="_throttling_delete_requests">Throttling delete requests</h5>
<div class="paragraph">
<p>To control the rate at which delete by query issues batches of delete operations,
you can set <code>requests_per_second</code> to any positive decimal number. This pads each
batch with a wait time to throttle the rate. Set <code>requests_per_second</code> to <code>-1</code>
to disable throttling.</p>
</div>
<div class="paragraph">
<p>Throttling uses a wait time between batches so that the internal scroll requests
can be given a timeout that takes the request padding into account. The padding
time is the difference between the batch size divided by the
<code>requests_per_second</code> and the time spent writing.  By default the batch size is
<code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the batch is issued as a single <code>_bulk</code> request, large batch sizes
cause OpenSearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".</p>
</div>
</div>
<div class="sect4">
<h5 id="docs-delete-by-query-slice">Slicing</h5>
<div class="paragraph">
<p>Delete by query supports <a href="paginate-search-results.html#slice-scroll">sliced scroll</a> to parallelize the
delete process. This can improve efficiency and provide a
convenient way to break the request down into smaller parts.</p>
</div>
<div class="paragraph">
<p>Setting <code>slices</code> to <code>auto</code> chooses a reasonable number for most indices.
If you&#8217;re slicing manually or otherwise tuning automatic slicing, keep in mind
that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Query performance is most efficient when the number of <code>slices</code> is equal to
the number of shards in the index. If that number is large (for example,
500), choose a lower number as too many <code>slices</code> hurts performance. Setting
<code>slices</code> higher than the number of shards generally does not improve efficiency
and adds overhead.</p>
</li>
<li>
<p>Delete performance scales linearly across available resources with the
number of slices.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Whether query or delete performance dominates the runtime depends on the
documents being reindexed and cluster resources.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="docs-delete-by-query-api-path-params">Path parameters</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>&lt;target&gt;</code></dt>
<dd>
<p>(Optional, string)
Comma-separated list of indices and index aliases to search.
Wildcard (<code>*</code>) expressions are supported.</p>
<div class="paragraph">
<p>To search all indices in a cluster, omit this parameter or use
<code>_all</code> or <code>*</code>.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-delete-by-query-api-query-params">Query parameters</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>allow_no_indices</code></dt>
<dd>
<p>(Optional, Boolean)
If <code>false</code>, the request returns an error if any wildcard expression,
<a href="indices.html#indices-aliases">index alias</a>, or <code>_all</code> value targets only missing or closed
indices. This behavior applies even if the request targets other open indices.
For example, a request targeting <code>foo*,bar*</code> returns an error if an index
starts with <code>foo</code> but no index starts with <code>bar</code>.</p>
<div class="paragraph">
<p>Defaults to <code>true</code>.</p>
</div>
</dd>
<dt class="hdlist1"><code>analyzer</code></dt>
<dd>
<p>(Optional, string) Analyzer to use for the query string.</p>
</dd>
<dt class="hdlist1"><code>analyze_wildcard</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, wildcard and prefix queries are
analyzed. Defaults to <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>conflicts</code></dt>
<dd>
<p>(Optional, string) What to do if delete by query hits version conflicts:
<code>abort</code> or <code>proceed</code>. Defaults to <code>abort</code>.</p>
</dd>
<dt class="hdlist1"><code>default_operator</code></dt>
<dd>
<p>(Optional, string) The default operator for query string query: AND or OR.
Defaults to <code>OR</code>.</p>
</dd>
<dt class="hdlist1"><code>df</code></dt>
<dd>
<p>(Optional, string) Field to use as default where no field prefix is
given in the query string.</p>
</dd>
<dt class="hdlist1"><code>expand_wildcards</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string) Controls what kind of indices that wildcard expressions can
expand to. Multiple values are accepted when separated by a comma, as in
<code>open,hidden</code>. Valid values are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>all</code></dt>
<dd>
<p>Expand to open and closed indices, including <a href="api-conventions.html#hidden-indices">hidden indices</a>.</p>
</dd>
<dt class="hdlist1"><code>open</code></dt>
<dd>
<p>Expand only to open indices.</p>
</dd>
<dt class="hdlist1"><code>closed</code></dt>
<dd>
<p>Expand only to closed indices.</p>
</dd>
<dt class="hdlist1"><code>hidden</code></dt>
<dd>
<p>Expansion of wildcards will include hidden indices.
Must be combined with <code>open</code>, <code>closed</code>, or both.</p>
</dd>
<dt class="hdlist1"><code>none</code></dt>
<dd>
<p>Wildcard expressions are not accepted.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>Defaults to <code>open</code>.</p>
</div>
</dd>
<dt class="hdlist1"><code>from</code></dt>
<dd>
<p>(Optional, integer) Starting document offset. Defaults to <code>0</code>.</p>
</dd>
<dt class="hdlist1"><code>ignore_unavailable</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, missing or closed indices are not included in the
response. Defaults to <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>lenient</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, format-based query failures (such as
providing text to a numeric field) will be ignored. Defaults to <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>max_docs</code></dt>
<dd>
<p>(Optional, integer) Maximum number of documents to process. Defaults to all
documents.</p>
</dd>
<dt class="hdlist1"><code>preference</code></dt>
<dd>
<p>(Optional, string) Specifies the node or shard the operation should be
performed on. Random by default.</p>
</dd>
<dt class="hdlist1"><code>q</code></dt>
<dd>
<p>(Optional, string) Query in the Lucene query string syntax.</p>
</dd>
<dt class="hdlist1"><code>request_cache</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, the request cache is used for this request.
Defaults to the index-level setting.</p>
</dd>
<dt class="hdlist1"><code>refresh</code></dt>
<dd>
<p>(Optional, enum) If <code>true</code>, OpenSearch refreshes the affected shards to make this
operation visible to search, if <code>wait_for</code> then wait for a refresh to make
this operation visible to search, if <code>false</code> do nothing with refreshes.
Valid values: <code>true</code>, <code>false</code>, <code>wait_for</code>. Default: <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>requests_per_second</code></dt>
<dd>
<p>(Optional, integer) The throttle for this request in sub-requests per second.
Defaults to <code>-1</code> (no throttle).</p>
</dd>
<dt class="hdlist1"><code>routing</code></dt>
<dd>
<p>(Optional, string) Target the specified primary shard.</p>
</dd>
<dt class="hdlist1"><code>scroll</code></dt>
<dd>
<p>(Optional, <a href="api-conventions.html#time-units">time value</a>)
Period to retain the <a href="paginate-search-results.html#scroll-search-context">search context</a> for scrolling. See
<a href="paginate-search-results.html#scroll-search-results">Scroll search results</a>.</p>
</dd>
<dt class="hdlist1"><code>scroll_size</code></dt>
<dd>
<p>(Optional, integer) Size of the scroll request that powers the operation.
Defaults to 1000.</p>
</dd>
<dt class="hdlist1"><code>search_type</code></dt>
<dd>
<p>(Optional, string) The type of the search operation. Available options:</p>
<div class="ulist">
<ul>
<li>
<p><code>query_then_fetch</code></p>
</li>
<li>
<p><code>dfs_query_then_fetch</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code>search_timeout</code></dt>
<dd>
<p>(Optional, <a href="api-conventions.html#time-units">time units</a>)
Explicit timeout for each search request.
Defaults to no timeout.</p>
</dd>
<dt class="hdlist1"><code>slices</code></dt>
<dd>
<p>(Optional, integer) The number of slices this task should be divided into.
Defaults to 1 meaning the task isn&#8217;t sliced into subtasks.</p>
</dd>
<dt class="hdlist1"><code>sort</code></dt>
<dd>
<p>(Optional, string) A comma-separated list of &lt;field&gt;:&lt;direction&gt; pairs.</p>
</dd>
<dt class="hdlist1"><code>_source</code></dt>
<dd>
<p>(Optional, string) True or false to return the <code>_source</code> field or not, or a
list of fields to return.</p>
</dd>
<dt class="hdlist1"><code>_source_excludes</code></dt>
<dd>
<p>(Optional, string)
A comma-separated list of <a href="mapping-fields.html#mapping-source-field">source fields</a> to exclude from
the response.</p>
<div class="paragraph">
<p>You can also use this parameter to exclude fields from the subset specified in
<code>_source_includes</code> query parameter.</p>
</div>
<div class="paragraph">
<p>If the <code>_source</code> parameter is <code>false</code>, this parameter is ignored.</p>
</div>
</dd>
<dt class="hdlist1"><code>_source_includes</code></dt>
<dd>
<p>(Optional, string)
A comma-separated list of <a href="mapping-fields.html#mapping-source-field">source fields</a> to
include in the response.</p>
<div class="paragraph">
<p>If this parameter is specified, only these source fields are returned. You can
exclude fields from this subset using the <code>_source_excludes</code> query parameter.</p>
</div>
<div class="paragraph">
<p>If the <code>_source</code> parameter is <code>false</code>, this parameter is ignored.</p>
</div>
</dd>
<dt class="hdlist1"><code>stats</code></dt>
<dd>
<p>(Optional, string) Specific <code>tag</code> of the request for logging and statistical
purposes.</p>
</dd>
<dt class="hdlist1"><code>terminate_after</code></dt>
<dd>
<p>(Optional, integer) The maximum number of documents to collect for each shard,
upon reaching which the query execution will terminate early.</p>
</dd>
<dt class="hdlist1"><code>timeout</code></dt>
<dd>
<p>(Optional, <a href="api-conventions.html#time-units">time units</a>)
Period each deletion request <a href="docs.html#index-wait-for-active-shards">waits for active
shards</a>. Defaults to <code>1m</code> (one minute).</p>
</dd>
<dt class="hdlist1"><code>version</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, returns the document version as part of a hit.</p>
</dd>
<dt class="hdlist1"><code>wait_for_active_shards</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string) The number of shard copies that must be active before
proceeding with the operation. Set to <code>all</code> or any positive integer up
to the total number of shards in the index (<code>number_of_replicas+1</code>).
Default: 1, the primary shard.</p>
</div>
<div class="paragraph">
<p>See <a href="docs.html#index-wait-for-active-shards">Active shards</a>.</p>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-delete-by-query-api-request-body">Request body</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>query</code></dt>
<dd>
<p>(Optional, <a href="query-dsl.html">query object</a>) Specifies the documents to delete
using the  <a href="query-dsl.html">Query DSL</a>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-delete-by-query-api-response-body">Response body</h4>
<div class="paragraph">
<p>The JSON response looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "took" : 147,
  "timed_out": false,
  "total": 119,
  "deleted": 119,
  "batches": 1,
  "version_conflicts": 0,
  "noops": 0,
  "retries": {
    "bulk": 0,
    "search": 0
  },
  "throttled_millis": 0,
  "requests_per_second": -1.0,
  "throttled_until_millis": 0,
  "failures" : [ ]
}</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>took</code></dt>
<dd>
<p>The number of milliseconds from start to end of the whole operation.</p>
</dd>
<dt class="hdlist1"><code>timed_out</code></dt>
<dd>
<p>This flag is set to <code>true</code> if any of the requests executed during the
delete by query execution has timed out.</p>
</dd>
<dt class="hdlist1"><code>total</code></dt>
<dd>
<p>The number of documents that were successfully processed.</p>
</dd>
<dt class="hdlist1"><code>deleted</code></dt>
<dd>
<p>The number of documents that were successfully deleted.</p>
</dd>
<dt class="hdlist1"><code>batches</code></dt>
<dd>
<p>The number of scroll responses pulled back by the delete by query.</p>
</dd>
<dt class="hdlist1"><code>version_conflicts</code></dt>
<dd>
<p>The number of version conflicts that the delete by query hit.</p>
</dd>
<dt class="hdlist1"><code>noops</code></dt>
<dd>
<p>This field is always equal to zero for delete by query. It only exists
so that delete by query, update by query, and reindex APIs return responses
 with the same structure.</p>
</dd>
<dt class="hdlist1"><code>retries</code></dt>
<dd>
<p>The number of retries attempted by delete by query. <code>bulk</code> is the number
of bulk actions retried, and <code>search</code> is the number of search actions retried.</p>
</dd>
<dt class="hdlist1"><code>throttled_millis</code></dt>
<dd>
<p>Number of milliseconds the request slept to conform to <code>requests_per_second</code>.</p>
</dd>
<dt class="hdlist1"><code>requests_per_second</code></dt>
<dd>
<p>The number of requests per second effectively executed during the delete by query.</p>
</dd>
<dt class="hdlist1"><code>throttled_until_millis</code></dt>
<dd>
<p>This field should always be equal to zero in a <code>_delete_by_query</code> response. It only
has meaning when using the <a href="cluster.html#tasks">Task API</a>, where it
indicates the next time (in milliseconds since epoch) a throttled request will be
executed again in order to conform to <code>requests_per_second</code>.</p>
</dd>
<dt class="hdlist1"><code>failures</code></dt>
<dd>
<p>Array of failures if there were any unrecoverable errors during the process. If
this is non-empty then the request aborted because of those failures.
Delete by query is implemented using batches, and any failure causes the entire
process to abort but all failures in the current batch are collected into the
array. You can use the <code>conflicts</code> option to prevent reindex from aborting on
version conflicts.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-delete-by-query-api-example">Examples</h4>
<div class="paragraph">
<p>Delete all documents from the <code>my-index-000001</code> index:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST my-index-000001/_delete_by_query?conflicts=proceed
{
  "query": {
    "match_all": {}
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Delete documents from multiple indices:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /my-index-000001,my-index-000002/_delete_by_query
{
  "query": {
    "match_all": {}
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Limit the delete by query operation to shards that a particular routing
value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST my-index-000001/_delete_by_query?routing=1
{
  "query": {
    "range" : {
        "age" : {
           "gte" : 10
        }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default <code>_delete_by_query</code> uses scroll batches of 1000. You can change the
batch size with the <code>scroll_size</code> URL parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST my-index-000001/_delete_by_query?scroll_size=5000
{
  "query": {
    "term": {
      "user.id": "bilbo"
    }
  }
}</code></pre>
</div>
</div>
<h5 id="docs-delete-by-query-manual-slice" class="discrete">Slice manually</h5>
<div class="paragraph">
<p>Slice a delete by query manually by providing a slice id and total number of
slices:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST my-index-000001/_delete_by_query
{
  "slice": {
    "id": 0,
    "max": 2
  },
  "query": {
    "range": {
      "http.response.bytes": {
        "lt": 2000000
      }
    }
  }
}
POST my-index-000001/_delete_by_query
{
  "slice": {
    "id": 1,
    "max": 2
  },
  "query": {
    "range": {
      "http.response.bytes": {
        "lt": 2000000
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which you can verify works with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET _refresh
POST my-index-000001/_search?size=0&amp;filter_path=hits.total
{
  "query": {
    "range": {
      "http.response.bytes": {
        "lt": 2000000
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which results in a sensible <code>total</code> like this one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "hits": {
    "total" : {
        "value": 0,
        "relation": "eq"
    }
  }
}</code></pre>
</div>
</div>
<h5 id="docs-delete-by-query-automatic-slice" class="discrete">Use automatic slicing</h5>
<div class="paragraph">
<p>You can also let delete-by-query automatically parallelize using
<a href="paginate-search-results.html#slice-scroll">sliced scroll</a> to slice on <code>_id</code>. Use <code>slices</code> to specify
the number of slices to use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST my-index-000001/_delete_by_query?refresh&amp;slices=5
{
  "query": {
    "range": {
      "http.response.bytes": {
        "lt": 2000000
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which you also can verify works with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST my-index-000001/_search?size=0&amp;filter_path=hits.total
{
  "query": {
    "range": {
      "http.response.bytes": {
        "lt": 2000000
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which results in a sensible <code>total</code> like this one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "hits": {
    "total" : {
        "value": 0,
        "relation": "eq"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Setting <code>slices</code> to <code>auto</code> will let OpenSearch choose the number of slices
to use. This setting will use one slice per shard, up to a certain limit. If
there are multiple source indices, it will choose the number of slices based
on the index with the smallest number of shards.</p>
</div>
<div class="paragraph">
<p>Adding <code>slices</code> to <code>_delete_by_query</code> just automates the manual process used in
the section above, creating sub-requests which means it has some quirks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You can see these requests in the
<a href="cluster.html#tasks">Tasks APIs</a>. These sub-requests are "child"
tasks of the task for the request with <code>slices</code>.</p>
</li>
<li>
<p>Fetching the status of the task for the request with <code>slices</code> only contains
the status of completed slices.</p>
</li>
<li>
<p>These sub-requests are individually addressable for things like cancellation
and rethrottling.</p>
</li>
<li>
<p>Rethrottling the request with <code>slices</code> will rethrottle the unfinished
sub-request proportionally.</p>
</li>
<li>
<p>Canceling the request with <code>slices</code> will cancel each sub-request.</p>
</li>
<li>
<p>Due to the nature of <code>slices</code> each sub-request won&#8217;t get a perfectly even
portion of the documents. All documents will be addressed, but some slices may
be larger than others. Expect larger slices to have a more even distribution.</p>
</li>
<li>
<p>Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with
slices` are distributed proportionally to each sub-request. Combine that with
the point above about distribution being uneven and you should conclude that
using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents
being deleted.</p>
</li>
<li>
<p>Each sub-request gets a slightly different snapshot of the source index
though these are all taken at approximately the same time.</p>
</li>
</ul>
</div>
<h5 id="docs-delete-by-query-rethrottle" class="discrete">Change throttling for a request</h5>
<div class="paragraph">
<p>The value of <code>requests_per_second</code> can be changed on a running delete by query
using the <code>_rethrottle</code> API. Rethrottling that speeds up the
query takes effect immediately but rethrotting that slows down the query
takes effect after completing the current batch to prevent scroll
timeouts.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _delete_by_query/r1A2WoRbTwKZ516z6NEs5A:36619/_rethrottle?requests_per_second=-1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use the <a href="cluster.html#tasks">tasks API</a> to get the task ID. Set <code>requests_per_second</code>
to any positive decimal value or <code>-1</code> to disable throttling.</p>
</div>
<div class="sect4">
<h5 id="_get_the_status_of_a_delete_by_query_operation">Get the status of a delete by query operation</h5>
<div class="paragraph">
<p>Use the <a href="cluster.html#tasks">tasks API</a> to get the status of a delete by query
operation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET _tasks?detailed=true&amp;actions=*/delete/byquery</code></pre>
</div>
</div>
<div class="paragraph">
<p>The response looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "nodes" : {
    "r1A2WoRbTwKZ516z6NEs5A" : {
      "name" : "r1A2WoR",
      "transport_address" : "127.0.0.1:9300",
      "host" : "127.0.0.1",
      "ip" : "127.0.0.1:9300",
      "attributes" : {
        "testattr" : "test",
        "portsfile" : "true"
      },
      "tasks" : {
        "r1A2WoRbTwKZ516z6NEs5A:36619" : {
          "node" : "r1A2WoRbTwKZ516z6NEs5A",
          "id" : 36619,
          "type" : "transport",
          "action" : "indices:data/write/delete/byquery",
          "status" : {    <b class="conum">(1)</b>
            "total" : 6154,
            "updated" : 0,
            "created" : 0,
            "deleted" : 3500,
            "batches" : 36,
            "version_conflicts" : 0,
            "noops" : 0,
            "retries": 0,
            "throttled_millis": 0
          },
          "description" : ""
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This object contains the actual status. It is just like the response JSON
with the important addition of the <code>total</code> field. <code>total</code> is the total number
of operations that the reindex expects to perform. You can estimate the
progress by adding the <code>updated</code>, <code>created</code>, and <code>deleted</code> fields. The request
will finish when their sum is equal to the <code>total</code> field.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>With the task id you can look up the task directly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_tasks/r1A2WoRbTwKZ516z6NEs5A:36619</code></pre>
</div>
</div>
<div class="paragraph">
<p>The advantage of this API is that it integrates with <code>wait_for_completion=false</code>
to transparently return the status of completed tasks. If the task is completed
and <code>wait_for_completion=false</code> was set on it then it&#8217;ll come back with
<code>results</code> or an <code>error</code> field. The cost of this feature is the document that
<code>wait_for_completion=false</code> creates at <code>.tasks/task/${taskId}</code>. It is up to
you to delete that document.</p>
</div>
<h5 id="docs-delete-by-query-cancel-task-api" class="discrete">Cancel a delete by query operation</h5>
<div class="paragraph">
<p>Any delete by query can be canceled using the <a href="cluster.html#tasks">task cancel API</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel</code></pre>
</div>
</div>
<div class="paragraph">
<p>The task ID can be found using the <a href="cluster.html#tasks">tasks API</a>.</p>
</div>
<div class="paragraph">
<p>Cancellation should happen quickly but might take a few seconds. The task status
API above will continue to list the delete by query task until this task checks that it
has been cancelled and terminates itself.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="docs-update">Update API</h3>
<titleabbrev>Update</titleabbrev>
<div class="paragraph">
<p>Updates a document using the specified script.</p>
</div>
<div class="sect3">
<h4 id="docs-update-api-request">Request</h4>
<div class="paragraph">
<p><code>POST /&lt;index&gt;/_update/&lt;_id&gt;</code></p>
</div>
</div>
<div class="sect3">
<h4 id="update-api-desc">Description</h4>
<div class="paragraph">
<p>Enables you to script document updates. The script can update, delete, or skip
modifying the document. The update API also supports passing a partial document,
which is merged into the existing document. To fully replace an existing
document, use the <a href="docs.html#docs-index_"><code>index</code> API</a>.</p>
</div>
<div class="paragraph">
<p>This operation:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Gets the document (collocated with the shard) from the index.</p>
</li>
<li>
<p>Runs the specified script.</p>
</li>
<li>
<p>Indexes the result.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The document must still be reindexed, but using <code>update</code> removes some network
roundtrips and reduces chances of version conflicts between the GET and the
index operation.</p>
</div>
<div class="paragraph">
<p>The <code>_source</code> field must be enabled to use <code>update</code>. In addition to <code>_source</code>,
you can access the following variables through the <code>ctx</code> map: <code>_index</code>,
<code>_type</code>, <code>_id</code>, <code>_version</code>, <code>_routing</code>, and <code>_now</code> (the current timestamp).</p>
</div>
</div>
<div class="sect3">
<h4 id="docs-update-api-path-params">Path parameters</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>&lt;index&gt;</code></dt>
<dd>
<p>(Required, string) Name of the target index. By default, the index is created
automatically if it doesn&#8217;t exist. For more information, see <a href="docs.html#index-creation">Automatically create indices</a>.</p>
</dd>
<dt class="hdlist1"><code>&lt;_id&gt;</code></dt>
<dd>
<p>(Required, string) Unique identifier for the document to be updated.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-update-api-query-params">Query parameters</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>if_seq_no</code></dt>
<dd>
<p>(Optional, integer) Only perform the operation if the document has this
sequence number. See <a href="docs.html#optimistic-concurrency-control-index">Optimistic concurrency control</a>.</p>
</dd>
<dt class="hdlist1"><code>if_primary_term</code></dt>
<dd>
<p>(Optional, integer) Only perform the operation if the document has
this primary term. See <a href="docs.html#optimistic-concurrency-control-index">Optimistic concurrency control</a>.</p>
</dd>
<dt class="hdlist1"><code>lang</code></dt>
<dd>
<p>(Optional, string) The script language. Default: <code>painless</code>.</p>
</dd>
<dt class="hdlist1"><code>require_alias</code></dt>
<dd>
<p>(Optional, Boolean)
If <code>true</code>, the destination must be an <a href="indices.html#indices-aliases">index alias</a>. Defaults to
<code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>refresh</code></dt>
<dd>
<p>(Optional, enum) If <code>true</code>, OpenSearch refreshes the affected shards to make this
operation visible to search, if <code>wait_for</code> then wait for a refresh to make
this operation visible to search, if <code>false</code> do nothing with refreshes.
Valid values: <code>true</code>, <code>false</code>, <code>wait_for</code>. Default: <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>retry_on_conflict</code></dt>
<dd>
<p>(Optional, integer) Specify how many times should the operation be retried when
 a conflict occurs. Default: 0.</p>
</dd>
<dt class="hdlist1"><code>routing</code></dt>
<dd>
<p>(Optional, string) Target the specified primary shard.</p>
</dd>
<dt class="hdlist1"><code>_source</code></dt>
<dd>
<p>(Optional, list) Set to <code>false</code> to disable source retrieval (default: <code>true</code>).
You can also specify a comma-separated list of the fields you want to retrieve.</p>
</dd>
<dt class="hdlist1"><code>_source_excludes</code></dt>
<dd>
<p>(Optional, list) Specify the source fields you want to exclude.</p>
</dd>
<dt class="hdlist1"><code>_source_includes</code></dt>
<dd>
<p>(Optional, list) Specify the source fields you want to retrieve.</p>
</dd>
<dt class="hdlist1"><code>timeout</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, <a href="api-conventions.html#time-units">time units</a>)
Period to wait for the following operations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="dynamic-mapping.html">Dynamic mapping</a> updates</p>
</li>
<li>
<p><a href="docs.html#index-wait-for-active-shards">Waiting for active shards</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Defaults to <code>1m</code> (one minute). This guarantees OpenSearch waits for at least the
timeout before failing. The actual wait time could be longer, particularly when
multiple waits occur.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>wait_for_active_shards</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string) The number of shard copies that must be active before
proceeding with the operation. Set to <code>all</code> or any positive integer up
to the total number of shards in the index (<code>number_of_replicas+1</code>).
Default: 1, the primary shard.</p>
</div>
<div class="paragraph">
<p>See <a href="docs.html#index-wait-for-active-shards">Active shards</a>.</p>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="update-api-example">Examples</h4>
<div class="paragraph">
<p>First, let&#8217;s index a simple doc:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT test/_doc/1
{
  "counter" : 1,
  "tags" : ["red"]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To increment the counter, you can submit an update request with the
following script:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST test/_update/1
{
  "script" : {
    "source": "ctx._source.counter += params.count",
    "lang": "painless",
    "params" : {
      "count" : 4
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, you could use and update script to add a tag to the list of tags
(this is just a list, so the tag is added even it exists):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST test/_update/1
{
  "script": {
    "source": "ctx._source.tags.add(params.tag)",
    "lang": "painless",
    "params": {
      "tag": "blue"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You could also remove a tag from the list of tags. The Painless
function to <code>remove</code> a tag takes the array index of the element
you want to remove. To avoid a possible runtime error, you first need to
make sure the tag exists. If the list contains duplicates of the tag, this
script just removes one occurrence.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST test/_update/1
{
  "script": {
    "source": "if (ctx._source.tags.contains(params.tag)) { ctx._source.tags.remove(ctx._source.tags.indexOf(params.tag)) }",
    "lang": "painless",
    "params": {
      "tag": "blue"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also add and remove fields from a document. For example, this script
adds the field <code>new_field</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST test/_update/1
{
  "script" : "ctx._source.new_field = 'value_of_new_field'"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Conversely, this script removes the field <code>new_field</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST test/_update/1
{
  "script" : "ctx._source.remove('new_field')"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of updating the document, you can also change the operation that is
executed from within the script.  For example, this request deletes the doc if
the <code>tags</code> field contains <code>green</code>, otherwise it does nothing (<code>noop</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST test/_update/1
{
  "script": {
    "source": "if (ctx._source.tags.contains(params.tag)) { ctx.op = 'delete' } else { ctx.op = 'none' }",
    "lang": "painless",
    "params": {
      "tag": "green"
    }
  }
}</code></pre>
</div>
</div>
<h5 id="_update_part_of_a_document" class="discrete">Update part of a document</h5>
<div class="paragraph">
<p>The following partial update adds a new field to the
existing document:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST test/_update/1
{
  "doc": {
    "name": "new_name"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If both <code>doc</code> and <code>script</code> are specified, then <code>doc</code> is ignored. If you
specify a scripted update, include the fields you want to update in the script.</p>
</div>
<h5 id="_detect_noop_updates" class="discrete">Detect noop updates</h5>
<div class="paragraph">
<p>By default updates that don&#8217;t change anything detect that they don&#8217;t change
anything and return <code>"result": "noop"</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST test/_update/1
{
  "doc": {
    "name": "new_name"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the value of <code>name</code> is already <code>new_name</code>, the update
request is ignored and the <code>result</code> element in the response returns <code>noop</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
   "_shards": {
        "total": 0,
        "successful": 0,
        "failed": 0
   },
   "_index": "test",
   "_type": "_doc",
   "_id": "1",
   "_version": 7,
   "_primary_term": 1,
   "_seq_no": 6,
   "result": "noop"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can disable this behavior by setting <code>"detect_noop": false</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST test/_update/1
{
  "doc": {
    "name": "new_name"
  },
  "detect_noop": false
}</code></pre>
</div>
</div>
<h5 id="upserts" class="discrete">Upsert</h5>
<div class="paragraph">
<p>If the document does not already exist, the contents of the <code>upsert</code> element
are inserted as a new document.  If the document exists, the
<code>script</code> is executed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST test/_update/1
{
  "script": {
    "source": "ctx._source.counter += params.count",
    "lang": "painless",
    "params": {
      "count": 4
    }
  },
  "upsert": {
    "counter": 1
  }
}</code></pre>
</div>
</div>
<h5 id="scripted_upsert" class="discrete">Scripted upsert</h5>
<div class="paragraph">
<p>To run the script whether or not the document exists, set <code>scripted_upsert</code> to
<code>true</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST sessions/_update/dh3sgudg8gsrgl
{
  "scripted_upsert": true,
  "script": {
    "id": "my_web_session_summariser",
    "params": {
      "pageViewEvent": {
        "url": "foo.com/bar",
        "response": 404,
        "time": "2014-01-01 12:32"
      }
    }
  },
  "upsert": {}
}</code></pre>
</div>
</div>
<h5 id="doc_as_upsert" class="discrete">Doc as upsert</h5>
<div class="paragraph">
<p>Instead of sending a partial <code>doc</code> plus an <code>upsert</code> doc, you can set
<code>doc_as_upsert</code> to <code>true</code> to use the contents of <code>doc</code> as the <code>upsert</code>
value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST test/_update/1
{
  "doc": {
    "name": "new_name"
  },
  "doc_as_upsert": true
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Using <a href="ingest.html">ingest pipelines</a> with <code>doc_as_upsert</code> is not supported.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="docs-update-by-query">Update By Query API</h3>
<titleabbrev>Update by query</titleabbrev>
<div class="paragraph">
<p>Updates documents that match the specified query.
If no query is specified, performs an update on every document in the index without
modifying the source, which is useful for picking up mapping changes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST my-index-000001/_update_by_query?conflicts=proceed</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="docs-update-by-query-api-request">Request</h4>
<div class="paragraph">
<p><code>POST /&lt;target&gt;/_update_by_query</code></p>
</div>
</div>
<div class="sect3">
<h4 id="docs-update-by-query-api-desc">Description</h4>
<div class="paragraph">
<p>You can specify the query criteria in the request URI or the request body
using the same syntax as the  <a href="search.html#search-search">Search API</a>.</p>
</div>
<div class="paragraph">
<p>When you submit an update by query request, OpenSearch gets a snapshot of the index
when it begins processing the request and updates matching documents using
<code>internal</code> versioning.
When the versions match, the document is updated and the version number is incremented.
If a document changes between the time that the snapshot is taken and
the update operation is processed, it results in a version conflict and the operation fails.
You can opt to count version conflicts instead of halting and returning by
setting <code>conflicts</code> to <code>proceed</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Documents with a version equal to 0 cannot be updated using update by
query because <code>internal</code> versioning does not support 0 as a valid
version number.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>While processing an update by query request, OpenSearch performs multiple search
requests sequentially to find all of the matching documents.
A bulk update request is performed for each batch of matching documents.
Any query or update failures cause the update by query request to fail and
the failures are shown in the response.
Any update requests that completed successfully still stick, they are not rolled back.</p>
</div>
<div class="sect4">
<h5 id="_refreshing_shards_2">Refreshing shards</h5>
<div class="paragraph">
<p>Specifying the <code>refresh</code> parameter refreshes all shards once the request completes.
This is different than the update API&#8217;s <code>refresh</code> parameter, which causes just the shard
that received the request to be refreshed. Unlike the update API, it does not support
<code>wait_for</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="docs-update-by-query-task-api">Running update by query asynchronously</h5>
<div class="paragraph">
<p>If the request contains <code>wait_for_completion=false</code>, OpenSearch
performs some preflight checks, launches the request, and returns a
<a href="cluster.html#tasks"><code>task</code></a> you can use to cancel or get the status of the task.
OpenSearch creates a record of this task as a document at <code>.tasks/task/${taskId}</code>.
When you are done with a task, you should delete the task document so
OpenSearch can reclaim the space.</p>
</div>
</div>
<div class="sect4">
<h5 id="_waiting_for_active_shards_2">Waiting for active shards</h5>
<div class="paragraph">
<p><code>wait_for_active_shards</code> controls how many copies of a shard must be active
before proceeding with the request. See <a href="docs.html#index-wait-for-active-shards">Active shards</a>
for details. <code>timeout</code> controls how long each write request waits for unavailable
shards to become available. Both work exactly the way they work in the
<a href="docs.html#docs-bulk">Bulk API</a>. Update by query uses scrolled searches, so you can also
specify the <code>scroll</code> parameter to control how long it keeps the search context
alive, for example <code>?scroll=10m</code>. The default is 5 minutes.</p>
</div>
</div>
<div class="sect4">
<h5 id="_throttling_update_requests">Throttling update requests</h5>
<div class="paragraph">
<p>To control the rate at which update by query issues batches of update operations,
you can set <code>requests_per_second</code> to any positive decimal number. This pads each
batch with a wait time to throttle the rate. Set <code>requests_per_second</code> to <code>-1</code>
to disable throttling.</p>
</div>
<div class="paragraph">
<p>Throttling uses a wait time between batches so that the internal scroll requests
can be given a timeout that takes the request padding into account. The padding
time is the difference between the batch size divided by the
<code>requests_per_second</code> and the time spent writing.  By default the batch size is
<code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the batch is issued as a single <code>_bulk</code> request, large batch sizes
cause OpenSearch to create many requests and wait before starting the next set.
This is "bursty" instead of "smooth".</p>
</div>
</div>
<div class="sect4">
<h5 id="docs-update-by-query-slice">Slicing</h5>
<div class="paragraph">
<p>Update by query supports <a href="paginate-search-results.html#slice-scroll">sliced scroll</a> to parallelize the
update process. This can improve efficiency and provide a
convenient way to break the request down into smaller parts.</p>
</div>
<div class="paragraph">
<p>Setting <code>slices</code> to <code>auto</code> chooses a reasonable number for most indices.
If you&#8217;re slicing manually or otherwise tuning automatic slicing, keep in mind
that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Query performance is most efficient when the number of <code>slices</code> is equal to
the number of shards in the index. If that number is large (for example,
500), choose a lower number as too many <code>slices</code> hurts performance. Setting
<code>slices</code> higher than the number of shards generally does not improve efficiency
and adds overhead.</p>
</li>
<li>
<p>Update performance scales linearly across available resources with the
number of slices.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Whether query or update performance dominates the runtime depends on the
documents being reindexed and cluster resources.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="docs-update-by-query-api-path-params">Path parameters</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>&lt;target&gt;</code></dt>
<dd>
<p>(Optional, string)
Comma-separated list of indices and index aliases to search.
Wildcard (<code>*</code>) expressions are supported.</p>
<div class="paragraph">
<p>To search all indices in a cluster, omit this parameter or use
<code>_all</code> or <code>*</code>.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-update-by-query-api-query-params">Query parameters</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>allow_no_indices</code></dt>
<dd>
<p>(Optional, Boolean)
If <code>false</code>, the request returns an error if any wildcard expression,
<a href="indices.html#indices-aliases">index alias</a>, or <code>_all</code> value targets only missing or closed
indices. This behavior applies even if the request targets other open indices.
For example, a request targeting <code>foo*,bar*</code> returns an error if an index
starts with <code>foo</code> but no index starts with <code>bar</code>.</p>
<div class="paragraph">
<p>Defaults to <code>true</code>.</p>
</div>
</dd>
<dt class="hdlist1"><code>analyzer</code></dt>
<dd>
<p>(Optional, string) Analyzer to use for the query string.</p>
</dd>
<dt class="hdlist1"><code>analyze_wildcard</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, wildcard and prefix queries are
analyzed. Defaults to <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>conflicts</code></dt>
<dd>
<p>(Optional, string) What to do if update by query hits version conflicts:
<code>abort</code> or <code>proceed</code>. Defaults to <code>abort</code>.</p>
</dd>
<dt class="hdlist1"><code>default_operator</code></dt>
<dd>
<p>(Optional, string) The default operator for query string query: AND or OR.
Defaults to <code>OR</code>.</p>
</dd>
<dt class="hdlist1"><code>df</code></dt>
<dd>
<p>(Optional, string) Field to use as default where no field prefix is
given in the query string.</p>
</dd>
<dt class="hdlist1"><code>expand_wildcards</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string) Controls what kind of indices that wildcard expressions can
expand to. Multiple values are accepted when separated by a comma, as in
<code>open,hidden</code>. Valid values are:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>all</code></dt>
<dd>
<p>Expand to open and closed indices, including <a href="api-conventions.html#hidden-indices">hidden indices</a>.</p>
</dd>
<dt class="hdlist1"><code>open</code></dt>
<dd>
<p>Expand only to open indices.</p>
</dd>
<dt class="hdlist1"><code>closed</code></dt>
<dd>
<p>Expand only to closed indices.</p>
</dd>
<dt class="hdlist1"><code>hidden</code></dt>
<dd>
<p>Expansion of wildcards will include hidden indices.
Must be combined with <code>open</code>, <code>closed</code>, or both.</p>
</dd>
<dt class="hdlist1"><code>none</code></dt>
<dd>
<p>Wildcard expressions are not accepted.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>Defaults to <code>open</code>.</p>
</div>
</dd>
<dt class="hdlist1"><code>from</code></dt>
<dd>
<p>(Optional, integer) Starting document offset. Defaults to <code>0</code>.</p>
</dd>
<dt class="hdlist1"><code>ignore_unavailable</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, missing or closed indices are not included in the
response. Defaults to <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>lenient</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, format-based query failures (such as
providing text to a numeric field) will be ignored. Defaults to <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>max_docs</code></dt>
<dd>
<p>(Optional, integer) Maximum number of documents to process. Defaults to all
documents.</p>
</dd>
<dt class="hdlist1"><code>pipeline</code></dt>
<dd>
<p>(Optional, string) ID of the pipeline to use to preprocess incoming documents.</p>
</dd>
<dt class="hdlist1"><code>preference</code></dt>
<dd>
<p>(Optional, string) Specifies the node or shard the operation should be
performed on. Random by default.</p>
</dd>
<dt class="hdlist1"><code>q</code></dt>
<dd>
<p>(Optional, string) Query in the Lucene query string syntax.</p>
</dd>
<dt class="hdlist1"><code>request_cache</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, the request cache is used for this request.
Defaults to the index-level setting.</p>
</dd>
<dt class="hdlist1"><code>refresh</code></dt>
<dd>
<p>(Optional, Boolean)
If <code>true</code>, OpenSearch refreshes affected shards to make the operation visible to
search. Defaults to <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>requests_per_second</code></dt>
<dd>
<p>(Optional, integer) The throttle for this request in sub-requests per second.
Defaults to <code>-1</code> (no throttle).</p>
</dd>
<dt class="hdlist1"><code>routing</code></dt>
<dd>
<p>(Optional, string) Target the specified primary shard.</p>
</dd>
<dt class="hdlist1"><code>scroll</code></dt>
<dd>
<p>(Optional, <a href="api-conventions.html#time-units">time value</a>)
Period to retain the <a href="paginate-search-results.html#scroll-search-context">search context</a> for scrolling. See
<a href="paginate-search-results.html#scroll-search-results">Scroll search results</a>.</p>
</dd>
<dt class="hdlist1"><code>scroll_size</code></dt>
<dd>
<p>(Optional, integer) Size of the scroll request that powers the operation.
Defaults to 1000.</p>
</dd>
<dt class="hdlist1"><code>search_type</code></dt>
<dd>
<p>(Optional, string) The type of the search operation. Available options:</p>
<div class="ulist">
<ul>
<li>
<p><code>query_then_fetch</code></p>
</li>
<li>
<p><code>dfs_query_then_fetch</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1"><code>search_timeout</code></dt>
<dd>
<p>(Optional, <a href="api-conventions.html#time-units">time units</a>)
Explicit timeout for each search request.
Defaults to no timeout.</p>
</dd>
<dt class="hdlist1"><code>slices</code></dt>
<dd>
<p>(Optional, integer) The number of slices this task should be divided into.
Defaults to 1 meaning the task isn&#8217;t sliced into subtasks.</p>
</dd>
<dt class="hdlist1"><code>sort</code></dt>
<dd>
<p>(Optional, string) A comma-separated list of &lt;field&gt;:&lt;direction&gt; pairs.</p>
</dd>
<dt class="hdlist1"><code>_source</code></dt>
<dd>
<p>(Optional, string) True or false to return the <code>_source</code> field or not, or a
list of fields to return.</p>
</dd>
<dt class="hdlist1"><code>_source_excludes</code></dt>
<dd>
<p>(Optional, string)
A comma-separated list of <a href="mapping-fields.html#mapping-source-field">source fields</a> to exclude from
the response.</p>
<div class="paragraph">
<p>You can also use this parameter to exclude fields from the subset specified in
<code>_source_includes</code> query parameter.</p>
</div>
<div class="paragraph">
<p>If the <code>_source</code> parameter is <code>false</code>, this parameter is ignored.</p>
</div>
</dd>
<dt class="hdlist1"><code>_source_includes</code></dt>
<dd>
<p>(Optional, string)
A comma-separated list of <a href="mapping-fields.html#mapping-source-field">source fields</a> to
include in the response.</p>
<div class="paragraph">
<p>If this parameter is specified, only these source fields are returned. You can
exclude fields from this subset using the <code>_source_excludes</code> query parameter.</p>
</div>
<div class="paragraph">
<p>If the <code>_source</code> parameter is <code>false</code>, this parameter is ignored.</p>
</div>
</dd>
<dt class="hdlist1"><code>stats</code></dt>
<dd>
<p>(Optional, string) Specific <code>tag</code> of the request for logging and statistical
purposes.</p>
</dd>
<dt class="hdlist1"><code>terminate_after</code></dt>
<dd>
<p>(Optional, integer) The maximum number of documents to collect for each shard,
upon reaching which the query execution will terminate early.</p>
</dd>
<dt class="hdlist1"><code>timeout</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, <a href="api-conventions.html#time-units">time units</a>)
Period each update request waits for the following operations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Dynamic mapping updates</p>
</li>
<li>
<p><a href="docs.html#index-wait-for-active-shards">Waiting for active shards</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Defaults to <code>1m</code> (one minute). This guarantees OpenSearch waits for at least the
timeout before failing. The actual wait time could be longer, particularly when
multiple waits occur.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>version</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, returns the document version as part of a hit.</p>
</dd>
<dt class="hdlist1"><code>wait_for_active_shards</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string) The number of shard copies that must be active before
proceeding with the operation. Set to <code>all</code> or any positive integer up
to the total number of shards in the index (<code>number_of_replicas+1</code>).
Default: 1, the primary shard.</p>
</div>
<div class="paragraph">
<p>See <a href="docs.html#index-wait-for-active-shards">Active shards</a>.</p>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-update-by-query-api-request-body">Request body</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>query</code></dt>
<dd>
<p>(Optional, <a href="query-dsl.html">query object</a>) Specifies the documents to update
using the  <a href="query-dsl.html">Query DSL</a>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-update-by-query-api-response-body">Response body</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>took</code></dt>
<dd>
<p>The number of milliseconds from start to end of the whole operation.</p>
</dd>
<dt class="hdlist1"><code>timed_out</code></dt>
<dd>
<p>This flag is set to <code>true</code> if any of the requests executed during the
update by query execution has timed out.</p>
</dd>
<dt class="hdlist1"><code>total</code></dt>
<dd>
<p>The number of documents that were successfully processed.</p>
</dd>
<dt class="hdlist1"><code>updated</code></dt>
<dd>
<p>The number of documents that were successfully updated.</p>
</dd>
<dt class="hdlist1"><code>deleted</code></dt>
<dd>
<p>The number of documents that were successfully deleted.</p>
</dd>
<dt class="hdlist1"><code>batches</code></dt>
<dd>
<p>The number of scroll responses pulled back by the update by query.</p>
</dd>
<dt class="hdlist1"><code>version_conflicts</code></dt>
<dd>
<p>The number of version conflicts that the update by query hit.</p>
</dd>
<dt class="hdlist1"><code>noops</code></dt>
<dd>
<p>The number of documents that were ignored because the script used for
the update by query returned a <code>noop</code> value for <code>ctx.op</code>.</p>
</dd>
<dt class="hdlist1"><code>retries</code></dt>
<dd>
<p>The number of retries attempted by update by query. <code>bulk</code> is the number of bulk
actions retried, and <code>search</code> is the number of search actions retried.</p>
</dd>
<dt class="hdlist1"><code>throttled_millis</code></dt>
<dd>
<p>Number of milliseconds the request slept to conform to <code>requests_per_second</code>.</p>
</dd>
<dt class="hdlist1"><code>requests_per_second</code></dt>
<dd>
<p>The number of requests per second effectively executed during the update by query.</p>
</dd>
<dt class="hdlist1"><code>throttled_until_millis</code></dt>
<dd>
<p>This field should always be equal to zero in an <code>_update_by_query</code> response. It only
has meaning when using the <a href="docs.html#docs-update-by-query-task-api">Task API</a>, where it
indicates the next time (in milliseconds since epoch) a throttled request will be
executed again in order to conform to <code>requests_per_second</code>.</p>
</dd>
<dt class="hdlist1"><code>failures</code></dt>
<dd>
<p>Array of failures if there were any unrecoverable errors during the process. If
this is non-empty then the request aborted because of those failures.
Update by query is implemented using batches. Any failure causes the entire
process to abort, but all failures in the current batch are collected into the
array. You can use the <code>conflicts</code> option to prevent reindex from aborting on
version conflicts.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-update-by-query-api-example">Examples</h4>
<div class="paragraph">
<p>The simplest usage of <code>_update_by_query</code> just performs an update on every
document in the index without changing the source. This is useful to
<a href="docs.html#picking-up-a-new-property">pick up a new property</a> or some other online
mapping change.</p>
</div>
<div class="paragraph">
<p>To update selected documents, specify a query in the request body:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST my-index-000001/_update_by_query?conflicts=proceed
{
  "query": { <b class="conum">(1)</b>
    "term": {
      "user.id": "bilbo"
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>The query must be passed as a value to the <code>query</code> key, in the same
way as the <a href="search.html#search-search">Search API</a>. You can also use the <code>q</code>
parameter in the same way as the search API.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Update documents in multiple indices:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST my-index-000001,my-index-000002/_update_by_query</code></pre>
</div>
</div>
<div class="paragraph">
<p>Limit the update by query operation to shards that a particular routing value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST my-index-000001/_update_by_query?routing=1</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default update by query uses scroll batches of 1000.
You can change the batch size with the <code>scroll_size</code> parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST my-index-000001/_update_by_query?scroll_size=100</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="docs-update-by-query-api-source">Update the document source</h5>
<div class="paragraph">
<p>Update by query supports scripts to update the document source.
For example, the following request increments the <code>count</code> field for all
documents with a <code>user.id</code> of <code>bilbo</code> in <code>my-index-000001</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST my-index-000001/_update_by_query
{
  "script": {
    "source": "ctx._source.count++",
    "lang": "painless"
  },
  "query": {
    "term": {
      "user.id": "bilbo"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>conflicts=proceed</code> is not specified in this example. In this case, a
version conflict should halt the process so you can handle the failure.</p>
</div>
<div class="paragraph">
<p>As with the <a href="docs.html#docs-update">Update API</a>, you can set <code>ctx.op</code> to change the
operation that is performed:</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>noop</code>
</td>
<td class="hdlist2">
<p>Set <code>ctx.op = "noop"</code> if your script decides that it doesn&#8217;t have to make any changes.
The update by query operation skips updating the document and increments the  <code>noop</code> counter.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>delete</code>
</td>
<td class="hdlist2">
<p>Set <code>ctx.op = "delete"</code> if your script decides that the document should be deleted.
The update by query operation deletes the document and increments the  <code>deleted</code> counter.</p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Update by query only supports <code>update</code>, <code>noop</code>, and <code>delete</code>.
Setting <code>ctx.op</code> to anything else is an error. Setting any other field in <code>ctx</code> is an error.
This API only enables you to modify the source of matching documents, you cannot move them.</p>
</div>
</div>
<div class="sect4">
<h5 id="docs-update-by-query-api-ingest-pipeline">Update documents using an ingest pipeline</h5>
<div class="paragraph">
<p>Update by query can use the <a href="ingest.html">Ingest node</a> feature by specifying a <code>pipeline</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT _ingest/pipeline/set-foo
{
  "description" : "sets foo",
  "processors" : [ {
      "set" : {
        "field": "foo",
        "value": "bar"
      }
  } ]
}
POST my-index-000001/_update_by_query?pipeline=set-foo</code></pre>
</div>
</div>
<h5 id="docs-update-by-query-fetch-tasks" class="discrete">Get the status of update by query operations</h5>
<div class="paragraph">
<p>You can fetch the status of all running update by query requests with the
<a href="cluster.html#tasks">Task API</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET _tasks?detailed=true&amp;actions=*byquery</code></pre>
</div>
</div>
<div class="paragraph">
<p>The responses looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "nodes" : {
    "r1A2WoRbTwKZ516z6NEs5A" : {
      "name" : "r1A2WoR",
      "transport_address" : "127.0.0.1:9300",
      "host" : "127.0.0.1",
      "ip" : "127.0.0.1:9300",
      "attributes" : {
        "testattr" : "test",
        "portsfile" : "true"
      },
      "tasks" : {
        "r1A2WoRbTwKZ516z6NEs5A:36619" : {
          "node" : "r1A2WoRbTwKZ516z6NEs5A",
          "id" : 36619,
          "type" : "transport",
          "action" : "indices:data/write/update/byquery",
          "status" : {    <b class="conum">(1)</b>
            "total" : 6154,
            "updated" : 3500,
            "created" : 0,
            "deleted" : 0,
            "batches" : 4,
            "version_conflicts" : 0,
            "noops" : 0,
            "retries": {
              "bulk": 0,
              "search": 0
            },
            "throttled_millis": 0
          },
          "description" : ""
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This object contains the actual status. It is just like the response JSON
with the important addition of the <code>total</code> field. <code>total</code> is the total number
of operations that the reindex expects to perform. You can estimate the
progress by adding the <code>updated</code>, <code>created</code>, and <code>deleted</code> fields. The request
will finish when their sum is equal to the <code>total</code> field.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>With the task id you can look up the task directly. The following example
retrieves information about task <code>r1A2WoRbTwKZ516z6NEs5A:36619</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_tasks/r1A2WoRbTwKZ516z6NEs5A:36619</code></pre>
</div>
</div>
<div class="paragraph">
<p>The advantage of this API is that it integrates with <code>wait_for_completion=false</code>
to transparently return the status of completed tasks. If the task is completed
and <code>wait_for_completion=false</code> was set on it, then it&#8217;ll come back with a
<code>results</code> or an <code>error</code> field. The cost of this feature is the document that
<code>wait_for_completion=false</code> creates at <code>.tasks/task/${taskId}</code>. It is up to
you to delete that document.</p>
</div>
<h5 id="docs-update-by-query-cancel-task-api" class="discrete">Cancel an update by query operation</h5>
<div class="paragraph">
<p>Any update by query can be cancelled using the <a href="cluster.html#tasks">Task Cancel API</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel</code></pre>
</div>
</div>
<div class="paragraph">
<p>The task ID can be found using the <a href="cluster.html#tasks">tasks API</a>.</p>
</div>
<div class="paragraph">
<p>Cancellation should happen quickly but might take a few seconds. The task status
API above will continue to list the update by query task until this task checks
that it has been cancelled and terminates itself.</p>
</div>
<h5 id="docs-update-by-query-rethrottle" class="discrete">Change throttling for a request</h5>
<div class="paragraph">
<p>The value of <code>requests_per_second</code> can be changed on a running update by query
using the <code>_rethrottle</code> API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _update_by_query/r1A2WoRbTwKZ516z6NEs5A:36619/_rethrottle?requests_per_second=-1</code></pre>
</div>
</div>
<div class="paragraph">
<p>The task ID can be found using the <a href="cluster.html#tasks">tasks API</a>.</p>
</div>
<div class="paragraph">
<p>Just like when setting it on the <code>_update_by_query</code> API, <code>requests_per_second</code>
can be either <code>-1</code> to disable throttling or any decimal number
like <code>1.7</code> or <code>12</code> to throttle to that level. Rethrottling that speeds up the
query takes effect immediately, but rethrotting that slows down the query will
take effect after completing the current batch. This prevents scroll
timeouts.</p>
</div>
<h5 id="docs-update-by-query-manual-slice" class="discrete">Slice manually</h5>
<div class="paragraph">
<p>Slice an update by query manually by providing a slice id and total number of
slices to each request:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST my-index-000001/_update_by_query
{
  "slice": {
    "id": 0,
    "max": 2
  },
  "script": {
    "source": "ctx._source['extra'] = 'test'"
  }
}
POST my-index-000001/_update_by_query
{
  "slice": {
    "id": 1,
    "max": 2
  },
  "script": {
    "source": "ctx._source['extra'] = 'test'"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which you can verify works with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET _refresh
POST my-index-000001/_search?size=0&amp;q=extra:test&amp;filter_path=hits.total</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which results in a sensible <code>total</code> like this one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "hits": {
    "total": {
        "value": 120,
        "relation": "eq"
    }
  }
}</code></pre>
</div>
</div>
<h5 id="docs-update-by-query-automatic-slice" class="discrete">Use automatic slicing</h5>
<div class="paragraph">
<p>You can also let update by query automatically parallelize using
<a href="paginate-search-results.html#slice-scroll">Sliced scroll</a> to slice on <code>_id</code>. Use <code>slices</code> to specify the number of
slices to use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST my-index-000001/_update_by_query?refresh&amp;slices=5
{
  "script": {
    "source": "ctx._source['extra'] = 'test'"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which you also can verify works with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST my-index-000001/_search?size=0&amp;q=extra:test&amp;filter_path=hits.total</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which results in a sensible <code>total</code> like this one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "hits": {
    "total": {
        "value": 120,
        "relation": "eq"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Setting <code>slices</code> to <code>auto</code> will let OpenSearch choose the number of slices
to use. This setting will use one slice per shard, up to a certain limit. If
there are multiple source indices, it will choose the number of slices based
on the index with the smallest number of shards.</p>
</div>
<div class="paragraph">
<p>Adding <code>slices</code> to <code>_update_by_query</code> just automates the manual process used in
the section above, creating sub-requests which means it has some quirks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You can see these requests in the
<a href="docs.html#docs-update-by-query-task-api">Tasks APIs</a>. These sub-requests are "child"
tasks of the task for the request with <code>slices</code>.</p>
</li>
<li>
<p>Fetching the status of the task for the request with <code>slices</code> only contains
the status of completed slices.</p>
</li>
<li>
<p>These sub-requests are individually addressable for things like cancellation
and rethrottling.</p>
</li>
<li>
<p>Rethrottling the request with <code>slices</code> will rethrottle the unfinished
sub-request proportionally.</p>
</li>
<li>
<p>Canceling the request with <code>slices</code> will cancel each sub-request.</p>
</li>
<li>
<p>Due to the nature of <code>slices</code> each sub-request won&#8217;t get a perfectly even
portion of the documents. All documents will be addressed, but some slices may
be larger than others. Expect larger slices to have a more even distribution.</p>
</li>
<li>
<p>Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with
<code>slices</code> are distributed proportionally to each sub-request. Combine that with
the point above about distribution being uneven and you should conclude that
using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents
being updated.</p>
</li>
<li>
<p>Each sub-request gets a slightly different snapshot of the source index
though these are all taken at approximately the same time.</p>
</li>
</ul>
</div>
<h5 id="picking-up-a-new-property" class="discrete">Pick up a new property</h5>
<div class="paragraph">
<p>Say you created an index without dynamic mapping, filled it with data, and then
added a mapping value to pick up more fields from the data:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT test
{
  "mappings": {
    "dynamic": false,   <b class="conum">(1)</b>
    "properties": {
      "text": {"type": "text"}
    }
  }
}

POST test/_doc?refresh
{
  "text": "words words",
  "flag": "bar"
}
POST test/_doc?refresh
{
  "text": "words words",
  "flag": "foo"
}
PUT test/_mapping   <b class="conum">(2)</b>
{
  "properties": {
    "text": {"type": "text"},
    "flag": {"type": "text", "analyzer": "keyword"}
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>This means that new fields won&#8217;t be indexed, just stored in <code>_source</code>.</p>
</li>
<li>
<p>This updates the mapping to add the new <code>flag</code> field. To pick up the new
field you have to reindex all documents with it.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Searching for the data won&#8217;t find anything:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST test/_search?filter_path=hits.total
{
  "query": {
    "match": {
      "flag": "foo"
    }
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "hits" : {
    "total": {
        "value": 0,
        "relation": "eq"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>But you can issue an <code>_update_by_query</code> request to pick up the new mapping:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST test/_update_by_query?refresh&amp;conflicts=proceed
POST test/_search?filter_path=hits.total
{
  "query": {
    "match": {
      "flag": "foo"
    }
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "hits" : {
    "total": {
        "value": 1,
        "relation": "eq"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can do the exact same thing when adding a field to a multifield.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="docs-multi-get">Multi get (mget) API</h3>
<titleabbrev>Multi get</titleabbrev>
<div class="paragraph">
<p>Retrieves multiple JSON documents by ID.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_mget
{
  "docs": [
    {
      "_index": "my-index-000001",
      "_id": "1"
    },
    {
      "_index": "my-index-000001",
      "_id": "2"
    }
  ]
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="docs-multi-get-api-request">Request</h4>
<div class="paragraph">
<p><code>GET /_mget</code></p>
</div>
<div class="paragraph">
<p><code>GET /&lt;index&gt;/_mget</code></p>
</div>
</div>
<div class="sect3">
<h4 id="docs-multi-get-api-desc">Description</h4>
<div class="paragraph">
<p>You use <code>mget</code> to retrieve multiple documents from one or more indices.
If you specify an index in the request URI, you only need to specify the document IDs in the request body.</p>
</div>
<div class="sect4">
<h5 id="mget-security">Security</h5>
<div class="paragraph">
<p>See <a href="api-conventions.html#url-access-control">URL-based access control</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="multi-get-partial-responses">Partial responses</h5>
<div class="paragraph">
<p>To ensure fast responses, the multi get API responds with partial results if one or more shards fail.
See <a href="docs.html#shard-failures">Shard failures</a> for more information.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="docs-multi-get-api-path-params">Path parameters</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>&lt;index&gt;</code></dt>
<dd>
<p>(Optional, string) Name of the index to retrieve documents from when <code>ids</code> are specified,
or when a document in the <code>docs</code> array does not specify an index.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-multi-get-api-query-params">Query parameters</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>preference</code></dt>
<dd>
<p>(Optional, string) Specifies the node or shard the operation should be
performed on. Random by default.</p>
</dd>
<dt class="hdlist1"><code>realtime</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, the request is real-time as opposed to near-real-time.
Defaults to <code>true</code>. See <a href="docs.html#realtime">Realtime</a>.</p>
</dd>
<dt class="hdlist1"><code>refresh</code></dt>
<dd>
<p>(Optional, enum) If <code>true</code>, OpenSearch refreshes the affected shards to make this
operation visible to search, if <code>wait_for</code> then wait for a refresh to make
this operation visible to search, if <code>false</code> do nothing with refreshes.
Valid values: <code>true</code>, <code>false</code>, <code>wait_for</code>. Default: <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>routing</code></dt>
<dd>
<p>(Optional, string) Target the specified primary shard.</p>
</dd>
<dt class="hdlist1"><code>stored_fields</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, retrieves the document fields stored in the
index rather than the document <code>_source</code>. Defaults to <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>_source</code></dt>
<dd>
<p>(Optional, string) True or false to return the <code>_source</code> field or not, or a
list of fields to return.</p>
</dd>
<dt class="hdlist1"><code>_source_excludes</code></dt>
<dd>
<p>(Optional, string)
A comma-separated list of <a href="mapping-fields.html#mapping-source-field">source fields</a> to exclude from
the response.</p>
<div class="paragraph">
<p>You can also use this parameter to exclude fields from the subset specified in
<code>_source_includes</code> query parameter.</p>
</div>
<div class="paragraph">
<p>If the <code>_source</code> parameter is <code>false</code>, this parameter is ignored.</p>
</div>
</dd>
<dt class="hdlist1"><code>_source_includes</code></dt>
<dd>
<p>(Optional, string)
A comma-separated list of <a href="mapping-fields.html#mapping-source-field">source fields</a> to
include in the response.</p>
<div class="paragraph">
<p>If this parameter is specified, only these source fields are returned. You can
exclude fields from this subset using the <code>_source_excludes</code> query parameter.</p>
</div>
<div class="paragraph">
<p>If the <code>_source</code> parameter is <code>false</code>, this parameter is ignored.</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-multi-get-api-request-body">Request body</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>docs</code></dt>
<dd>
<p>(Optional, array) The documents you want to retrieve.
Required if no index is specified in the request URI.
You can specify the following attributes for each
document:</p>
<div class="openblock">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><code>_id</code></dt>
<dd>
<p>(Required, string) The unique document ID.</p>
</dd>
<dt class="hdlist1"><code>_index</code></dt>
<dd>
<p>(Optional, string)
The index that contains the document.
Required if no index is specified in the request URI.</p>
</dd>
<dt class="hdlist1"><code>_routing</code></dt>
<dd>
<p>(Optional, string) The key for the primary shard the document resides on.
Required if routing is used during indexing.</p>
</dd>
<dt class="hdlist1"><code>_source</code></dt>
<dd>
<p>(Optional, Boolean) If <code>false</code>,  excludes all <code>_source</code> fields. Defaults to <code>true</code>.</p>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>source_include</code></dt>
<dd>
<p>(Optional, array) The fields to extract and return from the <code>_source</code> field.</p>
</dd>
<dt class="hdlist1"><code>source_exclude</code></dt>
<dd>
<p>(Optional, array) The fields to exclude from the returned <code>_source</code> field.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>_stored_fields</code></dt>
<dd>
<p>(Optional, array) The stored fields you want to retrieve.</p>
</dd>
</dl>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>ids</code></dt>
<dd>
<p>(Optional, array) The IDs of the documents you want to retrieve.
Allowed when the index is specified in the request URI.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="multi-get-api-response-body">Response body</h4>
<div class="paragraph">
<p>The response includes a <code>docs</code> array that contains the documents in the order specified in the request.
The structure of the returned documents is similar to that returned by the <a href="docs.html#docs-get">get</a> API.
If there is a failure getting a particular document, the error is included in place of the document.</p>
</div>
</div>
<div class="sect3">
<h4 id="docs-multi-get-api-example">Examples</h4>
<div class="sect4">
<h5 id="mget-ids">Get documents by ID</h5>
<div class="paragraph">
<p>If you specify an index in the request URI, only the document IDs are required in the request body:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /my-index-000001/_mget
{
  "docs": [
    {
      "_type": "_doc",
      "_id": "1"
    },
    {
      "_type": "_doc",
      "_id": "2"
    }
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /test/_doc/_mget
{
  "docs": [
    {
      "_id": "1"
    },
    {
      "_id": "2"
    }
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use the <code>ids</code> element to simplify the request:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /my-index-000001/_mget
{
  "ids" : ["1", "2"]
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mget-source-filtering">Filter source fields</h5>
<div class="paragraph">
<p>By default, the <code>_source</code> field is returned for every document (if stored).
Use the <code>_source</code> and <code>_source_include</code> or <code>source_exclude</code> attributes to
filter what fields are returned for a particular document.
You can include the <code>_source</code>, <code>_source_includes</code>, and <code>_source_excludes</code> query parameters in the
request URI to specify the defaults to use when there are no per-document instructions.</p>
</div>
<div class="paragraph">
<p>For example, the following request sets <code>_source</code> to false for document 1 to exclude the
source entirely, retrieves <code>field3</code> and <code>field4</code> from document 2, and retrieves the <code>user</code> field
from document 3 but filters out the <code>user.location</code> field.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_mget
{
  "docs": [
    {
      "_index": "test",
      "_type": "_doc",
      "_id": "1",
      "_source": false
    },
    {
      "_index": "test",
      "_type": "_doc",
      "_id": "2",
      "_source": [ "field3", "field4" ]
    },
    {
      "_index": "test",
      "_type": "_doc",
      "_id": "3",
      "_source": {
        "include": [ "user" ],
        "exclude": [ "user.location" ]
      }
    }
  ]
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mget-fields">Get stored fields</h5>
<div class="paragraph">
<p>Use the <code>stored_fields</code> attribute to specify the set of stored fields you want
to retrieve. Any requested fields that are not stored are ignored.
You can include the <code>stored_fields</code> query parameter in the request URI to specify the defaults
to use when there are no per-document instructions.</p>
</div>
<div class="paragraph">
<p>For example, the following request retrieves <code>field1</code> and <code>field2</code> from document 1, and
<code>field3</code> and `field4`from document 2:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_mget
{
  "docs": [
    {
      "_index": "test",
      "_type": "_doc",
      "_id": "1",
      "stored_fields": [ "field1", "field2" ]
    },
    {
      "_index": "test",
      "_type": "_doc",
      "_id": "2",
      "stored_fields": [ "field3", "field4" ]
    }
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following request retrieves <code>field1</code> and <code>field2</code> from all documents by default.
These default fields are returned for document 1, but
overridden to return <code>field3</code> and <code>field4</code> for document 2.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /test/_doc/_mget?stored_fields=field1,field2
{
  "docs": [
    {
      "_id": "1"
    },
    {
      "_id": "2",
      "stored_fields": [ "field3", "field4" ]
    }
  ]
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mget-routing">Specify document routing</h5>
<div class="paragraph">
<p>If routing is used during indexing, you need to specify the routing value to retrieve documents.
For example, the following request fetches <code>test/_doc/2</code>  from the shard corresponding to routing key <code>key1</code>,
and fetches <code>test/_doc/1</code> from the shard corresponding to routing key <code>key2</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /_mget?routing=key1
{
  "docs": [
    {
      "_index": "test",
      "_type": "_doc",
      "_id": "1",
      "routing": "key2"
    },
    {
      "_index": "test",
      "_type": "_doc",
      "_id": "2"
    }
  ]
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="docs-bulk">Bulk API</h3>
<titleabbrev>Bulk</titleabbrev>
<div class="paragraph">
<p>Performs multiple indexing or delete operations in a single API call.
This reduces overhead and can greatly increase indexing speed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _bulk
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
{ "delete" : { "_index" : "test", "_id" : "2" } }
{ "create" : { "_index" : "test", "_id" : "3" } }
{ "field1" : "value3" }
{ "update" : {"_id" : "1", "_index" : "test"} }
{ "doc" : {"field2" : "value2"} }</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="docs-bulk-api-request">Request</h4>
<div class="paragraph">
<p><code>POST /_bulk</code></p>
</div>
<div class="paragraph">
<p><code>POST /&lt;target&gt;/_bulk</code></p>
</div>
<div class="ulist">
<ul>
<li>
<p>To use the <code>create</code> action, you must have the <code>create_doc</code>, <code>create</code>,
<code>index</code>, or <code>write</code> index privilege.</p>
</li>
<li>
<p>To use the <code>index</code> action, you must have the <code>create</code>, <code>index</code>, or <code>write</code>
index privilege.</p>
</li>
<li>
<p>To use the <code>delete</code> action, you must have the <code>delete</code> or <code>write</code> index
privilege.</p>
</li>
<li>
<p>To use the <code>update</code> action, you must have the <code>index</code> or <code>write</code> index
privilege.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="docs-bulk-api-desc">Description</h4>
<div class="paragraph">
<p>Provides a way to perform multiple <code>index</code>, <code>create</code>, <code>delete</code>, and <code>update</code> actions in a single request.</p>
</div>
<div class="paragraph">
<p>The actions are specified in the request body using a newline delimited JSON (NDJSON) structure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">action_and_meta_data\n
optional_source\n
action_and_meta_data\n
optional_source\n
....
action_and_meta_data\n
optional_source\n</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>index</code> and <code>create</code> actions expect a source on the next line,
and have the same semantics as the <code>op_type</code> parameter in the standard index API:
<code>create</code> fails if a document with the same ID already exists in the target,
<code>index</code> adds or replaces a document as necessary.</p>
</div>
<div class="paragraph">
<p><code>update</code> expects that the partial doc, upsert,
and script and its options are specified on the next line.</p>
</div>
<div class="paragraph">
<p><code>delete</code> does not expect a source on the next line and
has the same semantics as the standard delete API.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The final line of data must end with a newline character <code>\n</code>.
Each newline character may be preceded by a carriage return <code>\r</code>.
When sending requests to the <code>_bulk</code> endpoint,
the <code>Content-Type</code> header should be set to <code>application/x-ndjson</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Because this format uses literal `\n&#8217;s as delimiters,
make sure that the JSON actions and sources are not pretty printed.</p>
</div>
<div class="paragraph">
<p>If you provide a <code>&lt;target&gt;</code> in the request path,
it is used for any actions that don&#8217;t explicitly specify an <code>_index</code> argument.</p>
</div>
<div class="paragraph">
<p>A note on the format: The idea here is to make processing of this as
fast as possible. As some of the actions are redirected to other
shards on other nodes, only <code>action_meta_data</code> is parsed on the
receiving node side.</p>
</div>
<div class="paragraph">
<p>Client libraries using this protocol should try and strive to do
something similar on the client side, and reduce buffering as much as
possible.</p>
</div>
<div class="paragraph">
<p>There is no "correct" number of actions to perform in a single bulk request.
Experiment with different settings to find the optimal size for your particular workload.</p>
</div>
<div class="paragraph">
<p>When using the HTTP API, make sure that the client does not send HTTP chunks,
as this will slow things down.</p>
</div>
<h5 id="bulk-curl" class="discrete">Submitting bulk requests with cURL</h5>
<div class="paragraph">
<p>If you&#8217;re providing text file input to <code>curl</code>, you <strong>must</strong> use the
<code>--data-binary</code> flag instead of plain <code>-d</code>. The latter doesn&#8217;t preserve
newlines. Example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">$ cat requests
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
$ curl -s -H "Content-Type: application/x-ndjson" -XPOST localhost:9200/_bulk --data-binary "@requests"; echo
{"took":7, "errors": false, "items":[{"index":{"_index":"test","_type":"_doc","_id":"1","_version":1,"result":"created","forced_refresh":false}}]}</code></pre>
</div>
</div>
<h5 id="bulk-optimistic-concurrency-control" class="discrete">Optimistic concurrency control</h5>
<div class="paragraph">
<p>Each <code>index</code> and <code>delete</code> action within a bulk API call may include the
<code>if_seq_no</code> and <code>if_primary_term</code> parameters in their respective action
and meta data lines. The <code>if_seq_no</code> and <code>if_primary_term</code> parameters control
how operations are executed, based on the last modification to existing
documents. See <a href="docs.html#optimistic-concurrency-control">Optimistic concurrency control</a> for more details.</p>
</div>
<h5 id="bulk-versioning" class="discrete">Versioning</h5>
<div class="paragraph">
<p>Each bulk item can include the version value using the
<code>version</code> field. It automatically follows the behavior of the
index / delete operation based on the <code>_version</code> mapping. It also
support the <code>version_type</code> (see <a href="docs.html#index-versioning">versioning</a>).</p>
</div>
<h5 id="bulk-routing" class="discrete">Routing</h5>
<div class="paragraph">
<p>Each bulk item can include the routing value using the
<code>routing</code> field. It automatically follows the behavior of the
index / delete operation based on the <code>_routing</code> mapping.</p>
</div>
<h5 id="bulk-wait-for-active-shards" class="discrete">Wait for active shards</h5>
<div class="paragraph">
<p>When making bulk calls, you can set the <code>wait_for_active_shards</code>
parameter to require a minimum number of shard copies to be active
before starting to process the bulk request. See
<a href="docs.html#index-wait-for-active-shards">here</a> for further details and a usage
example.</p>
</div>
<h5 id="bulk-refresh" class="discrete">Refresh</h5>
<div class="paragraph">
<p>Control when the changes made by this request are visible to search. See
<a href="docs.html#docs-refresh">refresh</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Only the shards that receive the bulk request will be affected by
<code>refresh</code>. Imagine a <code>_bulk?refresh=wait_for</code> request with three
documents in it that happen to be routed to different shards in an index
with five shards. The request will only wait for those three shards to
refresh. The other two shards that make up the index do not
participate in the <code>_bulk</code> request at all.
</td>
</tr>
</table>
</div>
<h5 id="bulk-security" class="discrete">Security</h5>
<div class="paragraph">
<p>See <a href="api-conventions.html#url-access-control">URL-based access control</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="docs-bulk-api-path-params">Path parameters</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>&lt;target&gt;</code></dt>
<dd>
<p>(Optional, string)
Name of the index or index alias to perform bulk actions
on.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-bulk-api-query-params">Query parameters</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>pipeline</code></dt>
<dd>
<p>(Optional, string) ID of the pipeline to use to preprocess incoming documents.</p>
</dd>
<dt class="hdlist1"><code>refresh</code></dt>
<dd>
<p>(Optional, enum) If <code>true</code>, OpenSearch refreshes the affected shards to make this
operation visible to search, if <code>wait_for</code> then wait for a refresh to make
this operation visible to search, if <code>false</code> do nothing with refreshes.
Valid values: <code>true</code>, <code>false</code>, <code>wait_for</code>. Default: <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>require_alias</code></dt>
<dd>
<p>(Optional, Boolean)
If <code>true</code>, the request&#8217;s actions must target an <a href="indices.html#indices-aliases">index alias</a>.
Defaults to <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>routing</code></dt>
<dd>
<p>(Optional, string) Target the specified primary shard.</p>
</dd>
<dt class="hdlist1"><code>_source</code></dt>
<dd>
<p>(Optional, string) True or false to return the <code>_source</code> field or not, or a
list of fields to return.</p>
</dd>
<dt class="hdlist1"><code>_source_excludes</code></dt>
<dd>
<p>(Optional, string)
A comma-separated list of <a href="mapping-fields.html#mapping-source-field">source fields</a> to exclude from
the response.</p>
<div class="paragraph">
<p>You can also use this parameter to exclude fields from the subset specified in
<code>_source_includes</code> query parameter.</p>
</div>
<div class="paragraph">
<p>If the <code>_source</code> parameter is <code>false</code>, this parameter is ignored.</p>
</div>
</dd>
<dt class="hdlist1"><code>_source_includes</code></dt>
<dd>
<p>(Optional, string)
A comma-separated list of <a href="mapping-fields.html#mapping-source-field">source fields</a> to
include in the response.</p>
<div class="paragraph">
<p>If this parameter is specified, only these source fields are returned. You can
exclude fields from this subset using the <code>_source_excludes</code> query parameter.</p>
</div>
<div class="paragraph">
<p>If the <code>_source</code> parameter is <code>false</code>, this parameter is ignored.</p>
</div>
</dd>
<dt class="hdlist1"><code>timeout</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, <a href="api-conventions.html#time-units">time units</a>)
Period each action waits for the following operations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="docs.html#index-creation">Automatic index creation</a></p>
</li>
<li>
<p><a href="dynamic-mapping.html">Dynamic mapping</a> updates</p>
</li>
<li>
<p><a href="docs.html#index-wait-for-active-shards">Waiting for active shards</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Defaults to <code>1m</code> (one minute). This guarantees OpenSearch waits for at least the
timeout before failing. The actual wait time could be longer, particularly when
multiple waits occur.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>wait_for_active_shards</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string) The number of shard copies that must be active before
proceeding with the operation. Set to <code>all</code> or any positive integer up
to the total number of shards in the index (<code>number_of_replicas+1</code>).
Default: 1, the primary shard.</p>
</div>
<div class="paragraph">
<p>See <a href="docs.html#index-wait-for-active-shards">Active shards</a>.</p>
</div>
</div>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="bulk-api-request-body">Request body</h4>
<div class="paragraph">
<p>The request body contains a newline-delimited list of <code>create</code>, <code>delete</code>, <code>index</code>,
and <code>update</code> actions and their associated source data.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>create</code></dt>
<dd>
<p>(Optional, string)
Indexes the specified document if it does not already exist.
The following line must contain the source data to be indexed.</p>
<div class="openblock">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><code>_index</code></dt>
<dd>
<p>(Optional, string)
Name of the index or index alias to perform the action on. This
parameter is required if a <code>&lt;target&gt;</code> is not specified in the request path.</p>
</dd>
<dt class="hdlist1"><code>_id</code></dt>
<dd>
<p>(Optional, string)
The document ID.
If no ID is specified, a document ID is automatically generated.</p>
</dd>
<dt class="hdlist1"><code>require_alias</code></dt>
<dd>
<p>(Optional, Boolean)
If <code>true</code>, the action must target an <a href="indices.html#indices-aliases">index alias</a>. Defaults
to <code>false</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>delete</code></dt>
<dd>
<p>(Optional, string)
Removes the specified document from the index.</p>
<div class="openblock">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><code>_index</code></dt>
<dd>
<p>(Optional, string)
Name of the index or index alias to perform the action on. This
parameter is required if a <code>&lt;target&gt;</code> is not specified in the request path.</p>
</dd>
<dt class="hdlist1"><code>_id</code></dt>
<dd>
<p>(Required, string)
The document ID.</p>
</dd>
<dt class="hdlist1"><code>require_alias</code></dt>
<dd>
<p>(Optional, Boolean)
If <code>true</code>, the action must target an <a href="indices.html#indices-aliases">index alias</a>. Defaults
to <code>false</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>index</code></dt>
<dd>
<p>(Optional, string)
Indexes the specified document.
If the document exists, replaces the document and increments the version.
The following line must contain the source data to be indexed.</p>
<div class="openblock">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><code>_index</code></dt>
<dd>
<p>(Optional, string)
Name of the index or index alias to perform the action on. This
parameter is required if a <code>&lt;target&gt;</code> is not specified in the request path.</p>
</dd>
<dt class="hdlist1"><code>_id</code></dt>
<dd>
<p>(Optional, string)
The document ID.
If no ID is specified, a document ID is automatically generated.</p>
</dd>
<dt class="hdlist1"><code>require_alias</code></dt>
<dd>
<p>(Optional, Boolean)
If <code>true</code>, the action must target an <a href="indices.html#indices-aliases">index alias</a>. Defaults
to <code>false</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>update</code></dt>
<dd>
<p>(Optional, string)
Performs a partial document update.
The following line must contain the partial document and update options.</p>
<div class="openblock">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><code>_index</code></dt>
<dd>
<p>(Optional, string)
Name of the index or index alias to perform the action on. This
parameter is required if a <code>&lt;target&gt;</code> is not specified in the request path.</p>
</dd>
<dt class="hdlist1"><code>_id</code></dt>
<dd>
<p>(Optional, string)
The document ID.
If no ID is specified, a document ID is automatically generated.</p>
</dd>
<dt class="hdlist1"><code>require_alias</code></dt>
<dd>
<p>(Optional, Boolean)
If <code>true</code>, the action must target an <a href="indices.html#indices-aliases">index alias</a>. Defaults
to <code>false</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>doc</code></dt>
<dd>
<p>(Optional, object)
The partial document to index.
Required for <code>update</code> operations.</p>
</dd>
<dt class="hdlist1"><code>&lt;fields&gt;</code></dt>
<dd>
<p>(Optional, object)
The document source to index.
Required for <code>create</code> and <code>index</code> operations.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3 child_attributes">
<h4 id="bulk-api-response-body">Response body</h4>
<div class="paragraph">
<p>The bulk API&#8217;s response contains the individual results of each operation in the
request, returned in the order submitted. The success or failure of an
individual operation does not affect other operations in the request.</p>
</div>
<div id="bulk-partial-responses" class="sidebarblock">
<div class="content">
<div class="title">Partial responses</div>
<div class="paragraph">
<p>To ensure fast responses, the bulk API will respond with partial results if one
or more shards fail. See <a href="docs.html#shard-failures">Shard failures</a> for more
information.</p>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>took</code></dt>
<dd>
<p>(integer)
How long, in milliseconds, it took to process the bulk request.</p>
</dd>
<dt class="hdlist1"><code>errors</code></dt>
<dd>
<p>(Boolean)
If <code>true</code>, one or more of the operations in the bulk request did not complete
successfully.</p>
</dd>
<dt class="hdlist1"><code>items</code></dt>
<dd>
<p>(array of objects)
Contains the result of each operation in the bulk request, in the order they
were submitted.</p>
<details open>
<summary class="title">Properties of <code>items</code> objects</summary>
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1">&lt;action&gt;</dt>
<dd>
<p>(object)
The parameter name is an action associated with the operation. Possible values
are <code>create</code>, <code>delete</code>, <code>index</code>, and <code>update</code>.</p>
<div class="paragraph">
<p>The parameter value is an object that contains information for the associated
operation.</p>
</div>
<details open>
<summary class="title">Properties of <code>&lt;action&gt;</code></summary>
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><code>_index</code></dt>
<dd>
<p>(string)
Name of the index associated with the operation.</p>
</dd>
<dt class="hdlist1"><code>_type</code></dt>
<dd>
<p>(string)
The document type associated with the operation. OpenSearch indices support a
single document type of <code>_doc</code>.</p>
</dd>
<dt class="hdlist1"><code>_id</code></dt>
<dd>
<p>(integer)
The document ID associated with the operation.</p>
</dd>
<dt class="hdlist1"><code>_version</code></dt>
<dd>
<p>(integer)
The document version associated with the operation. The document version is
incremented each time the document is updated.</p>
<div class="paragraph">
<p>This parameter is only returned for successful actions.</p>
</div>
</dd>
<dt class="hdlist1"><code>result</code></dt>
<dd>
<p>(string)
Result of the operation. Successful values are <code>created</code>, <code>deleted</code>, and
<code>updated</code>.</p>
<div class="paragraph">
<p>This parameter is only returned for successful operations.</p>
</div>
</dd>
<dt class="hdlist1"><code>_shards</code></dt>
<dd>
<p>(object)
Contains shard information for the operation.</p>
<div class="paragraph">
<p>This parameter is only returned for successful operations.</p>
</div>
<details open>
<summary class="title">Properties of <code>_shards</code></summary>
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><code>total</code></dt>
<dd>
<p>(integer)
Number of shards the operation attempted to execute on.</p>
</dd>
<dt class="hdlist1"><code>successful</code></dt>
<dd>
<p>(integer)
Number of shards the operation succeeded on.</p>
</dd>
<dt class="hdlist1"><code>failed</code></dt>
<dd>
<p>(integer)
Number of shards the operation attempted to execute on but failed.</p>
</dd>
</dl>
</div>
</div>
</details>
</dd>
<dt class="hdlist1"><code>_seq_no</code></dt>
<dd>
<p>(integer)
The sequence number assigned to the document for the operation.
Sequence numbers are used to ensure an older version of a document
doesn’t overwrite a newer version. See <a href="docs.html#optimistic-concurrency-control-index">Optimistic concurrency control</a>.</p>
<div class="paragraph">
<p>This parameter is only returned for successful operations.</p>
</div>
</dd>
<dt class="hdlist1"><code>_primary_term</code></dt>
<dd>
<p>(integer)
The primary term assigned to the document for the operation.
See <a href="docs.html#optimistic-concurrency-control-index">Optimistic concurrency control</a>.</p>
<div class="paragraph">
<p>This parameter is only returned for successful operations.</p>
</div>
</dd>
<dt class="hdlist1"><code>status</code></dt>
<dd>
<p>(integer)
HTTP status code returned for the operation.</p>
</dd>
<dt class="hdlist1"><code>error</code></dt>
<dd>
<p>(object)
Contains additional information about the failed operation.</p>
<div class="paragraph">
<p>The parameter is only returned for failed operations.</p>
</div>
<details open>
<summary class="title">Properties of <code>error</code></summary>
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1"><code>type</code></dt>
<dd>
<p>(string)
Error type for the operation.</p>
</dd>
<dt class="hdlist1"><code>reason</code></dt>
<dd>
<p>(string)
Reason for the failed operation.</p>
</dd>
<dt class="hdlist1"><code>index_uuid</code></dt>
<dd>
<p>(string)
The universally unique identifier (UUID) of the index associated with the failed
operation.</p>
</dd>
<dt class="hdlist1"><code>shard</code></dt>
<dd>
<p>(string)
ID of the shard associated with the failed operation.</p>
</dd>
<dt class="hdlist1"><code>index</code></dt>
<dd>
<p>(string)
Name of the index associated with the failed operation.</p>
</dd>
</dl>
</div>
</div>
</details>
</dd>
</dl>
</div>
</div>
</details>
</dd>
</dl>
</div>
</div>
</details>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-bulk-api-example">Examples</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _bulk
{ "index" : { "_index" : "test", "_id" : "1" } }
{ "field1" : "value1" }
{ "delete" : { "_index" : "test", "_id" : "2" } }
{ "create" : { "_index" : "test", "_id" : "3" } }
{ "field1" : "value3" }
{ "update" : {"_id" : "1", "_index" : "test"} }
{ "doc" : {"field2" : "value2"} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The API returns the following result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
   "took": 30,
   "errors": false,
   "items": [
      {
         "index": {
            "_index": "test",
            "_type": "_doc",
            "_id": "1",
            "_version": 1,
            "result": "created",
            "_shards": {
               "total": 2,
               "successful": 1,
               "failed": 0
            },
            "status": 201,
            "_seq_no" : 0,
            "_primary_term": 1
         }
      },
      {
         "delete": {
            "_index": "test",
            "_type": "_doc",
            "_id": "2",
            "_version": 1,
            "result": "not_found",
            "_shards": {
               "total": 2,
               "successful": 1,
               "failed": 0
            },
            "status": 404,
            "_seq_no" : 1,
            "_primary_term" : 2
         }
      },
      {
         "create": {
            "_index": "test",
            "_type": "_doc",
            "_id": "3",
            "_version": 1,
            "result": "created",
            "_shards": {
               "total": 2,
               "successful": 1,
               "failed": 0
            },
            "status": 201,
            "_seq_no" : 2,
            "_primary_term" : 3
         }
      },
      {
         "update": {
            "_index": "test",
            "_type": "_doc",
            "_id": "1",
            "_version": 2,
            "result": "updated",
            "_shards": {
                "total": 2,
                "successful": 1,
                "failed": 0
            },
            "status": 200,
            "_seq_no" : 3,
            "_primary_term" : 4
         }
      }
   ]
}</code></pre>
</div>
</div>
<h5 id="bulk-update" class="discrete">Bulk update example</h5>
<div class="paragraph">
<p>When using the <code>update</code> action, <code>retry_on_conflict</code> can be used as a field in
the action itself (not in the extra payload line), to specify how many
times an update should be retried in the case of a version conflict.</p>
</div>
<div class="paragraph">
<p>The <code>update</code> action payload supports the following options: <code>doc</code>
(partial document), <code>upsert</code>, <code>doc_as_upsert</code>, <code>script</code>, <code>params</code> (for
script), <code>lang</code> (for script), and <code>_source</code>. See update documentation for details on
the options. Example with update actions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _bulk
{ "update" : {"_id" : "1", "_index" : "index1", "retry_on_conflict" : 3} }
{ "doc" : {"field" : "value"} }
{ "update" : { "_id" : "0", "_index" : "index1", "retry_on_conflict" : 3} }
{ "script" : { "source": "ctx._source.counter += params.param1", "lang" : "painless", "params" : {"param1" : 1}}, "upsert" : {"counter" : 1}}
{ "update" : {"_id" : "2", "_index" : "index1", "retry_on_conflict" : 3} }
{ "doc" : {"field" : "value"}, "doc_as_upsert" : true }
{ "update" : {"_id" : "3", "_index" : "index1", "_source" : true} }
{ "doc" : {"field" : "value"} }
{ "update" : {"_id" : "4", "_index" : "index1"} }
{ "doc" : {"field" : "value"}, "_source": true}</code></pre>
</div>
</div>
<h5 id="bulk-failures-ex" class="discrete">Example with failed actions</h5>
<div class="paragraph">
<p>The following bulk API request includes operations that update non-existent
documents.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /_bulk
{ "update": {"_id": "5", "_index": "index1"} }
{ "doc": {"my_field": "foo"} }
{ "update": {"_id": "6", "_index": "index1"} }
{ "doc": {"my_field": "foo"} }
{ "create": {"_id": "7", "_index": "index1"} }
{ "my_field": "foo" }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because these operations cannot complete successfully, the API returns a
response with an <code>errors</code> flag of <code>true</code>.</p>
</div>
<div class="paragraph">
<p>The response also includes an <code>error</code> object for any failed operations. The
<code>error</code> object contains additional information about the failure, such as the
error type and reason.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "took": 486,
  "errors": true,
  "items": [
    {
      "update": {
        "_index": "index1",
        "_type" : "_doc",
        "_id": "5",
        "status": 404,
        "error": {
          "type": "document_missing_exception",
          "reason": "[_doc][5]: document missing",
          "index_uuid": "aAsFqTI0Tc2W0LCWgPNrOA",
          "shard": "0",
          "index": "index1"
        }
      }
    },
    {
      "update": {
        "_index": "index1",
        "_type" : "_doc",
        "_id": "6",
        "status": 404,
        "error": {
          "type": "document_missing_exception",
          "reason": "[_doc][6]: document missing",
          "index_uuid": "aAsFqTI0Tc2W0LCWgPNrOA",
          "shard": "0",
          "index": "index1"
        }
      }
    },
    {
      "create": {
        "_index": "index1",
        "_type" : "_doc",
        "_id": "7",
        "_version": 1,
        "result": "created",
        "_shards": {
          "total": 2,
          "successful": 1,
          "failed": 0
        },
        "_seq_no": 0,
        "_primary_term": 1,
        "status": 201
      }
    }
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To return only information about failed operations, use the
<a href="api-conventions.html#common-options-response-filtering"><code>filter_path</code></a> query parameter with an
argument of <code>items.*.error</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /_bulk?filter_path=items.*.error
{ "update": {"_id": "5", "_index": "index1"} }
{ "doc": {"my_field": "baz"} }
{ "update": {"_id": "6", "_index": "index1"} }
{ "doc": {"my_field": "baz"} }
{ "update": {"_id": "7", "_index": "index1"} }
{ "doc": {"my_field": "baz"} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The API returns the following result.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "items": [
    {
      "update": {
        "error": {
          "type": "document_missing_exception",
          "reason": "[_doc][5]: document missing",
          "index_uuid": "aAsFqTI0Tc2W0LCWgPNrOA",
          "shard": "0",
          "index": "index1"
        }
      }
    },
    {
      "update": {
        "error": {
          "type": "document_missing_exception",
          "reason": "[_doc][6]: document missing",
          "index_uuid": "aAsFqTI0Tc2W0LCWgPNrOA",
          "shard": "0",
          "index": "index1"
        }
      }
    }
  ]
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="docs-reindex">Reindex API</h3>
<titleabbrev>Reindex</titleabbrev>
<div class="paragraph">
<p>Copies documents from a <em>source</em> to a <em>destination</em>.</p>
</div>
<div class="paragraph">
<p>The source and destination can be any pre-existing index or index alias.
However, the source and destination must be different.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
<div class="paragraph">
<p>Reindex requires <a href="mapping-fields.html#mapping-source-field"><code>_source</code></a> to be enabled for
all documents in the source.</p>
</div>
<div class="paragraph">
<p>The destination should be configured as wanted before calling <code>_reindex</code>.
Reindex does not copy the settings from the source or its associated template.</p>
</div>
<div class="paragraph">
<p>Mappings, shard counts, replicas, and so on must be configured ahead of time.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _reindex
{
  "source": {
    "index": "my-index-000001"
  },
  "dest": {
    "index": "my-new-index-000001"
  }
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="docs-reindex-api-request">Request</h4>
<div class="paragraph">
<p><code>POST /_reindex</code></p>
</div>
</div>
<div class="sect3">
<h4 id="docs-reindex-api-prereqs">Prerequisites</h4>
<div class="ulist">
<ul>
<li>
<p>If reindexing from a remote cluster, you must explicitly allow the remote host
in the <code>reindex.remote.whitelist</code> setting of <code>opensearch.yml</code>. See
<a href="docs.html#reindex-from-remote">Reindex from remote</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="docs-reindex-api-desc">Description</h4>
<div class="paragraph">
<p>Extracts the <a href="mapping-fields.html#mapping-source-field">document source</a> from the source index and indexes the documents into the destination index.
You can copy all documents to the destination index, or reindex a subset of the documents.</p>
</div>
<div class="paragraph">
<p>Just like <a href="docs.html#docs-update-by-query"><code>_update_by_query</code></a>, <code>_reindex</code> gets a
snapshot of the source but its destination must be <strong>different</strong> so
version conflicts are unlikely. The <code>dest</code> element can be configured like the
index API to control optimistic concurrency control. Omitting
<code>version_type</code> or setting it to <code>internal</code> causes OpenSearch
to blindly dump documents into the destination, overwriting any that happen to have
the same ID.</p>
</div>
<div class="paragraph">
<p>Setting <code>version_type</code> to <code>external</code> causes OpenSearch to preserve the
<code>version</code> from the source, create any documents that are missing, and update
any documents that have an older version in the destination than they do
in the source.</p>
</div>
<div class="paragraph">
<p>Setting <code>op_type</code> to <code>create</code> causes <code>_reindex</code> to only create missing
documents in the destination. All existing documents will cause a version
conflict.</p>
</div>
<div class="paragraph">
<p>By default, version conflicts abort the <code>_reindex</code> process.
To continue reindexing if there are conflicts, set the <code>"conflicts"</code> request body parameter to <code>proceed</code>.
In this case, the response includes a count of the version conflicts that were encountered.
Note that the handling of other error types is unaffected by the <code>"conflicts"</code> parameter.</p>
</div>
<div class="sect4">
<h5 id="docs-reindex-task-api">Running reindex asynchronously</h5>
<div class="paragraph">
<p>If the request contains <code>wait_for_completion=false</code>, OpenSearch
performs some preflight checks, launches the request, and returns a
<a href="cluster.html#tasks"><code>task</code></a> you can use to cancel or get the status of the task.
OpenSearch creates a record of this task as a document at <code>.tasks/_doc/${taskId}</code>.
When you are done with a task, you should delete the task document so
OpenSearch can reclaim the space.</p>
</div>
</div>
<div class="sect4">
<h5 id="docs-reindex-from-multiple-sources">Reindex from multiple sources</h5>
<div class="paragraph">
<p>If you have many sources to reindex it is generally better to reindex them
one at a time rather than using a glob pattern to pick up multiple sources. That
way you can resume the process if there are any errors by removing the
partially completed source and starting over. It also makes
parallelizing the process fairly simple: split the list of sources to reindex
and run each list in parallel.</p>
</div>
<div class="paragraph">
<p>One-off bash scripts seem to work nicely for this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">for index in i1 i2 i3 i4 i5; do
  curl -HContent-Type:application/json -XPOST localhost:9200/_reindex?pretty -d'{
    "source": {
      "index": "'$index'"
    },
    "dest": {
      "index": "'$index'-reindexed"
    }
  }'
done</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="docs-reindex-throttle">Throttling</h5>
<div class="paragraph">
<p>Set <code>requests_per_second</code> to any positive decimal number (<code>1.4</code>, <code>6</code>,
<code>1000</code>, etc.) to throttle the rate at which <code>_reindex</code> issues batches of index
operations. Requests are throttled by padding each batch with a wait time.
To disable throttling, set <code>requests_per_second</code> to <code>-1</code>.</p>
</div>
<div class="paragraph">
<p>The throttling is done by waiting between batches so that the <code>scroll</code> that <code>_reindex</code>
uses internally can be given a timeout that takes into account the padding.
The padding time is the difference between the batch size divided by the
<code>requests_per_second</code> and the time spent writing. By default the batch size is
<code>1000</code>, so if <code>requests_per_second</code> is set to <code>500</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">target_time = 1000 / 500 per second = 2 seconds
wait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since the batch is issued as a single <code>_bulk</code> request, large batch sizes
cause OpenSearch to create many requests and then wait for a while before
starting the next set. This is "bursty" instead of "smooth".</p>
</div>
</div>
<div class="sect4">
<h5 id="docs-reindex-rethrottle">Rethrottling</h5>
<div class="paragraph">
<p>The value of <code>requests_per_second</code> can be changed on a running reindex using
the <code>_rethrottle</code> API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _reindex/r1A2WoRbTwKZ516z6NEs5A:36619/_rethrottle?requests_per_second=-1</code></pre>
</div>
</div>
<div class="paragraph">
<p>The task ID can be found using the <a href="cluster.html#tasks">tasks API</a>.</p>
</div>
<div class="paragraph">
<p>Just like when setting it on the Reindex API, <code>requests_per_second</code>
can be either <code>-1</code> to disable throttling or any decimal number
like <code>1.7</code> or <code>12</code> to throttle to that level. Rethrottling that speeds up the
query takes effect immediately, but rethrottling that slows down the query will
take effect after completing the current batch. This prevents scroll
timeouts.</p>
</div>
</div>
<div class="sect4">
<h5 id="docs-reindex-slice">Slicing</h5>
<div class="paragraph">
<p>Reindex supports <a href="paginate-search-results.html#slice-scroll">Sliced scroll</a> to parallelize the reindexing process.
This parallelization can improve efficiency and provide a convenient way to
break the request down into smaller parts.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Reindexing from remote clusters does not support
<a href="docs.html#docs-reindex-manual-slice">manual</a> or
<a href="docs.html#docs-reindex-automatic-slice">automatic slicing</a>.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="docs-reindex-manual-slice">Manual slicing</h6>
<div class="paragraph">
<p>Slice a reindex request manually by providing a slice id and total number of
slices to each request:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _reindex
{
  "source": {
    "index": "my-index-000001",
    "slice": {
      "id": 0,
      "max": 2
    }
  },
  "dest": {
    "index": "my-new-index-000001"
  }
}
POST _reindex
{
  "source": {
    "index": "my-index-000001",
    "slice": {
      "id": 1,
      "max": 2
    }
  },
  "dest": {
    "index": "my-new-index-000001"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can verify this works by:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET _refresh
POST my-new-index-000001/_search?size=0&amp;filter_path=hits.total</code></pre>
</div>
</div>
<div class="paragraph">
<p>which results in a sensible <code>total</code> like this one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "hits": {
    "total" : {
        "value": 120,
        "relation": "eq"
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="docs-reindex-automatic-slice">Automatic slicing</h6>
<div class="paragraph">
<p>You can also let <code>_reindex</code> automatically parallelize using <a href="paginate-search-results.html#slice-scroll">Sliced scroll</a> to
slice on <code>_id</code>. Use <code>slices</code> to specify the number of slices to use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _reindex?slices=5&amp;refresh
{
  "source": {
    "index": "my-index-000001"
  },
  "dest": {
    "index": "my-new-index-000001"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also this verify works by:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST my-new-index-000001/_search?size=0&amp;filter_path=hits.total</code></pre>
</div>
</div>
<div class="paragraph">
<p>which results in a sensible <code>total</code> like this one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "hits": {
    "total" : {
        "value": 120,
        "relation": "eq"
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Setting <code>slices</code> to <code>auto</code> will let OpenSearch choose the number of slices to
use. This setting will use one slice per shard, up to a certain limit. If there
are multiple sources, it will choose the number of
slices based on the index with the smallest number of shards.</p>
</div>
<div class="paragraph">
<p>Adding <code>slices</code> to <code>_reindex</code> just automates the manual process used in the
section above, creating sub-requests which means it has some quirks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>You can see these requests in the <a href="docs.html#docs-reindex-task-api">Tasks APIs</a>. These
sub-requests are "child" tasks of the task for the request with <code>slices</code>.</p>
</li>
<li>
<p>Fetching the status of the task for the request with <code>slices</code> only contains
the status of completed slices.</p>
</li>
<li>
<p>These sub-requests are individually addressable for things like cancelation
and rethrottling.</p>
</li>
<li>
<p>Rethrottling the request with <code>slices</code> will rethrottle the unfinished
sub-request proportionally.</p>
</li>
<li>
<p>Canceling the request with <code>slices</code> will cancel each sub-request.</p>
</li>
<li>
<p>Due to the nature of <code>slices</code> each sub-request won&#8217;t get a perfectly even
portion of the documents. All documents will be addressed, but some slices may
be larger than others. Expect larger slices to have a more even distribution.</p>
</li>
<li>
<p>Parameters like <code>requests_per_second</code> and <code>max_docs</code> on a request with
<code>slices</code> are distributed proportionally to each sub-request. Combine that with
the point above about distribution being uneven and you should conclude that
using <code>max_docs</code> with <code>slices</code> might not result in exactly <code>max_docs</code> documents
being reindexed.</p>
</li>
<li>
<p>Each sub-request gets a slightly different snapshot of the source,
though these are all taken at approximately the same time.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="docs-reindex-picking-slices">Picking the number of slices</h6>
<div class="paragraph">
<p>If slicing automatically, setting <code>slices</code> to <code>auto</code> will choose a reasonable
number for most indices. If slicing manually or otherwise tuning
automatic slicing, use these guidelines.</p>
</div>
<div class="paragraph">
<p>Query performance is most efficient when the number of <code>slices</code> is equal to the
number of shards in the index. If that number is large (e.g. 500),
choose a lower number as too many <code>slices</code> will hurt performance. Setting
<code>slices</code> higher than the number of shards generally does not improve efficiency
and adds overhead.</p>
</div>
<div class="paragraph">
<p>Indexing performance scales linearly across available resources with the
number of slices.</p>
</div>
<div class="paragraph">
<p>Whether query or indexing performance dominates the runtime depends on the
documents being reindexed and cluster resources.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="docs-reindex-routing">Reindex routing</h5>
<div class="paragraph">
<p>By default if <code>_reindex</code> sees a document with routing then the routing is
preserved unless it&#8217;s changed by the script. You can set <code>routing</code> on the
<code>dest</code> request to change this:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>keep</code></dt>
<dd>
<p>Sets the routing on the bulk request sent for each match to the routing on
the match. This is the default value.</p>
</dd>
<dt class="hdlist1"><code>discard</code></dt>
<dd>
<p>Sets the routing on the bulk request sent for each match to <code>null</code>.</p>
</dd>
<dt class="hdlist1"><code>=&lt;some text&gt;</code></dt>
<dd>
<p>Sets the routing on the bulk request sent for each match to all text after
the <code>=</code>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>For example, you can use the following request to copy all documents from
the <code>source</code> with the company name <code>cat</code> into the <code>dest</code>  with
routing set to <code>cat</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _reindex
{
  "source": {
    "index": "source",
    "query": {
      "match": {
        "company": "cat"
      }
    }
  },
  "dest": {
    "index": "dest",
    "routing": "=cat"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default <code>_reindex</code> uses scroll batches of 1000. You can change the
batch size with the <code>size</code> field in the <code>source</code> element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _reindex
{
  "source": {
    "index": "source",
    "size": 100
  },
  "dest": {
    "index": "dest",
    "routing": "=cat"
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="reindex-with-an-ingest-pipeline">Reindex with an ingest pipeline</h5>
<div class="paragraph">
<p>Reindex can also use the <a href="ingest.html">Ingest node</a> feature by specifying a
<code>pipeline</code> like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _reindex
{
  "source": {
    "index": "source"
  },
  "dest": {
    "index": "dest",
    "pipeline": "some_ingest_pipeline"
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="docs-reindex-api-query-params">Query parameters</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>refresh</code></dt>
<dd>
<p>(Optional, enum) If <code>true</code>, OpenSearch refreshes the affected shards to make this
operation visible to search, if <code>wait_for</code> then wait for a refresh to make
this operation visible to search, if <code>false</code> do nothing with refreshes.
Valid values: <code>true</code>, <code>false</code>, <code>wait_for</code>. Default: <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>timeout</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, <a href="api-conventions.html#time-units">time units</a>)
Period each indexing waits for the following operations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="docs.html#index-creation">Automatic index creation</a></p>
</li>
<li>
<p><a href="dynamic-mapping.html">Dynamic mapping</a> updates</p>
</li>
<li>
<p><a href="docs.html#index-wait-for-active-shards">Waiting for active shards</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Defaults to <code>1m</code> (one minute). This guarantees OpenSearch waits for at least the
timeout before failing. The actual wait time could be longer, particularly when
multiple waits occur.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>wait_for_active_shards</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string) The number of shard copies that must be active before
proceeding with the operation. Set to <code>all</code> or any positive integer up
to the total number of shards in the index (<code>number_of_replicas+1</code>).
Default: 1, the primary shard.</p>
</div>
<div class="paragraph">
<p>See <a href="docs.html#index-wait-for-active-shards">Active shards</a>.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>wait_for_completion</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, the request blocks until the operation is complete.
Defaults to <code>true</code>.</p>
</dd>
<dt class="hdlist1"><code>requests_per_second</code></dt>
<dd>
<p>(Optional, integer) The throttle for this request in sub-requests per second.
Defaults to <code>-1</code> (no throttle).</p>
</dd>
<dt class="hdlist1"><code>require_alias</code></dt>
<dd>
<p>(Optional, Boolean)
If <code>true</code>, the destination must be an <a href="indices.html#indices-aliases">index alias</a>. Defaults to
<code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>scroll</code></dt>
<dd>
<p>(Optional, <a href="api-conventions.html#time-units">time units</a>) Specifies how long a consistent view of
the index should be maintained for scrolled search.</p>
</dd>
<dt class="hdlist1"><code>slices</code></dt>
<dd>
<p>(Optional, integer) The number of slices this task should be divided into.
Defaults to 1 meaning the task isn&#8217;t sliced into subtasks.</p>
</dd>
<dt class="hdlist1"><code>max_docs</code></dt>
<dd>
<p>(Optional, integer) Maximum number of documents to process. Defaults to all
documents.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-reindex-api-request-body">Request body</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>conflicts</code></dt>
<dd>
<p>(Optional, enum) Set to <code>proceed</code> to continue reindexing even if there are conflicts.
Defaults to <code>abort</code>.</p>
</dd>
<dt class="hdlist1"><code>source</code></dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>index</code></dt>
<dd>
<p>(Required, string) The name of the index or index alias you are copying <em>from</em>.
Also accepts a comma-separated list to reindex from multiple sources.</p>
</dd>
<dt class="hdlist1"><code>max_docs</code></dt>
<dd>
<p>(Optional, integer) The maximum number of documents to reindex.</p>
</dd>
<dt class="hdlist1"><code>query</code></dt>
<dd>
<p>(Optional, <a href="query-dsl.html">query object</a>) Specifies the documents to reindex using the Query DSL.</p>
</dd>
<dt class="hdlist1"><code>remote</code></dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>host</code></dt>
<dd>
<p>(Optional, string) The URL for the remote instance of OpenSearch that you want to index <em>from</em>.
Required when indexing from remote.</p>
</dd>
<dt class="hdlist1"><code>username</code></dt>
<dd>
<p>(Optional, string) The username to use for authentication with the remote host.</p>
</dd>
<dt class="hdlist1"><code>password</code></dt>
<dd>
<p>(Optional, string) The password to use for authentication with the remote host.</p>
</dd>
<dt class="hdlist1"><code>socket_timeout</code></dt>
<dd>
<p>(Optional, <a href="api-conventions.html#time-units">time units</a>) The remote socket read timeout. Defaults to 30 seconds.</p>
</dd>
<dt class="hdlist1"><code>connect_timeout</code></dt>
<dd>
<p>(Optional, <a href="api-conventions.html#time-units">time units</a>) The remote connection timeout. Defaults to 30 seconds.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>size</code></dt>
<dd>
<p>{Optional, integer) The number of documents to index per batch.
Use when indexing from remote to ensure that the batches fit within the on-heap buffer,
which defaults to a maximum size of 100 MB.</p>
</dd>
<dt class="hdlist1"><code>slice</code></dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>id</code></dt>
<dd>
<p>(Optional, integer) Slice ID for <a href="docs.html#docs-reindex-manual-slice">manual slicing</a>.</p>
</dd>
<dt class="hdlist1"><code>max</code></dt>
<dd>
<p>(Optional, integer) Total number of slices.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>sort</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, list) A comma-separated list of <code>&lt;field&gt;:&lt;direction&gt;</code> pairs to sort by before indexing.
Use in conjunction with <code>max_docs</code> to control what documents are reindexed.</p>
</div>
<div class="paragraph">
<p>Sort in reindex is deprecated and is not guaranteed to index documents in order. If used in combination with <code>max_docs</code>&#44; consider using a query filter instead.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>_source</code></dt>
<dd>
<p>(Optional, string) If <code>true</code> reindexes all source fields.
Set to a list to reindex select fields.
Defaults to <code>true</code>.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>dest</code></dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>index</code></dt>
<dd>
<p>(Required, string) The name of the index or index alias you are copying <em>to</em>.</p>
</dd>
<dt class="hdlist1"><code>version_type</code></dt>
<dd>
<p>(Optional, enum) The versioning to use for the indexing operation.
Valid values: <code>internal</code>, <code>external</code>, <code>external_gt</code>, <code>external_gte</code>.
See <a href="docs.html#index-version-types">Version types</a> for more information.</p>
</dd>
<dt class="hdlist1"><code>op_type</code></dt>
<dd>
<p>(Optional, enum) Set to create to only index documents that do not already exist (put if absent).
Valid values: <code>index</code>, <code>create</code>. Defaults to <code>index</code>.</p>
</dd>
<dt class="hdlist1"><code>type</code></dt>
<dd>
<p>(Optional, string)
Types are deprecated.
<a href="mapping-fields.html#mapping-type-field">Document type</a> for reindexed documents.
Defaults to <code>_doc</code>.</p>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Types in source indices are always ignored, also when not specifying a
destination <code>type</code>. If explicitly specifying destination <code>type</code>, the specified
type must match the type in the destination index or be either unspecified or
the special value <code>_doc</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1"><code>script</code></dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>source</code></dt>
<dd>
<p>(Optional, string) The script to run to update the document source or metadata when reindexing.</p>
</dd>
<dt class="hdlist1"><code>lang</code></dt>
<dd>
<p>(Optional, enum) The script language: <code>painless</code>, <code>expression</code>, <code>mustache</code>, <code>java</code>.
For more information, see <a href="modules-scripting.html">Scripting</a>.</p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-reindex-api-response-body">Response body</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>took</code></dt>
<dd>
<p>(integer) The total milliseconds the entire operation took.</p>
</dd>
<dt class="hdlist1"><code>timed_out</code></dt>
<dd>
<p>{Boolean) This flag is set to <code>true</code> if any of the requests executed during the
reindex timed out.</p>
</dd>
<dt class="hdlist1"><code>total</code></dt>
<dd>
<p>(integer) The number of documents that were successfully processed.</p>
</dd>
<dt class="hdlist1"><code>updated</code></dt>
<dd>
<p>(integer) The number of documents that were successfully updated,
i.e. a document with same ID already existed prior to reindex updating it.</p>
</dd>
<dt class="hdlist1"><code>created</code></dt>
<dd>
<p>(integer) The number of documents that were successfully created.</p>
</dd>
<dt class="hdlist1"><code>deleted</code></dt>
<dd>
<p>(integer) The number of documents that were successfully deleted.</p>
</dd>
<dt class="hdlist1"><code>batches</code></dt>
<dd>
<p>(integer) The number of scroll responses pulled back by the reindex.</p>
</dd>
<dt class="hdlist1"><code>noops</code></dt>
<dd>
<p>(integer) The number of documents that were ignored because the script used for
the reindex returned a <code>noop</code> value for <code>ctx.op</code>.</p>
</dd>
<dt class="hdlist1"><code>version_conflicts</code></dt>
<dd>
<p>(integer) The number of version conflicts that reindex hits.</p>
</dd>
<dt class="hdlist1"><code>retries</code></dt>
<dd>
<p>(integer) The number of retries attempted by reindex. <code>bulk</code> is the number of bulk
actions retried and <code>search</code> is the number of search actions retried.</p>
</dd>
<dt class="hdlist1"><code>throttled_millis</code></dt>
<dd>
<p>(integer) Number of milliseconds the request slept to conform to <code>requests_per_second</code>.</p>
</dd>
<dt class="hdlist1"><code>requests_per_second</code></dt>
<dd>
<p>(integer) The number of requests per second effectively executed during the reindex.</p>
</dd>
<dt class="hdlist1"><code>throttled_until_millis</code></dt>
<dd>
<p>(integer) This field should always be equal to zero in a <code>_reindex</code> response. It only
has meaning when using the <a href="docs.html#docs-reindex-task-api">Task API</a>, where it
indicates the next time (in milliseconds since epoch) a throttled request will be
executed again in order to conform to <code>requests_per_second</code>.</p>
</dd>
<dt class="hdlist1"><code>failures</code></dt>
<dd>
<p>(array) Array of failures if there were any unrecoverable errors during the process. If
this is non-empty then the request aborted because of those failures. Reindex
is implemented using batches and any failure causes the entire process to abort
but all failures in the current batch are collected into the array. You can use
the <code>conflicts</code> option to prevent reindex from aborting on version conflicts.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-reindex-api-example">Examples</h4>
<div class="sect4">
<h5 id="docs-reindex-select-query">Reindex select documents with a query</h5>
<div class="paragraph">
<p>You can limit the documents by adding a query to the <code>source</code>.
For example, the following request only copies documents with a <code>user.id</code> of <code>bilbo</code> into <code>my-new-index-000001</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _reindex
{
  "source": {
    "index": "my-index-000001",
    "query": {
      "term": {
        "user.id": "bilbo"
      }
    }
  },
  "dest": {
    "index": "my-new-index-000001"
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="docs-reindex-select-max-docs">Reindex select documents with <code>max_docs</code></h5>
<div class="paragraph">
<p>You can limit the number of processed documents by setting <code>max_docs</code>.
For example, this request copies a single document from <code>my-index-000001</code> to
<code>my-new-index-000001</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _reindex
{
  "max_docs": 1,
  "source": {
    "index": "my-index-000001"
  },
  "dest": {
    "index": "my-new-index-000001"
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="docs-reindex-multiple-sources">Reindex from multiple sources</h5>
<div class="paragraph">
<p>The <code>index</code> attribute in <code>source</code> can be a list, allowing you to copy from lots
of sources in one request. This will copy documents from the
<code>my-index-000001</code> and <code>my-index-000002</code> indices:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _reindex
{
  "source": {
    "index": ["my-index-000001", "my-index-000002"]
  },
  "dest": {
    "index": "my-new-index-000002"
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
The Reindex API makes no effort to handle ID collisions so the last
document written will "win" but the order isn&#8217;t usually predictable so it is
not a good idea to rely on this behavior. Instead, make sure that IDs are unique
using a script.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="docs-reindex-filter-source">Reindex select fields with a source filter</h5>
<div class="paragraph">
<p>You can use source filtering to reindex a subset of the fields in the original documents.
For example, the following request only reindexes the <code>user.id</code> and <code>_doc</code> fields of each document:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _reindex
{
  "source": {
    "index": "my-index-000001",
    "_source": ["user.id", "_doc"]
  },
  "dest": {
    "index": "my-new-index-000001"
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="docs-reindex-change-name">Reindex to change the name of a field</h5>
<div class="paragraph">
<p><code>_reindex</code> can be used to build a copy of an index with renamed fields. Say you
create an index containing documents that look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST my-index-000001/_doc/1?refresh
{
  "text": "words words",
  "flag": "foo"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>but you don&#8217;t like the name <code>flag</code> and want to replace it with <code>tag</code>.
<code>_reindex</code> can create the other index for you:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _reindex
{
  "source": {
    "index": "my-index-000001"
  },
  "dest": {
    "index": "my-new-index-000001"
  },
  "script": {
    "source": "ctx._source.tag = ctx._source.remove(\"flag\")"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now you can get the new document:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET my-new-index-000001/_doc/1</code></pre>
</div>
</div>
<div class="paragraph">
<p>which will return:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "found": true,
  "_id": "1",
  "_index": "my-new-index-000001",
  "_type": "_doc",
  "_version": 1,
  "_seq_no": 44,
  "_primary_term": 1,
  "_source": {
    "text": "words words",
    "tag": "foo"
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="docs-reindex-daily-indices">Reindex daily indices</h5>
<div class="paragraph">
<p>You can use <code>_reindex</code> in combination with <a href="modules-scripting-painless.html">Painless</a> to reindex
daily indices to apply a new template to the existing documents.</p>
</div>
<div class="paragraph">
<p>Assuming you have indices that contain documents like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT metricbeat-2016.05.30/_doc/1?refresh
{"system.cpu.idle.pct": 0.908}
PUT metricbeat-2016.05.31/_doc/1?refresh
{"system.cpu.idle.pct": 0.105}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The new template for the <code>metricbeat-*</code> indices is already loaded into OpenSearch,
but it applies only to the newly created indices. Painless can be used to reindex
the existing documents and apply the new template.</p>
</div>
<div class="paragraph">
<p>The script below extracts the date from the index name and creates a new index
with <code>-1</code> appended. All data from <code>metricbeat-2016.05.31</code> will be reindexed
into <code>metricbeat-2016.05.31-1</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _reindex
{
  "source": {
    "index": "metricbeat-*"
  },
  "dest": {
    "index": "metricbeat"
  },
  "script": {
    "lang": "painless",
    "source": "ctx._index = 'metricbeat-' + (ctx._index.substring('metricbeat-'.length(), ctx._index.length())) + '-1'"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>All documents from the previous metricbeat indices can now be found in the <code>*-1</code> indices.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET metricbeat-2016.05.30-1/_doc/1
GET metricbeat-2016.05.31-1/_doc/1</code></pre>
</div>
</div>
<div class="paragraph">
<p>The previous method can also be used in conjunction with <a href="docs.html#docs-reindex-change-name">changing a field name</a>
to load only the existing data into the new index and rename any fields if needed.</p>
</div>
</div>
<div class="sect4">
<h5 id="docs-reindex-api-subset">Extract a random subset of the source</h5>
<div class="paragraph">
<p><code>_reindex</code> can be used to extract a random subset of the source for testing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _reindex
{
  "max_docs": 10,
  "source": {
    "index": "my-index-000001",
    "query": {
      "function_score" : {
        "random_score" : {},
        "min_score" : 0.9    <b class="conum">(1)</b>
      }
    }
  },
  "dest": {
    "index": "my-new-index-000001"
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>You may need to adjust the <code>min_score</code> depending on the relative amount of
data extracted from source.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="reindex-scripts">Modify documents during reindexing</h5>
<div class="paragraph">
<p>Like <code>_update_by_query</code>, <code>_reindex</code> supports a script that modifies the
document. Unlike <code>_update_by_query</code>, the script is allowed to modify the
document&#8217;s metadata. This example bumps the version of the source document:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _reindex
{
  "source": {
    "index": "my-index-000001"
  },
  "dest": {
    "index": "my-new-index-000001",
    "version_type": "external"
  },
  "script": {
    "source": "if (ctx._source.foo == 'bar') {ctx._version++; ctx._source.remove('foo')}",
    "lang": "painless"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Just as in <code>_update_by_query</code>, you can set <code>ctx.op</code> to change the
operation that is executed on the destination:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>noop</code></dt>
<dd>
<p>Set <code>ctx.op = "noop"</code> if your script decides that the document doesn&#8217;t have
to be indexed in the destination. This no operation will be reported
in the <code>noop</code> counter in the <a href="docs.html#docs-reindex-api-response-body">response body</a>.</p>
</dd>
<dt class="hdlist1"><code>delete</code></dt>
<dd>
<p>Set <code>ctx.op = "delete"</code> if your script decides that the document must be
 deleted from the destination. The deletion will be reported in the
 <code>deleted</code> counter in the <a href="docs.html#docs-reindex-api-response-body">response body</a>.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Setting <code>ctx.op</code> to anything else will return an error, as will setting any
other field in <code>ctx</code>.</p>
</div>
<div class="paragraph">
<p>Think of the possibilities! Just be careful; you are able to
change:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>_id</code></p>
</li>
<li>
<p><code>_index</code></p>
</li>
<li>
<p><code>_version</code></p>
</li>
<li>
<p><code>_routing</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Setting <code>_version</code> to <code>null</code> or clearing it from the <code>ctx</code> map is just like not
sending the version in an indexing request; it will cause the document to be
overwritten in the destination regardless of the version on the target or the
version type you use in the <code>_reindex</code> request.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="reindex-from-remote">Reindex from remote</h4>
<div class="paragraph">
<p>Reindex supports reindexing from a remote OpenSearch cluster:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _reindex
{
  "source": {
    "remote": {
      "host": "http://otherhost:9200",
      "username": "user",
      "password": "pass"
    },
    "index": "my-index-000001",
    "query": {
      "match": {
        "test": "data"
      }
    }
  },
  "dest": {
    "index": "my-new-index-000001"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>host</code> parameter must contain a scheme, host, port (e.g.
<code><a href="https://otherhost:9200" class="bare">https://otherhost:9200</a></code>), and optional path (e.g. <code><a href="https://otherhost:9200/proxy" class="bare">https://otherhost:9200/proxy</a></code>).
The <code>username</code> and <code>password</code> parameters are optional, and when they are present <code>_reindex</code>
will connect to the remote OpenSearch node using basic auth. Be sure to use <code>https</code> when
using basic auth or the password will be sent in plain text.
There are a range of <a href="docs.html#reindex-ssl">settings</a> available to configure the behaviour of the
 <code>https</code> connection.</p>
</div>
<div class="paragraph">
<p>Remote hosts have to be explicitly allowed in opensearch.yml using the
<code>reindex.remote.whitelist</code> property. It can be set to a comma delimited list
of allowed remote <code>host</code> and <code>port</code> combinations. Scheme is
ignored, only the host and port are used. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">reindex.remote.whitelist: "otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The list of allowed hosts must be configured on any nodes that will coordinate the reindex.</p>
</div>
<div class="paragraph">
<p>This feature should work with remote clusters of any version of OpenSearch
you are likely to find. This should allow you to upgrade from any version of
OpenSearch to the current version by reindexing from a cluster of the old
version.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
OpenSearch does not have forward compatibility across major versions. For example, you cannot reindex from a 2.x cluster into a 1.x cluster.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To enable queries sent to older versions of OpenSearch the <code>query</code> parameter
is sent directly to the remote host without validation or modification.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Reindexing from remote clusters does not support
<a href="docs.html#docs-reindex-manual-slice">manual</a> or
<a href="docs.html#docs-reindex-automatic-slice">automatic slicing</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Reindexing from a remote server uses an on-heap buffer that defaults to a
maximum size of 100mb. If the remote index includes very large documents you&#8217;ll
need to use a smaller batch size. The example below sets the batch size to <code>10</code>
which is very, very small.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _reindex
{
  "source": {
    "remote": {
      "host": "http://otherhost:9200"
    },
    "index": "source",
    "size": 10,
    "query": {
      "match": {
        "test": "data"
      }
    }
  },
  "dest": {
    "index": "dest"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to set the socket read timeout on the remote connection
with the <code>socket_timeout</code> field and the connection timeout with the
<code>connect_timeout</code> field. Both default to 30 seconds. This example
sets the socket read timeout to one minute and the connection timeout to 10
seconds:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST _reindex
{
  "source": {
    "remote": {
      "host": "http://otherhost:9200",
      "socket_timeout": "1m",
      "connect_timeout": "10s"
    },
    "index": "source",
    "query": {
      "match": {
        "test": "data"
      }
    }
  },
  "dest": {
    "index": "dest"
  }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="reindex-ssl">Configuring SSL parameters</h5>
<div class="paragraph">
<p>Reindex from remote supports configurable SSL settings. These must be
specified in the <code>opensearch.yml</code> file, with the exception of the
secure settings, which you add in the OpenSearch keystore.
It is not possible to configure SSL in the body of the <code>_reindex</code> request.</p>
</div>
<div class="paragraph">
<p>The following settings are supported:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>reindex.ssl.certificate_authorities</code></dt>
<dd>
<p>List of paths to PEM encoded certificate files that should be trusted.
You cannot specify both <code>reindex.ssl.certificate_authorities</code> and
<code>reindex.ssl.truststore.path</code>.</p>
</dd>
<dt class="hdlist1"><code>reindex.ssl.truststore.path</code></dt>
<dd>
<p>The path to the Java Keystore file that contains the certificates to trust.
This keystore can be in "JKS" or "PKCS#12" format.
You cannot specify both <code>reindex.ssl.certificate_authorities</code> and
<code>reindex.ssl.truststore.path</code>.</p>
</dd>
<dt class="hdlist1"><code>reindex.ssl.truststore.password</code></dt>
<dd>
<p>The password to the truststore (<code>reindex.ssl.truststore.path</code>).
This setting cannot be used with <code>reindex.ssl.truststore.secure_password</code>.</p>
</dd>
<dt class="hdlist1"><code>reindex.ssl.truststore.secure_password</code> (<a href="settings.html#secure-settings">Secure</a>)</dt>
<dd>
<p>The password to the truststore (<code>reindex.ssl.truststore.path</code>).
This setting cannot be used with <code>reindex.ssl.truststore.password</code>.</p>
</dd>
<dt class="hdlist1"><code>reindex.ssl.truststore.type</code></dt>
<dd>
<p>The type of the truststore (<code>reindex.ssl.truststore.path</code>).
Must be either <code>jks</code> or <code>PKCS12</code>. If the truststore path ends in ".p12", ".pfx"
or "pkcs12", this setting defaults to <code>PKCS12</code>. Otherwise, it defaults to <code>jks</code>.</p>
</dd>
<dt class="hdlist1"><code>reindex.ssl.verification_mode</code></dt>
<dd>
<p>Indicates the type of verification to protect against man in the middle attacks
and certificate forgery.
One of <code>full</code> (verify the hostname and the certificate path), <code>certificate</code>
(verify the certificate path, but not the hostname) or <code>none</code> (perform no
verification - this is strongly discouraged in production environments).
Defaults to <code>full</code>.</p>
</dd>
<dt class="hdlist1"><code>reindex.ssl.certificate</code></dt>
<dd>
<p>Specifies the path to the PEM encoded certificate (or certificate chain) to be
used for HTTP client authentication (if required by the remote cluster)
This setting requires that <code>reindex.ssl.key</code> also be set.
You cannot specify both <code>reindex.ssl.certificate</code> and <code>reindex.ssl.keystore.path</code>.</p>
</dd>
<dt class="hdlist1"><code>reindex.ssl.key</code></dt>
<dd>
<p>Specifies the path to the PEM encoded private key associated with the
certificate used for client authentication (<code>reindex.ssl.certificate</code>).
You cannot specify both <code>reindex.ssl.key</code> and <code>reindex.ssl.keystore.path</code>.</p>
</dd>
<dt class="hdlist1"><code>reindex.ssl.key_passphrase</code></dt>
<dd>
<p>Specifies the passphrase to decrypt the PEM encoded private key
(<code>reindex.ssl.key</code>) if it is encrypted.
Cannot be used with <code>reindex.ssl.secure_key_passphrase</code>.</p>
</dd>
<dt class="hdlist1"><code>reindex.ssl.secure_key_passphrase</code> (<a href="settings.html#secure-settings">Secure</a>)</dt>
<dd>
<p>Specifies the passphrase to decrypt the PEM encoded private key
(<code>reindex.ssl.key</code>) if it is encrypted.
Cannot be used with <code>reindex.ssl.key_passphrase</code>.</p>
</dd>
<dt class="hdlist1"><code>reindex.ssl.keystore.path</code></dt>
<dd>
<p>Specifies the path to the keystore that contains a private key and certificate
to be used for HTTP client authentication (if required by the remote cluster).
This keystore can be in "JKS" or "PKCS#12" format.
You cannot specify both <code>reindex.ssl.key</code> and <code>reindex.ssl.keystore.path</code>.</p>
</dd>
<dt class="hdlist1"><code>reindex.ssl.keystore.type</code></dt>
<dd>
<p>The type of the keystore (<code>reindex.ssl.keystore.path</code>). Must be either <code>jks</code> or <code>PKCS12</code>.
If the keystore path ends in ".p12", ".pfx" or "pkcs12", this setting defaults
to <code>PKCS12</code>. Otherwise, it defaults to <code>jks</code>.</p>
</dd>
<dt class="hdlist1"><code>reindex.ssl.keystore.password</code></dt>
<dd>
<p>The password to the keystore (<code>reindex.ssl.keystore.path</code>). This setting cannot be used
with <code>reindex.ssl.keystore.secure_password</code>.</p>
</dd>
<dt class="hdlist1"><code>reindex.ssl.keystore.secure_password</code> (<a href="settings.html#secure-settings">Secure</a>)</dt>
<dd>
<p>The password to the keystore (<code>reindex.ssl.keystore.path</code>).
This setting cannot be used with <code>reindex.ssl.keystore.password</code>.</p>
</dd>
<dt class="hdlist1"><code>reindex.ssl.keystore.key_password</code></dt>
<dd>
<p>The password for the key in the keystore (<code>reindex.ssl.keystore.path</code>).
Defaults to the keystore password. This setting cannot be used with
<code>reindex.ssl.keystore.secure_key_password</code>.</p>
</dd>
<dt class="hdlist1"><code>reindex.ssl.keystore.secure_key_password</code> (<a href="settings.html#secure-settings">Secure</a>)</dt>
<dd>
<p>The password for the key in the keystore (<code>reindex.ssl.keystore.path</code>).
Defaults to the keystore password. This setting cannot be used with
<code>reindex.ssl.keystore.key_password</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="docs-termvectors">Term vectors API</h3>
<titleabbrev>Term vectors</titleabbrev>
<div class="paragraph">
<p>Retrieves information and statistics for terms in the fields of a particular document.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /my-index-000001/_termvectors/1</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="docs-termvectors-api-request">Request</h4>
<div class="paragraph">
<p><code>GET /&lt;index&gt;/_termvectors/&lt;_id&gt;</code></p>
</div>
</div>
<div class="sect3">
<h4 id="docs-termvectors-api-desc">Description</h4>
<div class="paragraph">
<p>You can retrieve term vectors for documents stored in the index or
for <em>artificial</em> documents passed in the body of the request.</p>
</div>
<div class="paragraph">
<p>You can specify the fields you are interested in through the <code>fields</code> parameter,
or by adding the fields to the request body.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /my-index-000001/_termvectors/1?fields=message</code></pre>
</div>
</div>
<div class="paragraph">
<p>Fields can be specified using wildcards, similar to the <a href="full-text-queries.html#query-dsl-multi-match-query">multi match query</a>.</p>
</div>
<div class="paragraph">
<p>Term vectors are <a href="docs.html#realtime">real-time</a> by default, not near real-time.
This can be changed by setting <code>realtime</code> parameter to <code>false</code>.</p>
</div>
<div class="paragraph">
<p>You can request three types of values: <em>term information</em>, <em>term statistics</em>
and <em>field statistics</em>. By default, all term information and field
statistics are returned for all fields but term statistics are excluded.</p>
</div>
<div class="sect4">
<h5 id="docs-termvectors-api-term-info">Term information</h5>
<div class="ulist">
<ul>
<li>
<p>term frequency in the field (always returned)</p>
</li>
<li>
<p>term positions (<code>positions</code> : true)</p>
</li>
<li>
<p>start and end offsets (<code>offsets</code> : true)</p>
</li>
<li>
<p>term payloads (<code>payloads</code> : true), as base64 encoded bytes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the requested information wasn&#8217;t stored in the index, it will be
computed on the fly if possible. Additionally, term vectors could be computed
for documents not even existing in the index, but instead provided by the user.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Start and end offsets assume UTF-16 encoding is being used. If you want to use
these offsets in order to get the original text that produced this token, you
should make sure that the string you are taking a sub-string of is also encoded
using UTF-16.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="docs-termvectors-api-term-stats">Term statistics</h5>
<div class="paragraph">
<p>Setting <code>term_statistics</code> to <code>true</code> (default is <code>false</code>) will
return</p>
</div>
<div class="ulist">
<ul>
<li>
<p>total term frequency (how often a term occurs in all documents)<br></p>
</li>
<li>
<p>document frequency (the number of documents containing the current
term)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>By default these values are not returned since term statistics can
have a serious performance impact.</p>
</div>
</div>
<div class="sect4">
<h5 id="docs-termvectors-api-field-stats">Field statistics</h5>
<div class="paragraph">
<p>Setting <code>field_statistics</code> to <code>false</code> (default is <code>true</code>) will
omit :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>document count (how many documents contain this field)</p>
</li>
<li>
<p>sum of document frequencies (the sum of document frequencies for all
terms in this field)</p>
</li>
<li>
<p>sum of total term frequencies (the sum of total term frequencies of
each term in this field)</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="docs-termvectors-api-terms-filtering">Terms filtering</h5>
<div class="paragraph">
<p>With the parameter <code>filter</code>, the terms returned could also be filtered based
on their tf-idf scores. This could be useful in order find out a good
characteristic vector of a document. This feature works in a similar manner to
the <a href="specialized-queries.html#mlt-query-term-selection">second phase</a> of the
<a href="specialized-queries.html#query-dsl-mlt-query">More Like This Query</a>. See <a href="docs.html#docs-termvectors-terms-filtering">example 5</a>
for usage.</p>
</div>
<div class="paragraph">
<p>The following sub-parameters are supported:</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>max_num_terms</code>
</td>
<td class="hdlist2">
<p>Maximum number of terms that must be returned per field. Defaults to <code>25</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>min_term_freq</code>
</td>
<td class="hdlist2">
<p>Ignore words with less than this frequency in the source doc. Defaults to <code>1</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>max_term_freq</code>
</td>
<td class="hdlist2">
<p>Ignore words with more than this frequency in the source doc. Defaults to unbounded.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>min_doc_freq</code>
</td>
<td class="hdlist2">
<p>Ignore terms which do not occur in at least this many docs. Defaults to <code>1</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>max_doc_freq</code>
</td>
<td class="hdlist2">
<p>Ignore words which occur in more than this many docs. Defaults to unbounded.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>min_word_length</code>
</td>
<td class="hdlist2">
<p>The minimum word length below which words will be ignored. Defaults to <code>0</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>max_word_length</code>
</td>
<td class="hdlist2">
<p>The maximum word length above which words will be ignored. Defaults to unbounded (<code>0</code>).</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="docs-termvectors-api-behavior">Behaviour</h4>
<div class="paragraph">
<p>The term and field statistics are not accurate. Deleted documents
are not taken into account. The information is only retrieved for the
shard the requested document resides in.
The term and field statistics are therefore only useful as relative measures
whereas the absolute numbers have no meaning in this context. By default,
when requesting term vectors of artificial documents, a shard to get the statistics
from is randomly selected. Use <code>routing</code> only to hit a particular shard.</p>
</div>
</div>
<div class="sect3">
<h4 id="docs-termvectors-api-path-params">Path parameters</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>&lt;index&gt;</code></dt>
<dd>
<p>(Required, string) Name of the index that contains the document.</p>
</dd>
<dt class="hdlist1"><code>&lt;_id&gt;</code></dt>
<dd>
<p>(Optional, string) Unique identifier of the document.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-termvectors-api-query-params">Query parameters</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>fields</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string)
Comma-separated list or wildcard expressions of fields
to include in the statistics.</p>
</div>
<div class="paragraph">
<p>Used as the default list
unless a specific field list is provided
in the <code>completion_fields</code> or <code>fielddata_fields</code> parameters.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>field_statistics</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, the response includes the document count, sum of document frequencies,
and sum of total term frequencies.
Defaults to <code>true</code>.</p>
</dd>
<dt class="hdlist1"><code>&lt;offsets&gt;</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, the response includes term offsets.
Defaults to <code>true</code>.</p>
</dd>
<dt class="hdlist1"><code>payloads</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, the response includes term payloads.
Defaults to <code>true</code>.</p>
</dd>
<dt class="hdlist1"><code>positions</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, the response includes term positions.
Defaults to <code>true</code>.</p>
</dd>
<dt class="hdlist1"><code>preference</code></dt>
<dd>
<p>(Optional, string) Specifies the node or shard the operation should be
performed on. Random by default.</p>
</dd>
<dt class="hdlist1"><code>routing</code></dt>
<dd>
<p>(Optional, string) Target the specified primary shard.</p>
</dd>
<dt class="hdlist1"><code>realtime</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, the request is real-time as opposed to near-real-time.
Defaults to <code>true</code>. See <a href="docs.html#realtime">Realtime</a>.</p>
</dd>
<dt class="hdlist1"><code>term_statistics</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, the response includes term frequency and document frequency.
Defaults to <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>version</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, returns the document version as part of a hit.</p>
</dd>
<dt class="hdlist1"><code>version_type</code></dt>
<dd>
<p>(Optional, enum) Specific version type: <code>internal</code>, <code>external</code>,
<code>external_gte</code>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-termvectors-api-example">Examples</h4>
<div class="sect4">
<h5 id="docs-termvectors-api-stored-termvectors">Returning stored term vectors</h5>
<div class="paragraph">
<p>First, we create an index that stores term vectors, payloads etc. :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT /my-index-000001
{ "mappings": {
    "properties": {
      "text": {
        "type": "text",
        "term_vector": "with_positions_offsets_payloads",
        "store" : true,
        "analyzer" : "fulltext_analyzer"
       },
       "fullname": {
        "type": "text",
        "term_vector": "with_positions_offsets_payloads",
        "analyzer" : "fulltext_analyzer"
      }
    }
  },
  "settings" : {
    "index" : {
      "number_of_shards" : 1,
      "number_of_replicas" : 0
    },
    "analysis": {
      "analyzer": {
        "fulltext_analyzer": {
          "type": "custom",
          "tokenizer": "whitespace",
          "filter": [
            "lowercase",
            "type_as_payload"
          ]
        }
      }
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Second, we add some documents:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT /my-index-000001/_doc/1
{
  "fullname" : "John Doe",
  "text" : "test test test "
}

PUT /my-index-000001/_doc/2?refresh=wait_for
{
  "fullname" : "Jane Doe",
  "text" : "Another test ..."
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following request returns all information and statistics for field
<code>text</code> in document <code>1</code> (John Doe):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /my-index-000001/_termvectors/1
{
  "fields" : ["text"],
  "offsets" : true,
  "payloads" : true,
  "positions" : true,
  "term_statistics" : true,
  "field_statistics" : true
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "_index": "my-index-000001",
  "_type": "_doc",
  "_id": "1",
  "_version": 1,
  "found": true,
  "took": 6,
  "term_vectors": {
    "text": {
      "field_statistics": {
        "sum_doc_freq": 4,
        "doc_count": 2,
        "sum_ttf": 6
      },
      "terms": {
        "test": {
          "doc_freq": 2,
          "ttf": 4,
          "term_freq": 3,
          "tokens": [
            {
              "position": 0,
              "start_offset": 0,
              "end_offset": 4,
              "payload": "d29yZA=="
            },
            {
              "position": 1,
              "start_offset": 5,
              "end_offset": 9,
              "payload": "d29yZA=="
            },
            {
              "position": 2,
              "start_offset": 10,
              "end_offset": 14,
              "payload": "d29yZA=="
            }
          ]
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="docs-termvectors-api-generate-termvectors">Generating term vectors on the fly</h5>
<div class="paragraph">
<p>Term vectors which are not explicitly stored in the index are automatically
computed on the fly. The following request returns all information and statistics for the
fields in document <code>1</code>, even though the terms haven&#8217;t been explicitly stored in the index.
Note that for the field <code>text</code>, the terms are not re-generated.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /my-index-000001/_termvectors/1
{
  "fields" : ["text", "some_field_without_term_vectors"],
  "offsets" : true,
  "positions" : true,
  "term_statistics" : true,
  "field_statistics" : true
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="docs-termvectors-artificial-doc">Artificial documents</h5>
<div class="paragraph">
<p>Term vectors can also be generated for artificial documents,
that is for documents not present in the index.  For example, the following request would
return the same results as in example 1. The mapping used is determined by the <code>index</code>.</p>
</div>
<div class="paragraph">
<p><strong>If dynamic mapping is turned on (default), the document fields not in the original
mapping will be dynamically created.</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /my-index-000001/_termvectors
{
  "doc" : {
    "fullname" : "John Doe",
    "text" : "test test test"
  }
}</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="docs-termvectors-per-field-analyzer">Per-field analyzer</h6>
<div class="paragraph">
<p>Additionally, a different analyzer than the one at the field may be provided
by using the <code>per_field_analyzer</code> parameter. This is useful in order to
generate term vectors in any fashion, especially when using artificial
documents. When providing an analyzer for a field that already stores term
vectors, the term vectors will be re-generated.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /my-index-000001/_termvectors
{
  "doc" : {
    "fullname" : "John Doe",
    "text" : "test test test"
  },
  "fields": ["fullname"],
  "per_field_analyzer" : {
    "fullname": "keyword"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "_index": "my-index-000001",
  "_type": "_doc",
  "_version": 0,
  "found": true,
  "took": 6,
  "term_vectors": {
    "fullname": {
       "field_statistics": {
          "sum_doc_freq": 2,
          "doc_count": 4,
          "sum_ttf": 4
       },
       "terms": {
          "John Doe": {
             "term_freq": 1,
             "tokens": [
                {
                   "position": 0,
                   "start_offset": 0,
                   "end_offset": 8
                }
             ]
          }
       }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="docs-termvectors-terms-filtering">Terms filtering</h5>
<div class="paragraph">
<p>Finally, the terms returned could be filtered based on their tf-idf scores. In
the example below we obtain the three most "interesting" keywords from the
artificial document having the given "plot" field value. Notice
that the keyword "Tony" or any stop words are not part of the response, as
their tf-idf must be too low.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET /imdb/_termvectors
{
  "doc": {
    "plot": "When wealthy industrialist Tony Stark is forced to build an armored suit after a life-threatening incident, he ultimately decides to use its technology to fight against evil."
  },
  "term_statistics": true,
  "field_statistics": true,
  "positions": false,
  "offsets": false,
  "filter": {
    "max_num_terms": 3,
    "min_term_freq": 1,
    "min_doc_freq": 1
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
   "_index": "imdb",
   "_type": "_doc",
   "_version": 0,
   "found": true,
   "term_vectors": {
      "plot": {
         "field_statistics": {
            "sum_doc_freq": 3384269,
            "doc_count": 176214,
            "sum_ttf": 3753460
         },
         "terms": {
            "armored": {
               "doc_freq": 27,
               "ttf": 27,
               "term_freq": 1,
               "score": 9.74725
            },
            "industrialist": {
               "doc_freq": 88,
               "ttf": 88,
               "term_freq": 1,
               "score": 8.590818
            },
            "stark": {
               "doc_freq": 44,
               "ttf": 47,
               "term_freq": 1,
               "score": 9.272792
            }
         }
      }
   }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="docs-multi-termvectors">Multi term vectors API</h3>
<titleabbrev>Multi term vectors</titleabbrev>
<div class="paragraph">
<p>Retrieves multiple term vectors with a single request.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /_mtermvectors
{
   "docs": [
      {
         "_index": "my-index-000001",
         "_id": "2",
         "term_statistics": true
      },
      {
         "_index": "my-index-000001",
         "_id": "1",
         "fields": [
            "message"
         ]
      }
   ]
}</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="docs-multi-termvectors-api-request">Request</h4>
<div class="paragraph">
<p><code>POST /_mtermvectors</code></p>
</div>
<div class="paragraph">
<p><code>POST /&lt;index&gt;/_mtermvectors</code></p>
</div>
</div>
<div class="sect3">
<h4 id="docs-multi-termvectors-api-desc">Description</h4>
<div class="paragraph">
<p>You can specify existing documents by index and ID or
provide artificial documents in the body of the request.
You can specify the index in the request body or request URI.</p>
</div>
<div class="paragraph">
<p>The response contains a <code>docs</code> array with all the fetched termvectors.
Each element has the structure provided by the <a href="docs.html#docs-termvectors">termvectors</a>
API.</p>
</div>
<div class="paragraph">
<p>See the <a href="docs.html#docs-termvectors">termvectors</a> API for more information about the information
that can be included in the response.</p>
</div>
</div>
<div class="sect3">
<h4 id="docs-multi-termvectors-api-path-params">Path parameters</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>&lt;index&gt;</code></dt>
<dd>
<p>(Optional, string) Name of the index that contains the documents.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="docs-multi-termvectors-api-query-params">Query parameters</h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>fields</code></dt>
<dd>
<div class="openblock">
<div class="content">
<div class="paragraph">
<p>(Optional, string)
Comma-separated list or wildcard expressions of fields
to include in the statistics.</p>
</div>
<div class="paragraph">
<p>Used as the default list
unless a specific field list is provided
in the <code>completion_fields</code> or <code>fielddata_fields</code> parameters.</p>
</div>
</div>
</div>
</dd>
<dt class="hdlist1"><code>field_statistics</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, the response includes the document count, sum of document frequencies,
and sum of total term frequencies.
Defaults to <code>true</code>.</p>
</dd>
<dt class="hdlist1"><code>&lt;offsets&gt;</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, the response includes term offsets.
Defaults to <code>true</code>.</p>
</dd>
<dt class="hdlist1"><code>payloads</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, the response includes term payloads.
Defaults to <code>true</code>.</p>
</dd>
<dt class="hdlist1"><code>positions</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, the response includes term positions.
Defaults to <code>true</code>.</p>
</dd>
<dt class="hdlist1"><code>preference</code></dt>
<dd>
<p>(Optional, string) Specifies the node or shard the operation should be
performed on. Random by default.</p>
</dd>
<dt class="hdlist1"><code>routing</code></dt>
<dd>
<p>(Optional, string) Target the specified primary shard.</p>
</dd>
<dt class="hdlist1"><code>realtime</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, the request is real-time as opposed to near-real-time.
Defaults to <code>true</code>. See <a href="docs.html#realtime">Realtime</a>.</p>
</dd>
<dt class="hdlist1"><code>term_statistics</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, the response includes term frequency and document frequency.
Defaults to <code>false</code>.</p>
</dd>
<dt class="hdlist1"><code>version</code></dt>
<dd>
<p>(Optional, Boolean) If <code>true</code>, returns the document version as part of a hit.</p>
</dd>
<dt class="hdlist1"><code>version_type</code></dt>
<dd>
<p>(Optional, enum) Specific version type: <code>internal</code>, <code>external</code>,
<code>external_gte</code>.</p>
</dd>
</dl>
</div>
<h4 id="docs-multi-termvectors-api-example" class="discrete">Examples</h4>
<div class="paragraph">
<p>If you specify an index in the request URI, the index does not need to be specified for each documents
in the request body:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /my-index-000001/_mtermvectors
{
   "docs": [
      {
         "_id": "2",
         "fields": [
            "message"
         ],
         "term_statistics": true
      },
      {
         "_id": "1"
      }
   ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If all requested documents are in same index and the parameters are the same, you can use the
following simplified syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /my-index-000001/_mtermvectors
{
  "ids": [ "1", "2" ],
  "parameters": {
    "fields": [
      "message"
    ],
    "term_statistics": true
  }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="docs-multi-termvectors-artificial-doc">Artificial documents</h5>
<div class="paragraph">
<p>You can also use <code>mtermvectors</code> to generate term vectors for <em>artificial</em> documents provided
in the body of the request. The mapping used is determined by the specified <code>_index</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">POST /_mtermvectors
{
   "docs": [
      {
         "_index": "my-index-000001",
         "doc" : {
            "message" : "test test test"
         }
      },
      {
         "_index": "my-index-000001",
         "doc" : {
           "message" : "Another test ..."
         }
      }
   ]
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="docs-refresh"><code>?refresh</code></h3>
<div class="paragraph">
<p>The <a href="docs.html#docs-index_">Index</a>, <a href="docs.html#docs-update">Update</a>, <a href="docs.html#docs-delete">Delete</a>, and
<a href="docs.html#docs-bulk">Bulk</a> APIs support setting <code>refresh</code> to control when changes made
by this request are made visible to search. These are the allowed values:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Empty string or <code>true</code></dt>
<dd>
<p>Refresh the relevant primary and replica shards (not the whole index)
immediately after the operation occurs, so that the updated document appears
in search results immediately. This should <strong>ONLY</strong> be done after careful thought
and verification that it does not lead to poor performance, both from an
indexing and a search standpoint.</p>
</dd>
<dt class="hdlist1"><code>wait_for</code></dt>
<dd>
<p>Wait for the changes made by the request to be made visible by a refresh before
replying. This doesn&#8217;t force an immediate refresh, rather, it waits for a
refresh to happen. OpenSearch automatically refreshes shards that have changed
every <code>index.refresh_interval</code> which defaults to one second. That setting is
<a href="index-modules.html#dynamic-index-settings">dynamic</a>. Calling the <a href="indices.html#indices-refresh">Refresh API</a> API or
setting <code>refresh</code> to <code>true</code> on any of the APIs that support it will also
cause a refresh, in turn causing already running requests with <code>refresh=wait_for</code>
to return.</p>
</dd>
<dt class="hdlist1"><code>false</code> (the default)</dt>
<dd>
<p>Take no refresh related actions. The changes made by this request will be made
visible at some point after the request returns.</p>
</dd>
</dl>
</div>
<h4 id="_choosing_which_setting_to_use" class="discrete">Choosing which setting to use</h4>
<div class="paragraph">
<p>Unless you have a good reason to wait for the change to become visible, always
use <code>refresh=false</code> (the default setting). The simplest and fastest choice is to omit the <code>refresh</code> parameter from the URL.</p>
</div>
<div class="paragraph">
<p>If you absolutely must have the changes made by a request visible synchronously
with the request, you must choose between putting more load on
OpenSearch (<code>true</code>) and waiting longer for the response (<code>wait_for</code>).
Here are a few points that should inform that decision:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The more changes being made to the index the more work <code>wait_for</code> saves
compared to <code>true</code>. In the case that the index is only changed once every
<code>index.refresh_interval</code> then it saves no work.</p>
</li>
<li>
<p><code>true</code> creates less efficient indexes constructs (tiny segments) that must
later be merged into more efficient index constructs (larger segments). Meaning
that the cost of <code>true</code> is paid at index time to create the tiny segment, at
search time to search the tiny segment, and at merge time to make the larger
segments.</p>
</li>
<li>
<p>Never start multiple <code>refresh=wait_for</code> requests in a row. Instead batch them
into a single bulk request with <code>refresh=wait_for</code> and OpenSearch will start
them all in parallel and return only when they have all finished.</p>
</li>
<li>
<p>If the refresh interval is set to <code>-1</code>, disabling the automatic refreshes,
then requests with <code>refresh=wait_for</code> will wait indefinitely until some action
causes a refresh. Conversely, setting <code>index.refresh_interval</code> to something
shorter than the default like <code>200ms</code> will make <code>refresh=wait_for</code> come back
faster, but it&#8217;ll still generate inefficient segments.</p>
</li>
<li>
<p><code>refresh=wait_for</code> only affects the request that it is on, but, by forcing a
refresh immediately, <code>refresh=true</code> will affect other ongoing request. In
general, if you have a running system you don&#8217;t wish to disturb then
<code>refresh=wait_for</code> is a smaller modification.</p>
</li>
</ul>
</div>
<h4 id="refresh_wait_for-force-refresh" class="discrete"><code>refresh=wait_for</code> Can Force a Refresh</h4>
<div class="paragraph">
<p>If a <code>refresh=wait_for</code> request comes in when there are already
<code>index.max_refresh_listeners</code> (defaults to 1000) requests waiting for a refresh
on that shard then that request will behave just as though it had <code>refresh</code> set
to <code>true</code> instead: it will force a refresh. This keeps the promise that when a
<code>refresh=wait_for</code> request returns that its changes are visible for search
while preventing unchecked resource usage for blocked requests. If a request
forced a refresh because it ran out of listener slots then its response will
contain <code>"forced_refresh": true</code>.</p>
</div>
<div class="paragraph">
<p>Bulk requests only take up one slot on each shard that they touch no matter how
many times they modify the shard.</p>
</div>
<h4 id="_examples_4" class="discrete">Examples</h4>
<div class="paragraph">
<p>These will create a document and immediately refresh the index so it is visible:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT /test/_doc/1?refresh
{"test": "test"}
PUT /test/_doc/2?refresh=true
{"test": "test"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>These will create a document without doing anything to make it visible for
search:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT /test/_doc/3
{"test": "test"}
PUT /test/_doc/4?refresh=false
{"test": "test"}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will create a document and wait for it to become visible for search:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT /test/_doc/4?refresh=wait_for
{"test": "test"}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="optimistic-concurrency-control">Optimistic concurrency control</h3>
<div class="paragraph">
<p>OpenSearch is distributed. When documents are created, updated, or deleted,
the new version of the document has to be replicated to other nodes in the cluster.
OpenSearch is also asynchronous and concurrent, meaning that these replication
requests are sent in parallel, and may arrive at their destination out of sequence.
OpenSearch needs a way of ensuring that an older version of a document never
overwrites a newer version.</p>
</div>
<div class="paragraph">
<p>To ensure an older version of a document doesn&#8217;t overwrite a newer version, every
operation performed to a document is assigned a sequence number by the primary
shard that coordinates that change. The sequence number is increased with each
operation and thus newer operations are guaranteed to have a higher sequence
number than older operations. OpenSearch can then use the sequence number of
operations to make sure a newer document version is never overridden by
a change that has a smaller sequence number assigned to it.</p>
</div>
<div class="paragraph">
<p>For example, the following indexing command will create a document and assign it
an initial sequence number and primary term:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT products/_doc/1567
{
  "product" : "r2d2",
  "details" : "A resourceful astromech droid"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see the assigned sequence number and primary term in the
<code>_seq_no</code> and <code>_primary_term</code> fields of the response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "_shards": {
    "total": 2,
    "failed": 0,
    "successful": 1
  },
  "_index": "products",
  "_type": "_doc",
  "_id": "1567",
  "_version": 1,
  "_seq_no": 362,
  "_primary_term": 2,
  "result": "created"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>OpenSearch keeps tracks of the sequence number and primary term of the last
operation to have changed each of the documents it stores. The sequence number
and primary term are returned in the <code>_seq_no</code> and <code>_primary_term</code> fields in
the response of the <a href="docs.html#docs-get">GET API</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">GET products/_doc/1567</code></pre>
</div>
</div>
<div class="paragraph">
<p>returns:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console-result" data-lang="console-result">{
  "_index": "products",
  "_type": "_doc",
  "_id": "1567",
  "_version": 1,
  "_seq_no": 362,
  "_primary_term": 2,
  "found": true,
  "_source": {
    "product": "r2d2",
    "details": "A resourceful astromech droid"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note: The <a href="search.html#search-search">Search API</a> can return the <code>_seq_no</code> and <code>_primary_term</code>
for each search hit by setting <a href="search.html#request-body-search-seq-no-primary-term"><code>seq_no_primary_term</code> parameter</a>.</p>
</div>
<div class="paragraph">
<p>The sequence number and the primary term uniquely identify a change. By noting down
the sequence number and primary term returned, you can make sure to only change the
document if no other change was made to it since you retrieved it. This
is done by setting the <code>if_seq_no</code> and <code>if_primary_term</code> parameters of the
<a href="docs.html#docs-index_">index API</a>, <a href="docs.html#docs-update">update API</a>, or <a href="docs.html#docs-delete">delete
API</a>.</p>
</div>
<div class="paragraph">
<p>For example, the following indexing call will make sure to add a tag to the
document without losing any potential change to the description or an addition
of another tag by another API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">PUT products/_doc/1567?if_seq_no=362&amp;if_primary_term=2
{
  "product": "r2d2",
  "details": "A resourceful astromech droid",
  "tags": [ "droid" ]
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="paragraph nav-footer">
<p>← Previous: <a href="cluster.html">Cluster APIs</a> | ↑ Up: <a href="rest-apis.html">REST APIs</a> | ⌂ Home: <a href="index.html">OpenSearch Reference</a> | Next: <a href="indices.html">Index APIs</a> →</p>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-04-12 14:08:20 -0700
</div>
</div>
</body>
</html>